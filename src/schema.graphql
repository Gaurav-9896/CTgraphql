"""
API Clients can be used to obtain OAuth 2 access tokens. The secret is only shown once in the response of creating the API Client.
"""
type APIClientWithSecret {
  accessTokenValiditySeconds: Int
  createdAt: DateTime
  deleteAt: DateTime
  id: String!
  lastUsedAt: Date
  name: String!
  refreshTokenValiditySeconds: Int
  scope: String!
  secret: String!
}

"""API Clients can be used to obtain OAuth 2 access tokens"""
type APIClientWithoutSecret {
  accessTokenValiditySeconds: Int
  createdAt: DateTime
  deleteAt: DateTime
  id: String!
  lastUsedAt: Date
  name: String!
  refreshTokenValiditySeconds: Int
  scope: String!
}

type APIClientWithoutSecretQueryResult {
  count: Int!
  exists: Boolean!
  offset: Int!
  results: [APIClientWithoutSecret!]!
  total: Long!
}

type AWSLambdaDestination implements ExtensionDestination {
  accessKey: String!
  accessSecret: String!
  arn: String!
  type: String!
}

input AWSLambdaDestinationInput {
  accessKey: String!
  accessSecret: String!
  arn: String!
}

type AbsoluteDiscountValue implements CartDiscountValue & ProductDiscountValue {
  money: [Money!]!
  type: String!
}

input AbsoluteDiscountValueInput {
  money: [MoneyInput!]!
}

enum ActionType {
  Create
  Update
}

"""A field to access the active cart."""
interface ActiveCartInterface {
  activeCart: Cart
}

input AddAssociateRolePermission {
  permission: Permission!
}

input AddAttributeGroupAttribute {
  attribute: AttributeReferenceInput!
}

input AddBusinessUnitAddress {
  address: AddressInput!
}

input AddBusinessUnitAssociate {
  associate: AssociateDraft!
}

input AddBusinessUnitBillingAddressId {
  addressId: String
  addressKey: String
}

input AddBusinessUnitShippingAddressId {
  addressId: String
  addressKey: String
}

input AddBusinessUnitStore {
  store: ResourceIdentifierInput!
}

input AddCartCustomLineItem {
  custom: CustomFieldsDraft
  externalTaxRate: ExternalTaxRateDraft
  key: String
  money: BaseMoneyInput!
  name: [LocalizedStringItemInputType!]!
  priceMode: CustomLineItemPriceMode = Standard
  quantity: Long
  shippingDetails: ItemShippingDetailsDraft
  slug: String!
  taxCategory: ResourceIdentifierInput
}

input AddCartCustomShippingMethod {
  custom: CustomFieldsDraft
  deliveries: [DeliveryDraft!] = []
  externalTaxRate: ExternalTaxRateDraft
  shippingAddress: AddressInput!
  shippingKey: String!
  shippingMethodName: String!
  shippingRate: ShippingRateDraft!
  shippingRateInput: ShippingRateInputDraft
  taxCategory: ResourceIdentifierInput
}

input AddCartDiscountCode {
  code: String!
  validateDuplicates: Boolean = false
}

input AddCartDiscountStore {
  store: ResourceIdentifierInput!
}

input AddCartItemShippingAddress {
  address: AddressInput!
}

input AddCartLineItem {
  addedAt: DateTime
  custom: CustomFieldsDraft
  distributionChannel: ResourceIdentifierInput
  externalPrice: BaseMoneyInput
  externalTaxRate: ExternalTaxRateDraft
  externalTotalPrice: ExternalLineItemTotalPriceDraft
  inventoryMode: InventoryMode
  key: String
  perMethodExternalTaxRate: [MethodExternalTaxRateDraft!] = []
  productId: String
  quantity: Long
  shippingDetails: ItemShippingDetailsDraft
  sku: String
  supplyChannel: ResourceIdentifierInput
  variantId: Int
}

input AddCartPayment {
  payment: ResourceIdentifierInput!
}

input AddCartShippingMethod {
  custom: CustomFieldsDraft
  deliveries: [DeliveryDraft!] = []
  externalTaxRate: ExternalTaxRateDraft
  shippingAddress: AddressInput!
  shippingKey: String!
  shippingMethod: ResourceIdentifierInput!
  shippingRateInput: ShippingRateInputDraft
}

input AddCartShoppingList {
  distributionChannel: ResourceIdentifierInput
  shoppingList: ResourceIdentifierInput!
  supplyChannel: ResourceIdentifierInput
}

input AddCategoryAsset {
  asset: AssetDraftInput!
  position: Int
}

input AddChannelRoles {
  roles: [ChannelRole!]!
}

input AddCustomerAddress {
  address: AddressInput!
}

input AddCustomerBillingAddressId {
  addressId: String
  addressKey: String
}

input AddCustomerGroupAssignment {
  customerGroupAssignment: CustomerGroupAssignmentDraft!
}

input AddCustomerShippingAddressId {
  addressId: String
  addressKey: String
}

input AddCustomerStore {
  store: ResourceIdentifierInput!
}

input AddInventoryEntryQuantity {
  quantity: Long!
}

input AddMyBusinessUnitAddress {
  address: AddressInput!
}

input AddMyBusinessUnitBillingAddressId {
  addressId: String
  addressKey: String
}

input AddMyBusinessUnitShippingAddressId {
  addressId: String
  addressKey: String
}

input AddMyCartLineItem {
  addedAt: DateTime
  custom: CustomFieldsDraft
  distributionChannel: ResourceIdentifierInput
  key: String
  productId: String
  quantity: Long
  shippingDetails: ItemShippingDetailsDraft
  sku: String
  supplyChannel: ResourceIdentifierInput
  variantId: Int
}

input AddMyPaymentTransaction {
  transaction: MyTransactionDraft!
}

input AddOrderDelivery {
  address: AddressInput
  custom: CustomFieldsDraft
  deliveryKey: String
  items: [DeliveryItemDraftType!] = []
  parcels: [ParcelDataDraftType!] = []
  shippingKey: String
}

input AddOrderEditStagedAction {
  stagedAction: StagedOrderUpdateAction!
}

input AddOrderItemShippingAddress {
  address: AddressInput!
}

input AddOrderParcelToDelivery {
  custom: CustomFieldsDraft
  deliveryId: String
  deliveryKey: String
  items: [DeliveryItemDraftType!] = []
  measurements: ParcelMeasurementsDraftType
  parcelKey: String
  trackingData: TrackingDataDraftType
}

input AddOrderPayment {
  payment: ResourceIdentifierInput!
}

input AddOrderReturnInfo {
  items: [ReturnItemDraftType!]!
  returnDate: DateTime
  returnTrackingId: String
}

input AddPaymentInterfaceInteraction {
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeId: String
  typeKey: String
}

input AddPaymentTransaction {
  transaction: TransactionDraft!
}

input AddProductAsset {
  asset: AssetDraftInput!
  position: Int
  sku: String
  staged: Boolean = true
  variantId: Int
}

input AddProductExternalImage {
  image: ImageInput!
  sku: String
  staged: Boolean = true
  variantId: Int
}

input AddProductPrice {
  price: ProductPriceDataInput!
  sku: String
  staged: Boolean = true
  variantId: Int
}

input AddProductSelectionProduct {
  product: ResourceIdentifierInput!
  variantSelection: ProductVariantSelectionDraft
}

input AddProductToCategory {
  category: ResourceIdentifierInput!
  orderHint: String
  staged: Boolean = true
}

input AddProductVariant {
  assets: [AssetDraftInput!] = []
  attributes: [ProductAttributeInput!] = []
  images: [ImageInput!] = []
  key: String
  prices: [ProductPriceDataInput!] = []
  sku: String
  staged: Boolean = true
}

input AddShippingMethodShippingRate {
  shippingRate: ShippingRateDraft!
  zone: ResourceIdentifierInput!
}

input AddShippingMethodZone {
  zone: ResourceIdentifierInput!
}

input AddShoppingListLineItem {
  addedAt: DateTime
  custom: CustomFieldsDraft
  key: String
  productId: String
  quantity: Int = 1
  sku: String
  variantId: Int
}

input AddShoppingListTextLineItem {
  addedAt: DateTime
  custom: CustomFieldsDraft
  description: [LocalizedStringItemInputType!]
  key: String
  name: [LocalizedStringItemInputType!]!
  quantity: Int = 1
}

input AddStagedOrderCustomLineItem {
  custom: CustomFieldsDraft
  externalTaxRate: ExternalTaxRateDraft
  key: String
  money: BaseMoneyInput!
  name: [LocalizedStringItemInputType!]!
  priceMode: CustomLineItemPriceMode = Standard
  quantity: Long
  shippingDetails: ItemShippingDetailsDraftType
  slug: String!
  taxCategory: ResourceIdentifierInput
}

type AddStagedOrderCustomLineItemOutput implements StagedOrderUpdateActionOutput {
  draft: CustomLineItemDraftOutput!
  type: String!
}

input AddStagedOrderDelivery {
  address: AddressInput
  custom: CustomFieldsDraft
  deliveryKey: String
  items: [DeliveryItemDraftType!] = []
  parcels: [ParcelDataDraftType!] = []
  shippingKey: String
}

type AddStagedOrderDeliveryOutput implements StagedOrderUpdateActionOutput {
  address: AddressDraft
  custom: CustomFieldsCommand
  deliveryKey: String
  items: [DeliveryItem!]!
  parcels: [ParcelData!]!
  shippingKey: String
  type: String!
}

input AddStagedOrderDiscountCode {
  code: String!
  validateDuplicates: Boolean = false
}

type AddStagedOrderDiscountCodeOutput implements StagedOrderUpdateActionOutput {
  code: String!
  type: String!
  validateDuplicates: Boolean!
}

input AddStagedOrderItemShippingAddress {
  address: AddressInput!
}

type AddStagedOrderItemShippingAddressOutput implements StagedOrderUpdateActionOutput {
  address: AddressDraft!
  type: String!
}

input AddStagedOrderLineItem {
  addedAt: DateTime
  custom: CustomFieldsDraft
  distributionChannel: ResourceIdentifierInput
  externalPrice: BaseMoneyInput
  externalTaxRate: ExternalTaxRateDraft
  externalTotalPrice: ExternalLineItemTotalPriceDraft
  inventoryMode: InventoryMode
  key: String
  perMethodExternalTaxRate: [MethodExternalTaxRateDraft!] = []
  productId: String
  quantity: Long
  shippingDetails: ItemShippingDetailsDraftType
  sku: String
  supplyChannel: ResourceIdentifierInput
  variantId: Int
}

type AddStagedOrderLineItemOutput implements StagedOrderUpdateActionOutput {
  draft: LineItemDraftOutput!
  type: String!
}

input AddStagedOrderParcelToDelivery {
  custom: CustomFieldsDraft
  deliveryId: String
  deliveryKey: String
  items: [DeliveryItemDraftType!] = []
  measurements: ParcelMeasurementsDraftType
  parcelKey: String
  trackingData: TrackingDataDraftType
}

type AddStagedOrderParcelToDeliveryOutput implements StagedOrderUpdateActionOutput {
  custom: CustomFieldsCommand
  deliveryId: String
  deliveryKey: String
  items: [DeliveryItem!]!
  measurements: ParcelMeasurements
  parcelKey: String
  trackingData: TrackingData
  type: String!
}

input AddStagedOrderPayment {
  payment: ResourceIdentifierInput!
}

type AddStagedOrderPaymentOutput implements StagedOrderUpdateActionOutput {
  paymentResId: ResourceIdentifier!
  type: String!
}

input AddStagedOrderReturnInfo {
  items: [ReturnItemDraftType!]!
  returnDate: DateTime
  returnTrackingId: String
}

type AddStagedOrderReturnInfoOutput implements StagedOrderUpdateActionOutput {
  items: [ReturnItemDraftTypeOutput!]!
  returnDate: DateTime
  returnTrackingId: String
  type: String!
}

input AddStagedOrderShoppingList {
  distributionChannel: ResourceIdentifierInput
  shoppingList: ResourceIdentifierInput!
  supplyChannel: ResourceIdentifierInput
}

type AddStagedOrderShoppingListOutput implements StagedOrderUpdateActionOutput {
  distributionChannelResId: ChannelReferenceIdentifier
  shoppingListResId: ResourceIdentifier!
  supplyChannelResId: ChannelReferenceIdentifier
  type: String!
}

input AddStandalonePriceTier {
  tier: ProductPriceTierInput!
}

input AddStateRoles {
  roles: [StateRole!]!
}

input AddStoreCountry {
  country: StoreCountryInput!
}

input AddStoreDistributionChannel {
  distributionChannel: ResourceIdentifierInput!
}

input AddStoreProductSelection {
  active: Boolean
  productSelection: ResourceIdentifierInput!
}

input AddStoreSupplyChannel {
  supplyChannel: ResourceIdentifierInput!
}

input AddTypeEnumValue {
  fieldName: String!
  value: EnumValueInput!
}

input AddTypeFieldDefinition {
  fieldDefinition: FieldDefinitionInput!
}

input AddTypeLocalizedEnumValue {
  fieldName: String!
  value: LocalizedEnumValueInput!
}

input AddZoneLocation {
  location: ZoneLocation!
}

"""An address represents a postal address."""
type Address {
  additionalAddressInfo: String
  additionalStreetInfo: String
  apartment: String
  building: String
  city: String
  company: String
  country: Country!
  custom: CustomFieldsType
  department: String
  email: String
  externalId: String
  fax: String
  firstName: String
  id: String
  key: String
  lastName: String
  mobile: String
  pOBox: String
  phone: String
  postalCode: String
  region: String
  salutation: String
  state: String
  streetName: String
  streetNumber: String
  title: String
}

type AddressDraft {
  additionalAddressInfo: String
  additionalStreetInfo: String
  apartment: String
  building: String
  city: String
  company: String
  country: Country!
  custom: CustomFieldsCommand
  department: String
  email: String
  externalId: String
  fax: String
  firstName: String
  id: String
  key: String
  lastName: String
  mobile: String
  pOBox: String
  phone: String
  postalCode: String
  region: String
  salutation: String
  state: String
  streetName: String
  streetNumber: String
  title: String
}

input AddressInput {
  additionalAddressInfo: String
  additionalStreetInfo: String
  apartment: String
  building: String
  city: String
  company: String
  country: Country!
  custom: CustomFieldsDraft
  department: String
  email: String
  externalId: String
  fax: String
  firstName: String
  id: String
  key: String
  lastName: String
  mobile: String
  pOBox: String
  phone: String
  postalCode: String
  region: String
  salutation: String
  state: String
  streetName: String
  streetNumber: String
  title: String
}

enum AnonymousCartSignInMode {
  """
  `LineItem`s of the anonymous cart will be copied to the customer’s active cart that has been modified most recently.
  
  The `CartState` of the anonymous cart gets changed to `Merged` while the `CartState` of the customer’s cart remains `Active`.
  
  `CustomLineItems` and `CustomFields` of the anonymous cart will not be copied to the customers cart.
  
  If a `LineItem` in the anonymous cart matches an existing line item in the customer’s cart (same product ID and variant ID), the maximum quantity of both LineItems is used as the new quantity. In that case `CustomFields` on the `LineItem` of the anonymous cart will not be in the resulting `LineItem`.
  """
  MergeWithExistingCustomerCart

  """
  The anonymous cart is used as new active customer cart. No `LineItem`s get merged.
  """
  UseAsNewActiveCustomerCart
}

type Applied implements OrderEditResult {
  appliedAt: DateTime!
  excerptAfterEdit: OrderExcerpt!
  excerptBeforeEdit: OrderExcerpt!
  type: String!
}

input ApplyCartDeltaToCustomLineItemShippingDetailsTargets {
  customLineItemId: String
  customLineItemKey: String
  targetsDelta: [ShippingTargetDraft!]!
}

input ApplyCartDeltaToLineItemShippingDetailsTargets {
  lineItemId: String
  lineItemKey: String
  targetsDelta: [ShippingTargetDraft!]!
}

input ApplyStagedChanges {
  dummy: String
}

type ApprovalFlow implements Versioned {
  approvals: [ApprovalFlowApproval!]!
  businessUnit: BusinessUnit!
  businessUnitRef: KeyReference!
  createdAt: DateTime!
  createdBy: Initiator
  currentTierPendingApprovers: [RuleApprover!]!
  custom: CustomFieldsType
  eligibleApprovers: [RuleApprover!]!
  id: String!
  lastModifiedAt: DateTime!
  lastModifiedBy: Initiator
  order: Order
  orderRef: Reference!
  pendingApprovers: [RuleApprover!]!
  rejection: ApprovalFlowRejection
  rules: [ApprovalRule!]!
  status: String!
  version: Long!
}

type ApprovalFlowApproval {
  approvedAt: DateTime!
  approver: Associate!
}

type ApprovalFlowApproved implements MessagePayload {
  associate: Customer
  associateRef: Reference
  order: Order
  orderRef: Reference
  type: String!
}

type ApprovalFlowCompleted implements MessagePayload {
  order: Order
  orderRef: Reference
  status: String!
  type: String!
}

type ApprovalFlowCreated implements MessagePayload {
  approvalFlow: ApprovalFlow!
  type: String!
}

type ApprovalFlowQueryResult {
  count: Int!
  exists: Boolean!
  offset: Int!
  results: [ApprovalFlow!]!
  total: Long!
}

type ApprovalFlowRejected implements MessagePayload {
  associate: Customer
  associateRef: Reference
  order: Order
  orderRef: Reference
  rejectionReason: String
  type: String!
}

type ApprovalFlowRejection {
  reason: String
  rejectedAt: DateTime!
  rejecter: Associate!
}

input ApprovalFlowUpdateAction {
  approve: ApproveApprovalFlow
  reject: RejectApprovalFlow
  setCustomField: SetApprovalFlowCustomField
  setCustomType: SetApprovalFlowCustomType
}

type ApprovalRule implements Versioned {
  approvers: ApproverHierarchy!
  businessUnit: BusinessUnit!
  businessUnitRef: KeyReference!
  createdAt: DateTime!
  createdBy: Initiator
  description: String
  id: String!
  key: String
  lastModifiedAt: DateTime!
  lastModifiedBy: Initiator
  name: String!
  predicate: String!
  requesters: [RuleRequester!]!
  status: ApprovalRuleStatus!
  version: Long!
}

type ApprovalRuleApproversSet implements MessagePayload {
  approvers: ApproverHierarchy!
  oldApprovers: ApproverHierarchy!
  type: String!
}

type ApprovalRuleCreated implements MessagePayload {
  approvalRule: ApprovalRule!
  type: String!
}

type ApprovalRuleDescriptionSet implements MessagePayload {
  description: String
  oldDescription: String
  type: String!
}

input ApprovalRuleDraft {
  approvers: ApproverHierarchyDraft!
  description: String
  key: String
  name: String!
  predicate: String!
  requesters: [RuleRequesterDraft!]!
  status: ApprovalRuleStatus!
}

type ApprovalRuleKeySet implements MessagePayload {
  key: String
  oldKey: String
  type: String!
}

type ApprovalRuleNameSet implements MessagePayload {
  name: String!
  oldName: String!
  type: String!
}

type ApprovalRulePredicateSet implements MessagePayload {
  oldPredicate: String!
  predicate: String!
  type: String!
}

type ApprovalRuleQueryResult {
  count: Int!
  exists: Boolean!
  offset: Int!
  results: [ApprovalRule!]!
  total: Long!
}

type ApprovalRuleRequestersSet implements MessagePayload {
  oldRequesters: [RuleRequester!]!
  requesters: [RuleRequester!]!
  type: String!
}

enum ApprovalRuleStatus {
  Active
  Inactive
}

type ApprovalRuleStatusSet implements MessagePayload {
  oldStatus: ApprovalRuleStatus!
  status: ApprovalRuleStatus!
  type: String!
}

input ApprovalRuleUpdateAction {
  setApprovers: SetApprovalRuleApprovers
  setDescription: SetApprovalRuleDescription
  setKey: SetApprovalRuleKey
  setName: SetApprovalRuleName
  setPredicate: SetApprovalRulePredicate
  setRequesters: SetApprovalRuleRequesters
  setStatus: SetApprovalRuleStatus
}

input ApproveApprovalFlow {
  dummy: String
}

type ApproverConjunction {
  and: [ApproverDisjunction!]!
}

input ApproverConjunctionDraft {
  and: [ApproverDisjunctionDraft!]!
}

type ApproverDisjunction {
  or: [RuleApprover!]!
}

input ApproverDisjunctionDraft {
  or: [RuleApproverDraft!]!
}

type ApproverHierarchy {
  tiers: [ApproverConjunction!]!
}

input ApproverHierarchyDraft {
  tiers: [ApproverConjunctionDraft!]!
}

type AsAssociate implements CartQueryInterface & OrderQueryInterface & QuoteQueryInterface & QuoteRequestQueryInterface {
  approvalFlow(id: String!): ApprovalFlow
  approvalFlows(limit: Int, offset: Int, sort: [String!], where: String): ApprovalFlowQueryResult!
  approvalRule(
    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
  ): ApprovalRule
  approvalRules(limit: Int, offset: Int, sort: [String!], where: String): ApprovalRuleQueryResult!
  businessUnit(
    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
  ): BusinessUnit
  businessUnits(limit: Int, offset: Int, sort: [String!], where: String): BusinessUnitQueryResult!
  cart(id: String!): Cart
  carts(limit: Int, offset: Int, sort: [String!], where: String): CartQueryResult!
  order(
    """Queries with specified ID"""
    id: String
    orderNumber: String
  ): Order
  orders(limit: Int, offset: Int, sort: [String!], where: String): OrderQueryResult!
  quote(
    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
  ): Quote
  quoteRequest(
    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
  ): QuoteRequest
  quoteRequests(limit: Int, offset: Int, sort: [String!], where: String): QuoteRequestQueryResult!
  quotes(limit: Int, offset: Int, sort: [String!], where: String): QuoteQueryResult!
}

input AsAssociateArgument {
  associateId: String!
  businessUnitKey: KeyReferenceInput!
}

type Asset {
  custom: CustomFieldsType
  description(
    """
    List of languages the client is able to understand, and which locale variant is preferred.
    """
    acceptLanguage: [Locale!]

    """
    String is defined for different locales. This argument specifies the desired locale.
    """
    locale: Locale
  ): String
  descriptionAllLocales: [LocalizedString!]
  id: String!
  key: String
  name(
    """
    List of languages the client is able to understand, and which locale variant is preferred.
    """
    acceptLanguage: [Locale!]

    """
    String is defined for different locales. This argument specifies the desired locale.
    """
    locale: Locale
  ): String
  nameAllLocales: [LocalizedString!]!
  sources: [AssetSource!]!
  tags: [String!]!
}

type AssetDimensions {
  height: Int!
  width: Int!
}

input AssetDimensionsInput {
  height: Int!
  width: Int!
}

input AssetDraftInput {
  custom: CustomFieldsDraft
  description: [LocalizedStringItemInputType!]
  key: String
  name: [LocalizedStringItemInputType!]!
  sources: [AssetSourceInput!]
  tags: [String!]
  type: ResourceIdentifierInput
}

type AssetSource {
  contentType: String
  dimensions: AssetDimensions
  key: String
  uri: String!
}

input AssetSourceInput {
  contentType: String
  dimensions: AssetDimensionsInput
  key: String
  uri: String!
}

type Associate {
  associateRoleAssignments: [AssociateRoleAssignment!]!
  customer: Customer
  customerRef: Reference
}

input AssociateDraft {
  associateRoleAssignments: [AssociateRoleAssignmentDraft!]
  customer: ResourceIdentifierInput!
}

enum AssociateInheritanceMode {
  Disabled
  Enabled
}

type AssociateRole implements ReferenceExpandable & Versioned {
  buyerAssignable: Boolean!
  createdAt: DateTime!
  createdBy: Initiator
  custom: CustomFieldsType
  id: String!
  key: String!
  lastModifiedAt: DateTime!
  lastModifiedBy: Initiator
  name: String
  permissions: [Permission!]!
  version: Long!
}

type AssociateRoleAssignment {
  associateRole: AssociateRole!
  associateRoleRef: KeyReference
  inheritance: AssociateInheritanceMode!
}

input AssociateRoleAssignmentDraft {
  associateRole: ResourceIdentifierInput!
  inheritance: AssociateInheritanceMode
}

type AssociateRoleBuyerAssignableChanged implements MessagePayload {
  buyerAssignable: Boolean!
  type: String!
}

type AssociateRoleCreated implements MessagePayload {
  associateRole: AssociateRole!
  type: String!
}

type AssociateRoleDeleted implements MessagePayload {
  type: String!
}

input AssociateRoleDraft {
  buyerAssignable: Boolean!
  custom: CustomFieldsDraft
  key: String!
  name: String
  permissions: [Permission!]
}

type AssociateRoleNameSet implements MessagePayload {
  name: String
  type: String!
}

type AssociateRolePermissionAdded implements MessagePayload {
  permission: Permission!
  type: String!
}

type AssociateRolePermissionRemoved implements MessagePayload {
  permission: Permission!
  type: String!
}

type AssociateRolePermissionsSet implements MessagePayload {
  permissions: [Permission!]
  type: String!
}

type AssociateRoleQueryResult {
  count: Int!
  exists: Boolean!
  offset: Int!
  results: [AssociateRole!]!
  total: Long!
}

input AssociateRoleUpdateAction {
  addPermission: AddAssociateRolePermission
  changeBuyerAssignable: ChangeAssociateRoleBuyerAssignable
  removePermission: RemoveAssociateRolePermission
  setCustomField: SetAssociateRoleCustomField
  setCustomType: SetAssociateRoleCustomType
  setName: SetAssociateRoleName
  setPermissions: SetAssociateRolePermissions
}

interface Attribute {
  name: String!
}

enum AttributeConstraint {
  """
  A set of attributes, that have this constraint, should have different combinations in each variant
  """
  CombinationUnique

  """No constraints are applied to the attribute"""
  None

  """Attribute value should be the same in all variants"""
  SameForAll

  """Attribute value should be different in each variant"""
  Unique
}

type AttributeDefinition {
  attributeConstraint: AttributeConstraint!
  inputHint: TextInputHint!
  inputTip(
    """
    List of languages the client is able to understand, and which locale variant is preferred.
    """
    acceptLanguage: [Locale!]

    """
    String is defined for different locales. This argument specifies the desired locale.
    """
    locale: Locale
  ): String
  inputTipAllLocales: [LocalizedString!]
  isRequired: Boolean!
  isSearchable: Boolean!
  label(
    """
    List of languages the client is able to understand, and which locale variant is preferred.
    """
    acceptLanguage: [Locale!]

    """
    String is defined for different locales. This argument specifies the desired locale.
    """
    locale: Locale
  ): String
  labelAllLocales: [LocalizedString!]!
  name: String!
  type: AttributeDefinitionType!
}

input AttributeDefinitionDraft {
  attributeConstraint: AttributeConstraint
  inputHint: TextInputHint
  inputTip: [LocalizedStringItemInputType!]
  isRequired: Boolean!
  isSearchable: Boolean!
  label: [LocalizedStringItemInputType!]!
  name: String!
  type: AttributeTypeDraft!
}

type AttributeDefinitionResult {
  limit: Int
  offset: Int
  results: [AttributeDefinition!]!
  total: Int!
}

"""
(https://docs.commercetools.com/api/projects/productTypes#attributetype)[https://docs.commercetools.com/api/projects/productTypes#attributetype]
"""
interface AttributeDefinitionType {
  name: String!
}

type AttributeGroup implements Versioned {
  attributes: [AttributeReference!]!
  createdAt: DateTime!
  createdBy: Initiator
  description(
    """
    List of languages the client is able to understand, and which locale variant is preferred.
    """
    acceptLanguage: [Locale!]

    """
    String is defined for different locales. This argument specifies the desired locale.
    """
    locale: Locale
  ): String
  descriptionAllLocales: [LocalizedString!]
  id: String!
  key: String
  lastModifiedAt: DateTime!
  lastModifiedBy: Initiator
  name(
    """
    List of languages the client is able to understand, and which locale variant is preferred.
    """
    acceptLanguage: [Locale!]

    """
    String is defined for different locales. This argument specifies the desired locale.
    """
    locale: Locale
  ): String
  nameAllLocales: [LocalizedString!]!
  version: Long!
}

input AttributeGroupDraft {
  attributes: [AttributeReferenceInput!]!
  description: [LocalizedStringItemInputType!]
  key: String
  name: [LocalizedStringItemInputType!]!
}

type AttributeGroupLimitWithCurrent implements LimitWithCurrent {
  current: Long!
  limit: Long
}

type AttributeGroupLimitsProjection {
  total: AttributeGroupLimitWithCurrent!
}

type AttributeGroupQueryResult {
  count: Int!
  exists: Boolean!
  offset: Int!
  results: [AttributeGroup!]!
  total: Long!
}

input AttributeGroupUpdateAction {
  addAttribute: AddAttributeGroupAttribute
  changeName: ChangeAttributeGroupName
  removeAttribute: RemoveAttributeGroupAttribute
  setAttributes: SetAttributeGroupAttributes
  setDescription: SetAttributeGroupDescription
  setKey: SetAttributeGroupKey
}

type AttributeReference {
  key: String!
}

input AttributeReferenceInput {
  key: String!
}

input AttributeSetElementTypeDraft {
  boolean: SimpleAttributeTypeDraft
  date: SimpleAttributeTypeDraft
  datetime: SimpleAttributeTypeDraft
  enum: EnumTypeDraft
  lenum: LocalizableEnumTypeDraft
  ltext: SimpleAttributeTypeDraft
  money: SimpleAttributeTypeDraft
  number: SimpleAttributeTypeDraft
  reference: ReferenceTypeDefinitionDraft
  text: SimpleAttributeTypeDraft
  time: SimpleAttributeTypeDraft
}

input AttributeSetTypeDraft {
  elementType: AttributeSetElementTypeDraft!
}

input AttributeTypeDraft {
  boolean: SimpleAttributeTypeDraft
  date: SimpleAttributeTypeDraft
  datetime: SimpleAttributeTypeDraft
  enum: EnumTypeDraft
  lenum: LocalizableEnumTypeDraft
  ltext: SimpleAttributeTypeDraft
  money: SimpleAttributeTypeDraft
  number: SimpleAttributeTypeDraft
  reference: ReferenceTypeDefinitionDraft
  set: AttributeSetTypeDraft
  text: SimpleAttributeTypeDraft
  time: SimpleAttributeTypeDraft
}

type Attribution {
  clientId: String
  source: AttributionSource!
  userRef: Reference
}

enum AttributionSource {
  Export
  Import
}

"""AuthenticationMode values."""
enum AuthenticationMode {
  ExternalAuth
  Password
}

type AuthorizationHeader implements HttpDestinationAuthentication {
  headerValue: String!
  type: String!
}

input AuthorizationHeaderInput {
  headerValue: String!
}

enum AwsAuthenticationMode {
  Credentials
  IAM
}

type AzureFunctionsAuthentication implements HttpDestinationAuthentication {
  key: String!
  type: String!
}

input AzureFunctionsAuthenticationInput {
  key: String!
}

type AzureServiceBusDestination implements Destination {
  connectionString: String!
  type: String!
}

input AzureServiceBusDestinationInput {
  connectionString: String!
}

interface BaseMoney {
  centAmount: Long!
  currencyCode: Currency!
  fractionDigits: Int!
  type: String!
}

input BaseMoneyInput {
  centPrecision: MoneyInput
  highPrecision: HighPrecisionMoneyInput
}

input BaseSearchKeywordInput {
  custom: CustomSuggestTokenizerInput
  whitespace: WhitespaceSuggestTokenizerInput
}

"""
The `BigDecimal` scalar type represents signed fractional values with arbitrary precision.
"""
scalar BigDecimal

type BooleanAttribute implements Attribute {
  name: String!
  value: Boolean!
}

type BooleanAttributeDefinitionType implements AttributeDefinitionType {
  name: String!
}

type BooleanField implements CustomField {
  name: String!
  value: Boolean!
}

type BooleanType implements FieldType {
  name: String!
}

type BusinessUnit implements ReferenceExpandable & Versioned {
  addresses: [Address!]!

  """
  This field contains the BusinessUnits KeyReferences from the Company to the parent Division of this BusinessUnit in that order.
  """
  ancestors: [BusinessUnit!]!
  associateMode: BusinessUnitAssociateMode!
  associates: [Associate!]!
  billingAddressIds: [String!]!
  billingAddresses: [Address!]!
  contactEmail: String
  createdAt: DateTime!
  createdBy: Initiator
  custom: CustomFieldsType
  defaultBillingAddress: Address
  defaultBillingAddressId: String
  defaultShippingAddress: Address
  defaultShippingAddressId: String
  id: String!
  inheritedAssociates: [InheritedAssociate!]

  """
  This field contains the inherited stores from its parentUnit if storeMode is set to FromParent.
  """
  inheritedStores: [InheritedStore!]
  key: String!
  lastModifiedAt: DateTime!
  lastModifiedBy: Initiator
  name: String!
  parentUnit: BusinessUnit
  parentUnitRef: KeyReference
  shippingAddressIds: [String!]!
  shippingAddresses: [Address!]!
  status: BusinessUnitStatus!
  storeMode: String
  stores: [Store!]
  storesRef: [KeyReference!]
  topLevelUnit: BusinessUnit!
  topLevelUnitRef: KeyReference
  unitType: BusinessUnitType!
  version: Long!
}

type BusinessUnitAddressAdded implements MessagePayload {
  address: Address!
  type: String!
}

type BusinessUnitAddressChanged implements MessagePayload {
  address: Address!
  type: String!
}

type BusinessUnitAddressCustomFieldAdded implements MessagePayload {
  name: String!
  type: String!
  value: Json!
}

type BusinessUnitAddressCustomFieldChanged implements MessagePayload {
  name: String!
  oldValue: Json
  type: String!
  value: Json!
}

type BusinessUnitAddressCustomFieldRemoved implements MessagePayload {
  name: String!
  type: String!
}

type BusinessUnitAddressCustomTypeRemoved implements MessagePayload {
  oldTypeId: String
  type: String!
}

type BusinessUnitAddressCustomTypeSet implements MessagePayload {
  customFields: CustomFieldsType!
  oldTypeId: String
  type: String!
}

type BusinessUnitAddressRemoved implements MessagePayload {
  address: Address!
  type: String!
}

type BusinessUnitAssociateAdded implements MessagePayload {
  associate: Associate!
  type: String!
}

type BusinessUnitAssociateChanged implements MessagePayload {
  associate: Associate!
  type: String!
}

enum BusinessUnitAssociateMode {
  Explicit
  ExplicitAndFromParent
}

type BusinessUnitAssociateModeChanged implements MessagePayload {
  associateMode: BusinessUnitAssociateMode!
  oldAssociateMode: BusinessUnitAssociateMode
  type: String!
}

type BusinessUnitAssociateRemoved implements MessagePayload {
  associate: Associate!
  type: String!
}

type BusinessUnitAssociatesSet implements MessagePayload {
  associates: [Associate!]!
  type: String!
}

type BusinessUnitBillingAddressAdded implements MessagePayload {
  address: Address!
  type: String!
}

type BusinessUnitBillingAddressRemoved implements MessagePayload {
  address: Address!
  type: String!
}

type BusinessUnitConfiguration {
  """
  BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta
  """
  myBusinessUnitAssociateRoleOnCreation: AssociateRole

  """
  BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta
  """
  myBusinessUnitAssociateRoleOnCreationRef: KeyReference
  myBusinessUnitStatusOnCreation: BusinessUnitConfigurationStatus!
}

enum BusinessUnitConfigurationStatus {
  Active
  Inactive
}

type BusinessUnitContactEmailSet implements MessagePayload {
  contactEmail: String
  type: String!
}

type BusinessUnitCreated implements MessagePayload {
  businessUnit: BusinessUnit!
  type: String!
}

type BusinessUnitCustomFieldAdded implements MessagePayload {
  name: String!
  type: String!
  value: Json!
}

type BusinessUnitCustomFieldChanged implements MessagePayload {
  name: String!
  oldValue: Json
  type: String!
  value: Json!
}

type BusinessUnitCustomFieldRemoved implements MessagePayload {
  name: String!
  type: String!
}

type BusinessUnitCustomTypeRemoved implements MessagePayload {
  oldTypeId: String
  type: String!
}

type BusinessUnitCustomTypeSet implements MessagePayload {
  customFields: CustomFieldsType!
  oldTypeId: String
  type: String!
}

type BusinessUnitDefaultBillingAddressSet implements MessagePayload {
  address: Address
  type: String!
}

type BusinessUnitDefaultShippingAddressSet implements MessagePayload {
  address: Address
  type: String!
}

type BusinessUnitDeleted implements MessagePayload {
  type: String!
}

input BusinessUnitDraft {
  addresses: [AddressInput!]
  associateMode: BusinessUnitAssociateMode
  associates: [AssociateDraft!]

  """
  The indices of the billing addresses in the `addresses` list. The `billingAddressIds` of the customer will be set to the IDs of that addresses.
  """
  billingAddresses: [Int!] = []
  contactEmail: String
  custom: CustomFieldsDraft

  """
  The index of the address in the `addresses` list. The `defaultBillingAddressId` of the customer will be set to the ID of that address.
  """
  defaultBillingAddress: Int

  """
  The index of the address in the `addresses` list. The `defaultShippingAddressId` of the customer will be set to the ID of that address.
  """
  defaultShippingAddress: Int
  key: String!
  name: String!
  parentUnit: ResourceIdentifierInput

  """
  The indices of the shipping addresses in the `addresses` list. The `shippingAddressIds` of the `Customer` will be set to the IDs of that addresses.
  """
  shippingAddresses: [Int!] = []
  storeMode: String
  stores: [ResourceIdentifierInput!]
  unitType: BusinessUnitType!
}

type BusinessUnitNameChanged implements MessagePayload {
  name: String!
  type: String!
}

type BusinessUnitParentChanged implements MessagePayload {
  newParentUnit: BusinessUnit
  newParentUnitRef: KeyReference
  oldParentUnit: BusinessUnit
  oldParentUnitRef: KeyReference
  type: String!
}

type BusinessUnitQueryResult {
  count: Int!
  exists: Boolean!
  offset: Int!
  results: [BusinessUnit!]!
  total: Long!
}

"""
CLOSED BETA: This feature is subject to change and should not be used in production. https://docs.commercetools.com/api/contract#closed-beta
"""
type BusinessUnitSearchConfiguration {
  lastModifiedAt: DateTime!
  lastModifiedBy: Initiator
  status: BusinessUnitSearchStatus!
}

"""
CLOSED BETA: This feature is subject to change and should not be used in production. https://docs.commercetools.com/api/contract#closed-beta
"""
enum BusinessUnitSearchStatus {
  Activated
  Deactivated
}

type BusinessUnitShippingAddressAdded implements MessagePayload {
  address: Address!
  type: String!
}

type BusinessUnitShippingAddressRemoved implements MessagePayload {
  address: Address!
  type: String!
}

enum BusinessUnitStatus {
  Active
  Inactive
}

type BusinessUnitStatusChanged implements MessagePayload {
  status: BusinessUnitStatus!
  type: String!
}

type BusinessUnitStoreAdded implements MessagePayload {
  store: Store!
  storeRef: KeyReference!
  type: String!
}

type BusinessUnitStoreModeChanged implements MessagePayload {
  oldStoreMode: String!
  oldStores: [Store!]
  oldStoresRef: [KeyReference!]
  storeMode: String!
  stores: [Store!]
  storesRef: [KeyReference!]
  type: String!
}

type BusinessUnitStoreRemoved implements MessagePayload {
  store: Store!
  storeRef: KeyReference!
  type: String!
}

type BusinessUnitStoresSet implements MessagePayload {
  stores: [Store!]!
  storesRef: [KeyReference!]!
  type: String!
}

enum BusinessUnitType {
  Company
  Division
}

input BusinessUnitUpdateAction {
  addAddress: AddBusinessUnitAddress
  addAssociate: AddBusinessUnitAssociate
  addBillingAddressId: AddBusinessUnitBillingAddressId
  addShippingAddressId: AddBusinessUnitShippingAddressId
  addStore: AddBusinessUnitStore
  changeAddress: ChangeBusinessUnitAddress
  changeAssociate: ChangeBusinessUnitAssociate
  changeAssociateMode: ChangeBusinessUnitAssociateMode
  changeName: ChangeBusinessUnitName
  changeParentUnit: ChangeBusinessUnitParentUnit
  changeStatus: ChangeBusinessUnitStatus
  removeAddress: RemoveBusinessUnitAddress
  removeAssociate: RemoveBusinessUnitAssociate
  removeBillingAddressId: RemoveBusinessUnitBillingAddressId
  removeShippingAddressId: RemoveBusinessUnitShippingAddressId
  removeStore: RemoveBusinessUnitStore
  setAddressCustomField: SetBusinessUnitAddressCustomField
  setAddressCustomType: SetBusinessUnitAddressCustomType
  setAssociates: SetBusinessUnitAssociates
  setContactEmail: SetBusinessUnitContactEmail
  setCustomField: SetBusinessUnitCustomField
  setCustomType: SetBusinessUnitCustomType
  setDefaultBillingAddress: SetBusinessUnitDefaultBillingAddress
  setDefaultShippingAddress: SetBusinessUnitDefaultShippingAddress
  setStoreMode: SetBusinessUnitStoreMode
  setStores: SetBusinessUnitStores
}

input CancelQuoteRequest {
  dummy: String
}

"""
A shopping cart holds product variants and can be ordered. Each cart either belongs to a registered customer or is an anonymous cart.
"""
type Cart implements ReferenceExpandable & Versioned {
  anonymousId: String
  billingAddress: Address
  businessUnit: BusinessUnit
  businessUnitRef: KeyReference
  cartState: CartState!
  country: Country
  createdAt: DateTime!
  createdBy: Initiator
  custom: CustomFieldsType
  customLineItems: [CustomLineItem!]!
  customer: Customer
  customerEmail: String
  customerGroup: CustomerGroup
  customerGroupRef: Reference
  customerId: String
  deleteDaysAfterLastModification: Int
  directDiscounts: [DirectDiscount!]!
  discountCodes: [DiscountCodeInfo!]!
  discountOnTotalPrice: DiscountOnTotalPrice
  id: String!
  inventoryMode: InventoryMode!
  itemShippingAddresses: [Address!]!
  key: String
  lastModifiedAt: DateTime!
  lastModifiedBy: Initiator
  lineItems(
    """Queries with specified ID"""
    id: String
  ): [LineItem!]!
  locale: Locale
  origin: CartOrigin!
  paymentInfo: PaymentInfo
  refusedGifts: [CartDiscount!]!
  refusedGiftsRefs: [Reference!]!
  shipping: [Shipping!]!
  shippingAddress: Address
  shippingCustomFields: CustomFieldsType
  shippingInfo: ShippingInfo
  shippingKey: String
  shippingMode: ShippingMode!
  shippingRateInput: ShippingRateInput
  store: Store
  storeRef: KeyReference
  taxCalculationMode: TaxCalculationMode!
  taxMode: TaxMode!
  taxRoundingMode: RoundingMode!
  taxedPrice: TaxedPrice
  taxedShippingPrice: TaxedPrice
  totalLineItemQuantity: Long
  totalPrice: Money!
  version: Long!
}

input CartClassificationInput {
  values: [LocalizedEnumValueInput!]!
}

type CartClassificationType implements ShippingRateInputType {
  type: String!
  values: [ShippingRateInputLocalizedEnumValue!]!
}

type CartCreated implements MessagePayload {
  discountCodesRefs: [Reference!]!
  lineItemCount: Int!
  totalPrice: Money!
  type: String!
}

"\nCart discounts are recalculated every time LineItems or CustomLineItems are added or removed from the Cart or an order is created from the cart.\n\nThe number of active cart discounts that do not require a discount code (isActive=true and requiresDiscountCode=false) is limited to 100.\n      "
type CartDiscount implements ReferenceExpandable & Versioned {
  cartPredicate: String!
  createdAt: DateTime!
  createdBy: Initiator
  custom: CustomFieldsType
  description(
    """
    List of languages the client is able to understand, and which locale variant is preferred.
    """
    acceptLanguage: [Locale!]

    """
    String is defined for different locales. This argument specifies the desired locale.
    """
    locale: Locale
  ): String
  descriptionAllLocales: [LocalizedString!]
  id: String!
  isActive: Boolean!
  key: String
  lastModifiedAt: DateTime!
  lastModifiedBy: Initiator
  name(
    """
    List of languages the client is able to understand, and which locale variant is preferred.
    """
    acceptLanguage: [Locale!]

    """
    String is defined for different locales. This argument specifies the desired locale.
    """
    locale: Locale
  ): String
  nameAllLocales: [LocalizedString!]!
  referenceRefs: [Reference!]!
  requiresDiscountCode: Boolean!
  sortOrder: String!
  stackingMode: StackingMode!
  stores: [Store!]!
  storesRef: [KeyReference!]!
  target: CartDiscountTarget
  validFrom: DateTime
  validUntil: DateTime
  value: CartDiscountValue!
  version: Long!
}

type CartDiscountCreated implements MessagePayload {
  cartDiscount: CartDiscount!
  type: String!
}

type CartDiscountDeleted implements MessagePayload {
  type: String!
}

input CartDiscountDraft {
  cartPredicate: String!
  custom: CustomFieldsDraft
  description: [LocalizedStringItemInputType!]
  isActive: Boolean = true
  key: String
  name: [LocalizedStringItemInputType!]!
  requiresDiscountCode: Boolean = false
  sortOrder: String!
  stackingMode: StackingMode = Stacking
  stores: [ResourceIdentifierInput!]
  target: CartDiscountTargetInput
  validFrom: DateTime
  validUntil: DateTime
  value: CartDiscountValueInput!
}

type CartDiscountLimitWithCurrent implements LimitWithCurrent {
  current: Long!
  limit: Long
}

type CartDiscountLimitsProjection {
  totalActiveWithoutDiscountCodes: CartDiscountLimitWithCurrent!
}

"""
Fields to access cartDiscounts. Includes direct access to a single cartDiscount and searching for cartDiscounts.
"""
interface CartDiscountQueryInterface {
  cartDiscount(
    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
  ): CartDiscount
  cartDiscounts(limit: Int, offset: Int, sort: [String!], where: String): CartDiscountQueryResult!
}

type CartDiscountQueryResult {
  count: Int!
  exists: Boolean!
  offset: Int!
  results: [CartDiscount!]!
  total: Long!
}

type CartDiscountStoreAdded implements MessagePayload {
  store: Store!
  storeRef: KeyReference!
  type: String!
}

type CartDiscountStoreRemoved implements MessagePayload {
  store: Store!
  storeRef: KeyReference!
  type: String!
}

type CartDiscountStoresSet implements MessagePayload {
  stores: [Store!]!
  storesRef: [KeyReference!]!
  type: String!
}

interface CartDiscountTarget {
  type: String!
}

input CartDiscountTargetInput {
  customLineItems: CustomLineItemsTargetInput
  lineItems: LineItemsTargetInput
  multiBuyCustomLineItems: MultiBuyCustomLineItemsTargetInput
  multiBuyLineItems: MultiBuyLineItemsTargetInput
  shipping: ShippingTargetInput
  totalPrice: CartDiscountTotalPriceTargetInput
}

type CartDiscountTotalPriceTarget implements CartDiscountTarget {
  type: String!
}

input CartDiscountTotalPriceTargetInput {
  dummy: String
}

input CartDiscountUpdateAction {
  addStore: AddCartDiscountStore
  changeCartPredicate: ChangeCartDiscountCartPredicate
  changeIsActive: ChangeCartDiscountIsActive
  changeName: ChangeCartDiscountName
  changeRequiresDiscountCode: ChangeCartDiscountRequiresDiscountCode
  changeSortOrder: ChangeCartDiscountSortOrder
  changeStackingMode: ChangeCartDiscountStackingMode
  changeTarget: ChangeCartDiscountTarget
  changeValue: ChangeCartDiscountValue
  removeStore: RemoveCartDiscountStore
  setCustomField: SetCartDiscountCustomField
  setCustomType: SetCartDiscountCustomType
  setDescription: SetCartDiscountDescription
  setKey: SetCartDiscountKey
  setStores: SetCartDiscountStores
  setValidFrom: SetCartDiscountValidFrom
  setValidFromAndUntil: SetCartDiscountValidFromAndUntil
  setValidUntil: SetCartDiscountValidUntil
}

interface CartDiscountValue {
  type: String!
}

input CartDiscountValueBaseMoneyInput {
  """
  CurrencyCode and centAmount are deprecated. Please use `Money`(centPrecision) or `HighPrecisionMoney`(highPrecision).
  """
  centAmount: Long
  centPrecision: MoneyInput

  """
  CurrencyCode and centAmount are deprecated. Please use `Money`(centPrecision) or `HighPrecisionMoney`(highPrecision).
  """
  currencyCode: Currency
  highPrecision: HighPrecisionMoneyInput
}

input CartDiscountValueInput {
  absolute: AbsoluteDiscountValueInput
  fixed: FixedPriceDiscountValueInput
  giftLineItem: GiftLineItemValueInput
  relative: RelativeDiscountValueInput
}

input CartDraft {
  anonymousId: String
  billingAddress: AddressInput
  businessUnit: ResourceIdentifierInput
  country: Country
  currency: Currency!
  custom: CustomFieldsDraft
  customLineItems: [CustomLineItemDraft!] = []
  customShipping: [CustomShippingDraft!] = []
  customerEmail: String
  customerGroup: ResourceIdentifierInput
  customerId: String
  deleteDaysAfterLastModification: Int
  discountCodes: [String!] = []
  externalTaxRateForShippingMethod: ExternalTaxRateDraft
  inventoryMode: InventoryMode = None
  itemShippingAddresses: [AddressInput!] = []
  key: String
  lineItems: [LineItemDraft!] = []
  locale: Locale
  origin: CartOrigin = Customer
  shipping: [ShippingDraft!] = []
  shippingAddress: AddressInput
  shippingMethod: ResourceIdentifierInput
  shippingMode: ShippingMode = Single
  shippingRateInput: ShippingRateInputDraft
  store: ResourceIdentifierInput
  taxCalculationMode: TaxCalculationMode = LineItemLevel
  taxMode: TaxMode = Platform
  taxRoundingMode: RoundingMode = HalfEven
}

type CartLimitWithCurrent implements LimitWithCurrent {
  current: Long!
  limit: Long
}

type CartLimitsProjection {
  total: CartLimitWithCurrent!
}

enum CartOrigin {
  """The cart was created by the customer. This is the default value"""
  Customer

  """The cart was created by the merchant on behalf of the customer"""
  Merchant

  """The cart was created by our platform and belongs to a Quote."""
  Quote
}

"""
Fields to access carts. Includes direct access to a single cart and searching for carts.
"""
interface CartQueryInterface {
  cart(id: String!): Cart
  carts(limit: Int, offset: Int, sort: [String!], where: String): CartQueryResult!
}

type CartQueryResult {
  count: Int!
  exists: Boolean!
  offset: Int!
  results: [Cart!]!
  total: Long!
}

input CartScoreInput {
  dummy: String
}

type CartScoreType implements ShippingRateInputType {
  type: String!
}

enum CartState {
  """The cart can be updated and ordered. It is the default state."""
  Active

  """
  The cart is frozen. The cart is ready for checkout and a few update actions are not allowed.
  """
  Frozen

  """
  Anonymous cart whose content was merged into a customers cart on signin. No further operations on the cart are allowed.
  """
  Merged

  """The cart was ordered. No further operations on the cart are allowed."""
  Ordered
}

input CartUpdateAction {
  addCustomLineItem: AddCartCustomLineItem
  addCustomShippingMethod: AddCartCustomShippingMethod
  addDiscountCode: AddCartDiscountCode
  addItemShippingAddress: AddCartItemShippingAddress
  addLineItem: AddCartLineItem
  addPayment: AddCartPayment
  addShippingMethod: AddCartShippingMethod
  addShoppingList: AddCartShoppingList
  applyDeltaToCustomLineItemShippingDetailsTargets: ApplyCartDeltaToCustomLineItemShippingDetailsTargets
  applyDeltaToLineItemShippingDetailsTargets: ApplyCartDeltaToLineItemShippingDetailsTargets
  changeCustomLineItemMoney: ChangeCartCustomLineItemMoney
  changeCustomLineItemPriceMode: ChangeCartCustomLineItemPriceMode
  changeCustomLineItemQuantity: ChangeCartCustomLineItemQuantity
  changeLineItemQuantity: ChangeCartLineItemQuantity
  changeTaxCalculationMode: ChangeCartTaxCalculationMode
  changeTaxMode: ChangeCartTaxMode
  changeTaxRoundingMode: ChangeCartTaxRoundingMode
  freezeCart: FreezeCart
  recalculate: RecalculateCart
  removeCustomLineItem: RemoveCartCustomLineItem
  removeDiscountCode: RemoveCartDiscountCode
  removeItemShippingAddress: RemoveCartItemShippingAddress
  removeLineItem: RemoveCartLineItem
  removePayment: RemoveCartPayment
  removeShippingMethod: RemoveCartShippingMethod
  setAnonymousId: SetCartAnonymousId
  setBillingAddress: SetCartBillingAddress
  setBillingAddressCustomField: SetCartBillingAddressCustomField
  setBillingAddressCustomType: SetCartBillingAddressCustomType
  setBusinessUnit: SetCartBusinessUnit
  setCartTotalTax: SetCartTotalTax
  setCountry: SetCartCountry
  setCustomField: SetCartCustomField
  setCustomLineItemCustomField: SetCartCustomLineItemCustomField
  setCustomLineItemCustomType: SetCartCustomLineItemCustomType
  setCustomLineItemShippingDetails: SetCartCustomLineItemShippingDetails
  setCustomLineItemTaxAmount: SetCartCustomLineItemTaxAmount
  setCustomLineItemTaxRate: SetCartCustomLineItemTaxRate
  setCustomShippingMethod: SetCartCustomShippingMethod
  setCustomType: SetCartCustomType
  setCustomerEmail: SetCartCustomerEmail
  setCustomerGroup: SetCartCustomerGroup
  setCustomerId: SetCartCustomerId
  setDeleteDaysAfterLastModification: SetCartDeleteDaysAfterLastModification
  setDirectDiscounts: SetCartDirectDiscounts
  setItemShippingAddressCustomField: SetCartItemShippingAddressCustomField
  setItemShippingAddressCustomType: SetCartItemShippingAddressCustomType
  setKey: SetCartKey
  setLineItemCustomField: SetCartLineItemCustomField
  setLineItemCustomType: SetCartLineItemCustomType
  setLineItemDistributionChannel: SetCartLineItemDistributionChannel
  setLineItemInventoryMode: SetCartLineItemInventoryMode
  setLineItemPrice: SetCartLineItemPrice
  setLineItemShippingDetails: SetCartLineItemShippingDetails
  setLineItemSupplyChannel: SetCartLineItemSupplyChannel
  setLineItemTaxAmount: SetCartLineItemTaxAmount
  setLineItemTaxRate: SetCartLineItemTaxRate
  setLineItemTotalPrice: SetCartLineItemTotalPrice
  setLocale: SetCartLocale
  setShippingAddress: SetCartShippingAddress
  setShippingAddressCustomField: SetCartShippingAddressCustomField
  setShippingAddressCustomType: SetCartShippingAddressCustomType
  setShippingCustomField: SetCartShippingCustomField
  setShippingCustomType: SetCartShippingCustomType
  setShippingMethod: SetCartShippingMethod
  setShippingMethodTaxAmount: SetCartShippingMethodTaxAmount
  setShippingMethodTaxRate: SetCartShippingMethodTaxRate
  setShippingRateInput: SetCartShippingRateInput
  unfreezeCart: UnfreezeCart
  updateItemShippingAddress: UpdateCartItemShippingAddress
}

input CartValueInput {
  dummy: String
}

type CartValueType implements ShippingRateInputType {
  type: String!
}

type CartsConfiguration {
  allowAddingUnpublishedProducts: Boolean!
  countryTaxRateFallbackEnabled: Boolean!
  deleteDaysAfterLastModification: Int
}

input CartsConfigurationInput {
  deleteDaysAfterLastModification: Int
}

type Category implements ReferenceExpandable & Versioned {
  ancestors: [Category!]!
  ancestorsRef: [Reference!]!
  assets: [Asset!]!

  """Number of direct child categories."""
  childCount: Int!

  """Direct child categories."""
  children: [Category!]
  createdAt: DateTime!
  createdBy: Initiator
  custom: CustomFieldsType
  description(
    """
    List of languages the client is able to understand, and which locale variant is preferred.
    """
    acceptLanguage: [Locale!]

    """
    String is defined for different locales. This argument specifies the desired locale.
    """
    locale: Locale
  ): String
  descriptionAllLocales: [LocalizedString!]
  externalId: String
  id: String!
  key: String
  lastModifiedAt: DateTime!
  lastModifiedBy: Initiator
  metaDescription(
    """
    List of languages the client is able to understand, and which locale variant is preferred.
    """
    acceptLanguage: [Locale!]

    """
    String is defined for different locales. This argument specifies the desired locale.
    """
    locale: Locale
  ): String
  metaDescriptionAllLocales: [LocalizedString!]
  metaKeywords(
    """
    List of languages the client is able to understand, and which locale variant is preferred.
    """
    acceptLanguage: [Locale!]

    """
    String is defined for different locales. This argument specifies the desired locale.
    """
    locale: Locale
  ): String
  metaKeywordsAllLocales: [LocalizedString!]
  metaTitle(
    """
    List of languages the client is able to understand, and which locale variant is preferred.
    """
    acceptLanguage: [Locale!]

    """
    String is defined for different locales. This argument specifies the desired locale.
    """
    locale: Locale
  ): String
  metaTitleAllLocales: [LocalizedString!]
  name(
    """
    List of languages the client is able to understand, and which locale variant is preferred.
    """
    acceptLanguage: [Locale!]

    """
    String is defined for different locales. This argument specifies the desired locale.
    """
    locale: Locale
  ): String
  nameAllLocales: [LocalizedString!]!
  orderHint: String!
  parent: Category
  parentRef: Reference
  slug(
    """
    List of languages the client is able to understand, and which locale variant is preferred.
    """
    acceptLanguage: [Locale!]

    """
    String is defined for different locales. This argument specifies the desired locale.
    """
    locale: Locale
  ): String
  slugAllLocales: [LocalizedString!]!

  """Number of staged products in the category subtree."""
  stagedProductCount: Int!
  version: Long!
}

type CategoryCreated implements MessagePayload {
  category: Category!
  type: String!
}

input CategoryDraft {
  assets: [AssetDraftInput!] = []
  custom: CustomFieldsDraft
  description: [LocalizedStringItemInputType!]
  externalId: String
  key: String
  metaDescription: [LocalizedStringItemInputType!]
  metaKeywords: [LocalizedStringItemInputType!]
  metaTitle: [LocalizedStringItemInputType!]
  name: [LocalizedStringItemInputType!]!
  orderHint: String
  parent: ResourceIdentifierInput
  slug: [LocalizedStringItemInputType!]!
}

type CategoryLimitsProjection {
  maxCategories: Limit!
}

type CategoryOrderHint {
  categoryId: String!
  orderHint: String!
}

input CategoryOrderHintInput {
  orderHint: String!
  uuid: String!
}

type CategoryOrderHintProductSearch {
  categoryId: String!
  orderHint: String!
}

type CategoryQueryResult {
  count: Int!
  exists: Boolean!
  offset: Int!
  results: [Category!]!
  total: Long!
}

type CategorySlugChanged implements MessagePayload {
  oldSlug(
    """
    List of languages the client is able to understand, and which locale variant is preferred.
    """
    acceptLanguage: [Locale!]

    """
    String is defined for different locales. This argument specifies the desired locale.
    """
    locale: Locale
  ): String
  oldSlugAllLocales: [LocalizedString!]
  slug(
    """
    List of languages the client is able to understand, and which locale variant is preferred.
    """
    acceptLanguage: [Locale!]

    """
    String is defined for different locales. This argument specifies the desired locale.
    """
    locale: Locale
  ): String
  slugAllLocales: [LocalizedString!]!
  type: String!
}

input CategoryUpdateAction {
  addAsset: AddCategoryAsset
  changeAssetName: ChangeCategoryAssetName
  changeAssetOrder: ChangeCategoryAssetOrder
  changeName: ChangeCategoryName
  changeOrderHint: ChangeCategoryOrderHint
  changeParent: ChangeCategoryParent
  changeSlug: ChangeCategorySlug
  removeAsset: RemoveCategoryAsset
  setAssetCustomField: SetCategoryAssetCustomField
  setAssetCustomType: SetCategoryAssetCustomType
  setAssetDescription: SetCategoryAssetDescription
  setAssetKey: SetCategoryAssetKey
  setAssetSources: SetCategoryAssetSources
  setAssetTags: SetCategoryAssetTags
  setCustomField: SetCategoryCustomField
  setCustomType: SetCategoryCustomType
  setDescription: SetCategoryDescription
  setExternalId: SetCategoryExternalId
  setKey: SetCategoryKey
  setMetaDescription: SetCategoryMetaDescription
  setMetaKeywords: SetCategoryMetaKeywords
  setMetaTitle: SetCategoryMetaTitle
}

input ChangeAssociateRoleBuyerAssignable {
  buyerAssignable: Boolean!
}

input ChangeAttributeGroupName {
  name: [LocalizedStringItemInputType!]!
}

input ChangeBusinessUnitAddress {
  address: AddressInput!
  addressId: String
  addressKey: String
}

input ChangeBusinessUnitAssociate {
  associate: AssociateDraft!
}

input ChangeBusinessUnitAssociateMode {
  associateMode: BusinessUnitAssociateMode!
}

input ChangeBusinessUnitName {
  name: String!
}

input ChangeBusinessUnitParentUnit {
  parentUnit: ResourceIdentifierInput!
}

input ChangeBusinessUnitStatus {
  status: BusinessUnitStatus!
}

input ChangeCartCustomLineItemMoney {
  customLineItemId: String
  customLineItemKey: String
  money: BaseMoneyInput!
}

input ChangeCartCustomLineItemPriceMode {
  customLineItemId: String
  customLineItemKey: String
  mode: CustomLineItemPriceMode!
}

input ChangeCartCustomLineItemQuantity {
  customLineItemId: String
  customLineItemKey: String
  quantity: Long!
}

input ChangeCartDiscountCartPredicate {
  cartPredicate: String!
}

input ChangeCartDiscountIsActive {
  isActive: Boolean!
}

input ChangeCartDiscountName {
  name: [LocalizedStringItemInputType!]!
}

input ChangeCartDiscountRequiresDiscountCode {
  requiresDiscountCode: Boolean!
}

input ChangeCartDiscountSortOrder {
  sortOrder: String!
}

input ChangeCartDiscountStackingMode {
  stackingMode: StackingMode!
}

input ChangeCartDiscountTarget {
  target: CartDiscountTargetInput!
}

input ChangeCartDiscountValue {
  value: CartDiscountValueInput!
}

input ChangeCartLineItemQuantity {
  """Only valid for the general Carts API. Ignored for the My Carts API."""
  externalPrice: BaseMoneyInput

  """Only valid for the general Carts API. Ignored for the My Carts API."""
  externalTotalPrice: ExternalLineItemTotalPriceDraft
  lineItemId: String
  lineItemKey: String
  quantity: Long!
}

input ChangeCartTaxCalculationMode {
  taxCalculationMode: TaxCalculationMode!
}

input ChangeCartTaxMode {
  taxMode: TaxMode!
}

input ChangeCartTaxRoundingMode {
  taxRoundingMode: RoundingMode!
}

input ChangeCategoryAssetName {
  assetId: String
  assetKey: String
  name: [LocalizedStringItemInputType!]!
}

input ChangeCategoryAssetOrder {
  assetOrder: [String!]!
}

input ChangeCategoryName {
  name: [LocalizedStringItemInputType!]!
}

input ChangeCategoryOrderHint {
  orderHint: String!
}

input ChangeCategoryParent {
  parent: ResourceIdentifierInput!
}

input ChangeCategorySlug {
  slug: [LocalizedStringItemInputType!]!
}

input ChangeChannelDescription {
  description: [LocalizedStringItemInputType!]
}

input ChangeChannelKey {
  key: String!
}

input ChangeChannelName {
  name: [LocalizedStringItemInputType!]
}

input ChangeCustomerAddress {
  address: AddressInput!
  addressId: String
  addressKey: String
}

input ChangeCustomerEmail {
  email: String!
}

input ChangeCustomerGroupName {
  name: String!
}

input ChangeDiscountCodeCartDiscounts {
  cartDiscounts: [ResourceIdentifierInput!]!
}

input ChangeDiscountCodeGroups {
  groups: [String!]!
}

input ChangeDiscountCodeIsActive {
  isActive: Boolean!
}

input ChangeExtensionDestination {
  destination: ExtensionDestinationInput!
}

input ChangeExtensionTriggers {
  triggers: [TriggerInput!]!
}

input ChangeInventoryEntryQuantity {
  quantity: Long!
}

input ChangeMyBusinessUnitAddress {
  address: AddressInput!
  addressId: String
  addressKey: String
}

input ChangeMyBusinessUnitAssociate {
  associate: AssociateDraft!
}

input ChangeMyBusinessUnitName {
  name: String!
}

input ChangeMyBusinessUnitParentUnit {
  parentUnit: ResourceIdentifierInput!
}

input ChangeMyCartTaxMode {
  taxMode: TaxMode!
}

input ChangeMyQuoteMyQuoteState {
  quoteState: MyQuoteState!
}

input ChangeOrderPaymentState {
  paymentState: PaymentState!
}

input ChangeOrderShipmentState {
  shipmentState: ShipmentState!
}

input ChangeOrderState {
  orderState: OrderState!
}

input ChangePaymentAmountPlanned {
  amount: MoneyInput!
}

input ChangePaymentTransactionInteractionId {
  interactionId: String!
  transactionId: String!
}

input ChangePaymentTransactionState {
  state: TransactionState!
  transactionId: String!
}

input ChangePaymentTransactionTimestamp {
  timestamp: DateTime!
  transactionId: String!
}

input ChangeProductAssetName {
  assetId: String
  assetKey: String
  name: [LocalizedStringItemInputType!]!
  sku: String
  staged: Boolean = true
  variantId: Int
}

input ChangeProductAssetOrder {
  assetOrder: [String!]!
  sku: String
  staged: Boolean = true
  variantId: Int
}

input ChangeProductDiscountIsActive {
  isActive: Boolean!
}

input ChangeProductDiscountName {
  name: [LocalizedStringItemInputType!]!
}

input ChangeProductDiscountPredicate {
  predicate: String!
}

input ChangeProductDiscountSortOrder {
  sortOrder: String!
}

input ChangeProductDiscountValue {
  value: ProductDiscountValueInput!
}

input ChangeProductImageLabel {
  imageUrl: String!
  label: String
  sku: String
  staged: Boolean = true
  variantId: Int
}

input ChangeProductMasterVariant {
  sku: String
  staged: Boolean = true
  variantId: Int
}

input ChangeProductName {
  name: [LocalizedStringItemInputType!]!
  staged: Boolean = true
}

input ChangeProductPrice {
  price: ProductPriceDataInput!
  priceId: String
  sku: String
  staged: Boolean = true
  variantId: Int
}

input ChangeProductSelectionName {
  name: [LocalizedStringItemInputType!]!
}

input ChangeProductSlug {
  slug: [LocalizedStringItemInputType!]!
  staged: Boolean = true
}

"""
CLOSED BETA: This feature is subject to change and should not be used in production. https://docs.commercetools.com/api/contract#closed-beta
"""
input ChangeProjectSettingsBusinessUnitSearchStatus {
  status: BusinessUnitSearchStatus!
}

input ChangeProjectSettingsCartsConfiguration {
  cartsConfiguration: CartsConfigurationInput!
}

input ChangeProjectSettingsCountries {
  countries: [Country!]!
}

input ChangeProjectSettingsCountryTaxRateFallbackEnabled {
  countryTaxRateFallbackEnabled: Boolean!
}

input ChangeProjectSettingsCurrencies {
  currencies: [Currency!]!
}

"""
CLOSED BETA: This feature is subject to change and should not be used in production. https://docs.commercetools.com/api/contract#closed-beta
"""
input ChangeProjectSettingsCustomerSearchStatus {
  status: CustomerSearchStatus!
}

input ChangeProjectSettingsLanguages {
  languages: [Locale!]!
}

input ChangeProjectSettingsMessagesConfiguration {
  messagesConfiguration: MessagesConfigurationDraft!
}

input ChangeProjectSettingsMessagesEnabled {
  messagesEnabled: Boolean!
}

input ChangeProjectSettingsMyBusinessUnitStatusOnCreation {
  status: BusinessUnitConfigurationStatus!
}

input ChangeProjectSettingsName {
  name: String!
}

input ChangeProjectSettingsOrderSearchStatus {
  status: OrderSearchStatus!
}

input ChangeProjectSettingsProductSearchIndexingEnabled {
  enabled: Boolean!

  """
  CLOSED BETA: This feature is subject to change and should not be used in production. https://docs.commercetools.com/api/contract#closed-beta
  """
  mode: ProductSearchIndexingMode
}

input ChangeProjectSettingsShoppingListsConfiguration {
  shoppingListsConfiguration: ShoppingListsConfigurationInput!
}

input ChangeQuoteCustomer {
  customer: ResourceIdentifierInput!
}

input ChangeQuoteRequestCustomer {
  customer: ResourceIdentifierInput!
}

input ChangeQuoteRequestState {
  quoteRequestState: QuoteRequestState!
}

input ChangeQuoteState {
  quoteState: QuoteState!
}

input ChangeShippingMethodIsDefault {
  isDefault: Boolean!
}

input ChangeShippingMethodName {
  name: String!
}

input ChangeShippingMethodTaxCategory {
  taxCategory: ResourceIdentifierInput!
}

input ChangeShoppingListLineItemQuantity {
  lineItemId: String
  lineItemKey: String
  quantity: Int!
}

input ChangeShoppingListLineItemsOrder {
  lineItemOrder: [String!]!
}

input ChangeShoppingListName {
  name: [LocalizedStringItemInputType!]!
}

input ChangeShoppingListTextLineItemName {
  name: [LocalizedStringItemInputType!]!
  textLineItemId: String
  textLineItemKey: String
}

input ChangeShoppingListTextLineItemQuantity {
  quantity: Int!
  textLineItemId: String
  textLineItemKey: String
}

input ChangeShoppingListTextLineItemsOrder {
  textLineItemOrder: [String!]!
}

input ChangeStagedOrderCustomLineItemMoney {
  customLineItemId: String
  customLineItemKey: String
  money: BaseMoneyInput!
}

type ChangeStagedOrderCustomLineItemMoneyOutput implements StagedOrderUpdateActionOutput {
  customLineItemId: String
  customLineItemKey: String
  money: BaseMoney!
  type: String!
}

input ChangeStagedOrderCustomLineItemQuantity {
  customLineItemId: String
  customLineItemKey: String
  quantity: Long!
}

type ChangeStagedOrderCustomLineItemQuantityOutput implements StagedOrderUpdateActionOutput {
  customLineItemId: String
  customLineItemKey: String
  quantity: Long!
  type: String!
}

input ChangeStagedOrderLineItemQuantity {
  externalPrice: BaseMoneyInput
  externalTotalPrice: ExternalLineItemTotalPriceDraft
  lineItemId: String
  lineItemKey: String
  quantity: Long!
}

type ChangeStagedOrderLineItemQuantityOutput implements StagedOrderUpdateActionOutput {
  externalPrice: BaseMoney
  externalTotalPrice: ExternalLineItemTotalPrice
  lineItemId: String
  lineItemKey: String
  quantity: Long!
  type: String!
}

input ChangeStagedOrderOrderState {
  orderState: OrderState!
}

type ChangeStagedOrderOrderStateOutput implements StagedOrderUpdateActionOutput {
  orderState: OrderState!
  type: String!
}

input ChangeStagedOrderPaymentState {
  paymentState: PaymentState!
}

type ChangeStagedOrderPaymentStateOutput implements StagedOrderUpdateActionOutput {
  paymentState: PaymentState!
  type: String!
}

input ChangeStagedOrderShipmentState {
  shipmentState: ShipmentState!
}

type ChangeStagedOrderShipmentStateOutput implements StagedOrderUpdateActionOutput {
  shipmentState: ShipmentState!
  type: String!
}

input ChangeStagedOrderTaxCalculationMode {
  taxCalculationMode: TaxCalculationMode!
}

type ChangeStagedOrderTaxCalculationModeOutput implements StagedOrderUpdateActionOutput {
  taxCalculationMode: TaxCalculationMode!
  type: String!
}

input ChangeStagedOrderTaxMode {
  taxMode: TaxMode!
}

type ChangeStagedOrderTaxModeOutput implements StagedOrderUpdateActionOutput {
  taxMode: TaxMode!
  type: String!
}

input ChangeStagedOrderTaxRoundingMode {
  taxRoundingMode: RoundingMode!
}

type ChangeStagedOrderTaxRoundingModeOutput implements StagedOrderUpdateActionOutput {
  taxRoundingMode: RoundingMode!
  type: String!
}

input ChangeStagedQuoteState {
  stagedQuoteState: StagedQuoteState!
}

input ChangeStandalonePriceActive {
  active: Boolean!
}

input ChangeStandalonePriceValue {
  """default is `false`"""
  staged: Boolean
  value: BaseMoneyInput!
}

input ChangeStateInitial {
  initial: Boolean!
}

input ChangeStateKey {
  key: String!
}

input ChangeStateType {
  type: StateType!
}

input ChangeStoreProductSelectionActive {
  active: Boolean!
  productSelection: ResourceIdentifierInput!
}

type ChangeSubscription {
  resourceTypeId: String!
}

input ChangeSubscriptionDestination {
  destination: DestinationInput!
}

input ChangeSubscriptionInput {
  resourceTypeId: String!
}

input ChangeTypeEnumValueLabel {
  fieldName: String!
  value: EnumValueInput!
}

input ChangeTypeEnumValueOrder {
  fieldName: String!
  keys: [String!]!
}

input ChangeTypeFieldDefinitionOrder {
  fieldNames: [String!]!
}

input ChangeTypeInputHint {
  fieldName: String!
  inputHint: TextInputHint!
}

input ChangeTypeKey {
  key: String!
}

input ChangeTypeLabel {
  fieldName: String!
  label: [LocalizedStringItemInputType!]!
}

input ChangeTypeLocalizedEnumValueLabel {
  fieldName: String!
  value: LocalizedEnumValueInput!
}

input ChangeTypeLocalizedEnumValueOrder {
  fieldName: String!
  keys: [String!]!
}

input ChangeTypeName {
  name: [LocalizedStringItemInputType!]!
}

input ChangeZoneName {
  name: String!
}

type Channel implements ReferenceExpandable & ReviewTarget & Versioned {
  address: Address
  createdAt: DateTime!
  createdBy: Initiator
  custom: CustomFieldsType
  description(
    """
    List of languages the client is able to understand, and which locale variant is preferred.
    """
    acceptLanguage: [Locale!]

    """
    String is defined for different locales. This argument specifies the desired locale.
    """
    locale: Locale
  ): String
  descriptionAllLocales: [LocalizedString!]
  geoLocation: Geometry
  id: String!
  key: String!
  lastModifiedAt: DateTime!
  lastModifiedBy: Initiator
  name(
    """
    List of languages the client is able to understand, and which locale variant is preferred.
    """
    acceptLanguage: [Locale!]

    """
    String is defined for different locales. This argument specifies the desired locale.
    """
    locale: Locale
  ): String
  nameAllLocales: [LocalizedString!]
  reviewRatingStatistics: ReviewRatingStatistics
  roles: [ChannelRole!]!
  version: Long!
}

input ChannelDraft {
  address: AddressInput
  custom: CustomFieldsDraft
  description: [LocalizedStringItemInputType!]
  geoLocation: GeometryInput
  key: String!
  name: [LocalizedStringItemInputType!]
  roles: [ChannelRole!]!
}

type ChannelQueryResult {
  count: Int!
  exists: Boolean!
  offset: Int!
  results: [Channel!]!
  total: Long!
}

type ChannelReferenceIdentifier {
  id: String
  key: String
  typeId: String!
}

enum ChannelRole {
  """
  Role tells that this channel can be used to track inventory entries.Channels with this role can be treated as warehouses
  """
  InventorySupply

  """
  Role tells that this channel can be used to track order export activities.
  """
  OrderExport

  """
  Role tells that this channel can be used to track order import activities.
  """
  OrderImport

  """
  This role can be combined with some other roles (e.g. with `InventorySupply`) to represent the fact that this particular channel is the primary/master channel among the channels of the same type.
  """
  Primary

  """
  Role tells that this channel can be used to expose products to a specific distribution channel. It can be used by the cart to select a product price.
  """
  ProductDistribution
}

input ChannelUpdateAction {
  addRoles: AddChannelRoles
  changeDescription: ChangeChannelDescription
  changeKey: ChangeChannelKey
  changeName: ChangeChannelName
  removeRoles: RemoveChannelRoles
  setAddress: SetChannelAddress
  setAddressCustomField: SetChannelAddressCustomField
  setAddressCustomType: SetChannelAddressCustomType
  setCustomField: SetChannelCustomField
  setCustomType: SetChannelCustomType
  setGeoLocation: SetChannelGeoLocation
  setRoles: SetChannelRoles
}

type ClassificationShippingRateInput implements ShippingRateInput {
  key: String!
  label(
    """
    List of languages the client is able to understand, and which locale variant is preferred.
    """
    acceptLanguage: [Locale!]

    """
    String is defined for different locales. This argument specifies the desired locale.
    """
    locale: Locale
  ): String
  labelAllLocales: [LocalizedString!]!
  type: String!
}

input ClassificationShippingRateInputDraft {
  key: String!
}

type ClassificationShippingRateInputDraftOutput implements ShippingRateInputDraftOutput {
  key: String!
  type: String!
}

type CloudEventsSubscriptionsFormat implements NotificationFormat {
  cloudEventsVersion: String!
  type: String!
}

input CloudEventsSubscriptionsFormatInput {
  cloudEventsVersion: String!
}

type CommercetoolsSubscription implements Versioned {
  changes: [ChangeSubscription!]!
  createdAt: DateTime!
  createdBy: Initiator
  destination: Destination!
  format: NotificationFormat!
  id: String!
  key: String
  lastModifiedAt: DateTime!
  lastModifiedBy: Initiator
  messages: [MessageSubscription!]!
  status: SubscriptionHealthStatus!
  version: Long!
}

type CommercetoolsSubscriptionQueryResult {
  count: Int!
  exists: Boolean!
  offset: Int!
  results: [CommercetoolsSubscription!]!
  total: Long!
}

type ConfluentCloudDestination implements Destination {
  acks: String!
  apiKey: String!
  apiSecret: String!
  bootstrapServer: String!
  key: String
  topic: String!
  type: String!
}

input ConfluentCloudDestinationInput {
  acks: String!
  apiKey: String!
  apiSecret: String!
  bootstrapServer: String!
  key: String
  topic: String!
}

"""[ISO 3166-1](http://en.wikipedia.org/wiki/ISO_3166-1) country code."""
scalar Country

input CreateApiClient {
  accessTokenValiditySeconds: Int
  deleteDaysAfterCreation: Int
  name: String!
  refreshTokenValiditySeconds: Int
  scope: String!
}

input CreateProductSelectionDraft {
  custom: CustomFieldsDraft
  key: String
  mode: ProductSelectionMode
  name: [LocalizedStringItemInputType!]!
}

input CreateStandalonePrice {
  active: Boolean! = true
  channel: ResourceIdentifierInput
  country: Country
  custom: CustomFieldsDraft
  customerGroup: ResourceIdentifierInput
  discounted: DiscountedProductPriceValueInput
  key: String
  sku: String!
  staged: StagedPriceDraft
  tiers: [ProductPriceTierInput!] = []
  validFrom: DateTime
  validUntil: DateTime
  value: BaseMoneyInput!
}

input CreateStore {
  countries: [StoreCountryInput!]
  custom: CustomFieldsDraft
  distributionChannels: [ResourceIdentifierInput!]
  key: String!
  languages: [Locale!]
  name: [LocalizedStringItemInputType!]
  productSelections: [ProductSelectionSettingDraft!]
  supplyChannels: [ResourceIdentifierInput!]
}

input CreateZone {
  description: String
  key: String
  locations: [ZoneLocation!] = []
  name: String!
}

"""
Represents a currency. Currencies are identified by their [ISO 4217](http://www.iso.org/iso/home/standards/currency_codes.htm) currency codes.
"""
scalar Currency

interface CustomField {
  name: String!
}

"""
A key-value pair representing the field name and value of one single custom field.

The value of this custom field consists of escaped JSON based on the FieldDefinition of the Type.


Examples for `value`:

* FieldType `String`: `"\"This is a string\""`
* FieldType `DateTimeType`: `"\"2018-10-12T14:00:00.000Z\""`
* FieldType `Number`: `"4"`
* FieldType `Set` with an elementType of `String`: `"[\"This is a string\", \"This is another string\"]"`
* FieldType `Reference`: `"{\"id\": \"b911b62d-353a-4388-93ee-8d488d9af962\", \"typeId\": \"product\"}"`
"""
input CustomFieldInput {
  name: String!

  """
  The value of this custom field consists of escaped JSON based on the FieldDefinition of the Type.
  
  
  Examples for `value`:
  
  * FieldType `String`: `"\"This is a string\""`
  * FieldType `DateTimeType`: `"\"2018-10-12T14:00:00.000Z\""`
  * FieldType `Number`: `"4"`
  * FieldType `Set` with an elementType of `String`: `"[\"This is a string\", \"This is another string\"]"`
  * FieldType `Reference`: `"{\"id\": \"b911b62d-353a-4388-93ee-8d488d9af962\", \"typeId\": \"product\"}"`
  """
  value: String!
}

type CustomFieldsCommand {
  fields: Json!
  typeId: String
  typeKey: String
  typeResId: ResourceIdentifier
}

input CustomFieldsDraft {
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeId: String
  typeKey: String
}

type CustomFieldsType {
  """This field contains non-typed data."""
  customFieldsRaw(
    """
    The names of the custom fields to exclude.
    
    If neither `includeNames` nor `excludeNames` are provided, then all custom fields are returned.
    """
    excludeNames: [String!]

    """
    The names of the custom fields to include.
    
    If neither `includeNames` nor `excludeNames` are provided, then all custom fields are returned.
    """
    includeNames: [String!]
  ): [RawCustomField!]
  type: TypeDefinition
  typeRef: Reference!
}

"""
A custom line item is a generic item that can be added to the cart but is not bound to a product. You can use it for discounts (negative money), vouchers, complex cart rules, additional services or fees. You control the lifecycle of this item.
"""
type CustomLineItem {
  custom: CustomFieldsType
  discountedPricePerQuantity: [DiscountedLineItemPriceForQuantity!]!
  id: String!
  key: String
  money: BaseMoney!
  name(
    """
    List of languages the client is able to understand, and which locale variant is preferred.
    """
    acceptLanguage: [Locale!]

    """
    String is defined for different locales. This argument specifies the desired locale.
    """
    locale: Locale
  ): String
  nameAllLocales: [LocalizedString!]!
  perMethodTaxRate: [MethodTaxRate!]!
  priceMode: CustomLineItemPriceMode!
  quantity: Long!
  shippingDetails: ItemShippingDetails
  slug: String!
  state: [ItemState!]!
  taxCategory: TaxCategory
  taxCategoryRef: Reference
  taxRate: TaxRate
  taxedPrice: TaxedItemPrice
  taxedPricePortions: [MethodTaxedPrice!]!
  totalPrice: Money!
}

input CustomLineItemDraft {
  custom: CustomFieldsDraft
  externalTaxRate: ExternalTaxRateDraft
  key: String
  money: BaseMoneyInput!
  name: [LocalizedStringItemInputType!]!
  priceMode: CustomLineItemPriceMode
  quantity: Long
  shippingDetails: ItemShippingDetailsDraft
  slug: String!
  taxCategory: ReferenceInput
}

type CustomLineItemDraftOutput {
  custom: CustomFieldsCommand
  externalTaxRate: ExternalTaxRateDraftOutput
  key: String
  money: BaseMoney!
  name(
    """
    List of languages the client is able to understand, and which locale variant is preferred.
    """
    acceptLanguage: [Locale!]

    """
    String is defined for different locales. This argument specifies the desired locale.
    """
    locale: Locale
  ): String
  nameAllLocales: [LocalizedString!]!
  priceMode: CustomLineItemPriceMode!
  quantity: Long
  shippingDetails: ItemShippingDetailsDraftOutput
  slug: String!
  taxCategoryResId: ResourceIdentifier
}

input CustomLineItemImportDraft {
  custom: CustomFieldsDraft
  key: String
  money: BaseMoneyInput!
  name: [LocalizedStringItemInputType!]!
  priceMode: CustomLineItemPriceMode
  quantity: Long!
  shippingDetails: ItemShippingDetailsDraft
  slug: String!
  state: [ItemStateDraftType!]
  taxCategory: ResourceIdentifierInput
  taxRate: TaxRateInput
}

enum CustomLineItemPriceMode {
  """
  Cart discounts are deactivated for the custom line items with this price mode.
  """
  External

  """This is the default mode."""
  Standard
}

type CustomLineItemReturnItem implements ReturnItem {
  comment: String
  createdAt: DateTime!
  custom: CustomFieldsType
  customLineItemId: String!
  id: String!
  key: String
  lastModifiedAt: DateTime!
  paymentState: ReturnPaymentState!
  quantity: Long!
  shipmentState: ReturnShipmentState!
  type: String!
}

type CustomLineItemStateTransition implements MessagePayload & OrderMessagePayload {
  customLineItemId: String!
  customLineItemKey: String
  fromState: State
  fromStateRef: Reference!
  quantity: Long!
  toState: State
  toStateRef: Reference!
  transitionDate: DateTime!
  type: String!
}

type CustomLineItemsTarget implements CartDiscountTarget {
  predicate: String!
  type: String!
}

input CustomLineItemsTargetInput {
  predicate: String!
}

type CustomObject implements ReferenceExpandable & Versioned {
  container: String!
  createdAt: DateTime!
  createdBy: Initiator
  id: String!
  key: String!
  lastModifiedAt: DateTime!
  lastModifiedBy: Initiator
  value: Json!
  version: Long!
}

"""
An input object used to create a new, or update an existing Custom Object.

The value should be passed in a form of escaped JSON.

Example for `value` field:

```
"{ \"stringField\": \"myVal\", \"numberField\": 123, \"boolField\": false, \"nestedObject\": { \"nestedObjectKey\": \"anotherValue\" }, \"dateField\": \"2018-10-12T14:00:00.000Z\" }"
```
"""
input CustomObjectDraft {
  container: String!
  key: String!

  """
  The value should be passed in a form of escaped JSON.
  
  Example for `value` field:
  
  ```
  "{ \"stringField\": \"myVal\", \"numberField\": 123, \"boolField\": false, \"nestedObject\": { \"nestedObjectKey\": \"anotherValue\" }, \"dateField\": \"2018-10-12T14:00:00.000Z\" }"
  ```
  """
  value: String!
  version: Long
}

type CustomObjectLimitWithCurrent implements LimitWithCurrent {
  current: Long!
  limit: Long
}

type CustomObjectLimitsProjection {
  total: CustomObjectLimitWithCurrent!
}

type CustomObjectQueryResult {
  count: Int!
  exists: Boolean!
  offset: Int!
  results: [CustomObject!]!
  total: Long!
}

input CustomShippingDraft {
  custom: CustomFieldsDraft
  deliveries: [DeliveryDraft!]
  externalTaxRate: ExternalTaxRateDraft
  key: String!
  shippingAddress: AddressInput!
  shippingMethodName: String!
  shippingRate: ShippingRateDraft!
  shippingRateInput: ShippingRateInputDraft
  taxCategory: ReferenceInput
}

type CustomSuggestTokenizer implements SuggestTokenizer {
  inputs: [String!]!
  type: String!
}

input CustomSuggestTokenizerInput {
  inputs: [String!]!
}

type CustomSuggestTokenizerProductSearch implements SuggestTokenizerProductSearch {
  inputs: [String!]!
  type: String!
}

"""
A customer is a person purchasing products. Carts, Orders and Reviews can be associated to a customer.
"""
type Customer implements ReferenceExpandable & Versioned {
  addresses: [Address!]!
  authenticationMode: AuthenticationMode
  billingAddressIds: [String!]!
  billingAddresses: [Address!]!
  companyName: String
  createdAt: DateTime!
  createdBy: Initiator
  custom: CustomFieldsType
  customerGroup: CustomerGroup

  """
  CLOSED BETA: This feature is subject to change and should not be used in production. https://docs.commercetools.com/api/contract#closed-beta
  """
  customerGroupAssignments: [CustomerGroupAssignment!]
  customerGroupRef: Reference
  customerNumber: String
  dateOfBirth: Date
  defaultBillingAddress: Address
  defaultBillingAddressId: String
  defaultShippingAddress: Address
  defaultShippingAddressId: String
  email: String!
  externalId: String
  firstName: String
  id: String!
  isEmailVerified: Boolean!
  key: String
  lastModifiedAt: DateTime!
  lastModifiedBy: Initiator
  lastName: String
  locale: Locale
  middleName: String
  password: String
  salutation: String
  shippingAddressIds: [String!]!
  shippingAddresses: [Address!]!
  stores: [Store!]!
  storesRef: [KeyReference!]!
  title: String
  vatId: String
  version: Long!
}

"""A field to access a customer's active cart."""
interface CustomerActiveCartInterface {
  customerActiveCart(customerId: String!): Cart
}

type CustomerAddressAdded implements MessagePayload {
  address: Address!
  type: String!
}

type CustomerAddressChanged implements MessagePayload {
  address: Address!
  type: String!
}

type CustomerAddressCustomFieldAdded implements MessagePayload {
  name: String!
  type: String!
  value: Json!
}

type CustomerAddressCustomFieldChanged implements MessagePayload {
  name: String!
  previousValue: Json
  type: String!
  value: Json!
}

type CustomerAddressCustomFieldRemoved implements MessagePayload {
  name: String!
  type: String!
}

type CustomerAddressCustomTypeRemoved implements MessagePayload {
  previousTypeId: String
  type: String!
}

type CustomerAddressCustomTypeSet implements MessagePayload {
  customFields: CustomFieldsType!
  previousTypeId: String
  type: String!
}

type CustomerAddressRemoved implements MessagePayload {
  address: Address!
  type: String!
}

type CustomerCompanyNameSet implements MessagePayload {
  companyName: String
  type: String!
}

type CustomerCreated implements MessagePayload {
  customer: Customer!
  type: String!
}

type CustomerCustomFieldAdded implements MessagePayload {
  name: String!
  type: String!
  value: Json!
}

type CustomerCustomFieldChanged implements MessagePayload {
  name: String!
  previousValue: Json
  type: String!
  value: Json!
}

type CustomerCustomFieldRemoved implements MessagePayload {
  name: String!
  type: String!
}

type CustomerCustomTypeRemoved implements MessagePayload {
  previousTypeId: String
  type: String!
}

type CustomerCustomTypeSet implements MessagePayload {
  customFields: CustomFieldsType!
  previousTypeId: String
  type: String!
}

type CustomerDateOfBirthSet implements MessagePayload {
  dateOfBirth: Date
  type: String!
}

type CustomerDeleted implements MessagePayload {
  type: String!
}

type CustomerEmailChanged implements MessagePayload {
  email: String!
  type: String!
}

type CustomerEmailToken implements Versioned {
  createdAt: DateTime!
  createdBy: Initiator
  customerId: String!
  expiresAt: DateTime!
  id: String!
  lastModifiedAt: DateTime!
  lastModifiedBy: Initiator
  value: String!
  version: Long!
}

type CustomerEmailTokenCreated implements MessagePayload {
  customerId: String!
  expiresAt: DateTime!
  type: String!
}

type CustomerEmailVerified implements MessagePayload {
  type: String!
}

type CustomerFirstNameSet implements MessagePayload {
  firstName: String
  type: String!
}

"""
A customer can be a member in a customer group (e.g. reseller, gold member). A customer group can be used in price calculations with special prices being assigned to certain customer groups.
"""
type CustomerGroup implements ReferenceExpandable & Versioned {
  createdAt: DateTime!
  createdBy: Initiator
  custom: CustomFieldsType
  id: String!
  key: String
  lastModifiedAt: DateTime!
  lastModifiedBy: Initiator
  name: String!
  version: Long!
}

"""
CLOSED BETA: This feature is subject to change and should not be used in production. https://docs.commercetools.com/api/contract#closed-beta
"""
type CustomerGroupAssignment {
  customerGroup: CustomerGroup
  customerGroupRef: Reference
}

"""
CLOSED BETA: This feature is subject to change and should not be used in production. https://docs.commercetools.com/api/contract#closed-beta
"""
input CustomerGroupAssignmentDraft {
  customerGroup: ResourceIdentifierInput!
}

type CustomerGroupCustomFieldAdded implements MessagePayload {
  name: String!
  type: String!
  value: Json!
}

type CustomerGroupCustomFieldChanged implements MessagePayload {
  name: String!
  oldValue: Json
  type: String!
  value: Json!
}

type CustomerGroupCustomFieldRemoved implements MessagePayload {
  name: String!
  type: String!
}

type CustomerGroupCustomTypeRemoved implements MessagePayload {
  oldTypeId: String
  type: String!
}

type CustomerGroupCustomTypeSet implements MessagePayload {
  customFields: CustomFieldsType!
  oldTypeId: String
  type: String!
}

input CustomerGroupDraft {
  custom: CustomFieldsDraft
  groupName: String!
  key: String
}

type CustomerGroupLimitWithCurrent implements LimitWithCurrent {
  current: Long!
  limit: Long
}

type CustomerGroupLimitsProjection {
  total: CustomerGroupLimitWithCurrent!
}

type CustomerGroupQueryResult {
  count: Int!
  exists: Boolean!
  offset: Int!
  results: [CustomerGroup!]!
  total: Long!
}

type CustomerGroupReferenceIdentifier {
  id: String
  key: String
  typeId: String!
}

type CustomerGroupSet implements MessagePayload {
  customerGroup: CustomerGroup
  customerGroupRef: Reference
  type: String!
}

input CustomerGroupUpdateAction {
  changeName: ChangeCustomerGroupName
  setCustomField: SetCustomerGroupCustomField
  setCustomType: SetCustomerGroupCustomType
  setKey: SetCustomerGroupKey
}

type CustomerLastNameSet implements MessagePayload {
  lastName: String
  type: String!
}

type CustomerLimitWithCurrent implements LimitWithCurrent {
  current: Long!
  limit: Long
}

type CustomerLimitsProjection {
  total: CustomerLimitWithCurrent!
}

type CustomerPasswordToken implements Versioned {
  createdAt: DateTime!
  createdBy: Initiator
  customerId: String!
  expiresAt: DateTime!
  id: String!
  lastModifiedAt: DateTime!
  lastModifiedBy: Initiator
  value: String!
  version: Long!
}

type CustomerPasswordTokenCreated implements MessagePayload {
  customerId: String!
  expiresAt: DateTime!
  type: String!
}

type CustomerPasswordUpdated implements MessagePayload {
  reset: Boolean!
  type: String!
}

"""
Fields to access customer accounts. Includes direct access to a single customer and searching for customers.
"""
interface CustomerQueryInterface {
  customer(
    """Queries a customer with specified email token"""
    emailToken: String

    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String

    """Queries a customer with specified password token"""
    passwordToken: String
  ): Customer
  customers(limit: Int, offset: Int, sort: [String!], where: String): CustomerQueryResult!
}

type CustomerQueryResult {
  count: Int!
  exists: Boolean!
  offset: Int!
  results: [Customer!]!
  total: Long!
}

"""
CLOSED BETA: This feature is subject to change and should not be used in production. https://docs.commercetools.com/api/contract#closed-beta
"""
type CustomerSearchConfiguration {
  lastModifiedAt: DateTime!
  lastModifiedBy: Initiator
  status: CustomerSearchStatus!
}

"""
CLOSED BETA: This feature is subject to change and should not be used in production. https://docs.commercetools.com/api/contract#closed-beta
"""
enum CustomerSearchStatus {
  Activated
  Deactivated
}

input CustomerSignInDraft {
  anonymousCart: ResourceIdentifierInput

  """This field will be deprecated in favour of anonymousCart.id."""
  anonymousCartId: String
  anonymousCartSignInMode: AnonymousCartSignInMode = MergeWithExistingCustomerCart
  anonymousId: String
  email: String!
  password: String!
  updateProductData: Boolean = false
}

type CustomerSignInResult {
  cart: Cart
  customer: Customer!
}

input CustomerSignMeInDraft {
  activeCartSignInMode: AnonymousCartSignInMode = MergeWithExistingCustomerCart
  email: String!
  password: String!
  updateProductData: Boolean = false
}

input CustomerSignMeUpDraft {
  addresses: [AddressInput!] = []

  """
  The indices of the billing addresses in the `addresses` list. The `billingAddressIds` of the customer will be set to the IDs of that addresses.
  """
  billingAddresses: [Int!] = []
  companyName: String
  custom: CustomFieldsDraft
  dateOfBirth: Date

  """
  The index of the address in the `addresses` list. The `defaultBillingAddressId` of the customer will be set to the ID of that address.
  """
  defaultBillingAddress: Int

  """
  The index of the address in the `addresses` list. The `defaultShippingAddressId` of the customer will be set to the ID of that address.
  """
  defaultShippingAddress: Int
  email: String!
  firstName: String
  key: String
  lastName: String
  locale: Locale
  middleName: String
  password: String
  salutation: String

  """
  The indices of the shipping addresses in the `addresses` list. The `shippingAddressIds` of the `Customer` will be set to the IDs of that addresses.
  """
  shippingAddresses: [Int!] = []
  stores: [ResourceIdentifierInput!]
  title: String
  vatId: String
}

input CustomerSignUpDraft {
  addresses: [AddressInput!] = []
  anonymousCart: ResourceIdentifierInput

  """This field will be deprecated in favour of anonymousCart.id."""
  anonymousCartId: String
  anonymousId: String
  authenticationMode: AuthenticationMode

  """
  The indices of the billing addresses in the `addresses` list. The `billingAddressIds` of the customer will be set to the IDs of that addresses.
  """
  billingAddresses: [Int!] = []
  companyName: String
  custom: CustomFieldsDraft
  customerGroup: ResourceIdentifierInput

  """
  CLOSED BETA: This feature is subject to change and should not be used in production. https://docs.commercetools.com/api/contract#closed-beta
  """
  customerGroupAssignments: [CustomerGroupAssignmentDraft!]
  customerNumber: String
  dateOfBirth: Date

  """
  The index of the address in the `addresses` list. The `defaultBillingAddressId` of the customer will be set to the ID of that address.
  """
  defaultBillingAddress: Int

  """
  The index of the address in the `addresses` list. The `defaultShippingAddressId` of the customer will be set to the ID of that address.
  """
  defaultShippingAddress: Int
  email: String!
  externalId: String
  firstName: String
  isEmailVerified: Boolean
  key: String
  lastName: String
  locale: Locale
  middleName: String
  password: String
  salutation: String

  """
  The indices of the shipping addresses in the `addresses` list. The `shippingAddressIds` of the `Customer` will be set to the IDs of that addresses.
  """
  shippingAddresses: [Int!] = []
  stores: [ResourceIdentifierInput!]
  title: String
  vatId: String
}

type CustomerTitleSet implements MessagePayload {
  title: String
  type: String!
}

input CustomerUpdateAction {
  addAddress: AddCustomerAddress
  addBillingAddressId: AddCustomerBillingAddressId

  """
  CLOSED BETA: This feature is subject to change and should not be used in production. https://docs.commercetools.com/api/contract#closed-beta
  """
  addCustomerGroupAssignment: AddCustomerGroupAssignment
  addShippingAddressId: AddCustomerShippingAddressId
  addStore: AddCustomerStore
  changeAddress: ChangeCustomerAddress
  changeEmail: ChangeCustomerEmail
  removeAddress: RemoveCustomerAddress
  removeBillingAddressId: RemoveCustomerBillingAddressId

  """
  CLOSED BETA: This feature is subject to change and should not be used in production. https://docs.commercetools.com/api/contract#closed-beta
  """
  removeCustomerGroupAssignment: RemoveCustomerGroupAssignment
  removeShippingAddressId: RemoveCustomerShippingAddressId
  removeStore: RemoveCustomerStore
  setAddressCustomField: SetCustomerAddressCustomField
  setAddressCustomType: SetCustomerAddressCustomType
  setAuthenticationMode: SetCustomerAuthenticationMode
  setCompanyName: SetCustomerCompanyName
  setCustomField: SetCustomerCustomField
  setCustomType: SetCustomerCustomType
  setCustomerGroup: SetCustomerGroup

  """
  CLOSED BETA: This feature is subject to change and should not be used in production. https://docs.commercetools.com/api/contract#closed-beta
  """
  setCustomerGroupAssignments: SetCustomerGroupAssignments
  setCustomerNumber: SetCustomerNumber
  setDateOfBirth: SetCustomerDateOfBirth
  setDefaultBillingAddress: SetCustomerDefaultBillingAddress
  setDefaultShippingAddress: SetCustomerDefaultShippingAddress
  setExternalId: SetCustomerExternalId
  setFirstName: SetCustomerFirstName
  setKey: SetCustomerKey
  setLastName: SetCustomerLastName
  setLocale: SetCustomerLocale
  setMiddleName: SetCustomerMiddleName
  setSalutation: SetCustomerSalutation
  setStores: SetCustomerStores
  setTitle: SetCustomerTitle
  setVatId: SetCustomerVatId
}

"""DateTime is a scalar value that represents an ISO8601 formatted date."""
scalar Date

type DateAttribute implements Attribute {
  name: String!
  value: Date!
}

type DateAttributeDefinitionType implements AttributeDefinitionType {
  name: String!
}

type DateField implements CustomField {
  name: String!
  value: Date!
}

"""
DateTime is a scalar value that represents an ISO8601 formatted date and time.
"""
scalar DateTime

type DateTimeAttribute implements Attribute {
  name: String!
  value: DateTime!
}

type DateTimeAttributeDefinitionType implements AttributeDefinitionType {
  name: String!
}

type DateTimeField implements CustomField {
  name: String!
  value: DateTime!
}

type DateTimeType implements FieldType {
  name: String!
}

type DateType implements FieldType {
  name: String!
}

type Delivery {
  address: Address
  createdAt: DateTime!
  custom: CustomFieldsType
  id: String!
  items: [DeliveryItem!]!
  key: String
  parcels: [Parcel!]!
}

type DeliveryAdded implements MessagePayload & OrderMessagePayload {
  delivery: Delivery!
  shippingKey: String
  type: String!
}

type DeliveryAddressSet implements MessagePayload & OrderMessagePayload {
  address: Address
  deliveryId: String!
  oldAddress: Address
  shippingKey: String
  type: String!
}

input DeliveryDraft {
  address: AddressInput
  custom: CustomFieldsDraft
  items: [DeliveryItemDraftType!]!
  key: String
  parcels: [ParcelDraft!]!
}

type DeliveryItem {
  id: String!
  quantity: Long!
}

input DeliveryItemDraftType {
  id: String!
  quantity: Long!
}

type DeliveryItemsUpdated implements MessagePayload & OrderMessagePayload {
  deliveryId: String!
  items: [DeliveryItem!]!
  oldItems: [DeliveryItem!]!
  shippingKey: String
  type: String!
}

type DeliveryRemoved implements MessagePayload & OrderMessagePayload {
  delivery: Delivery!
  shippingKey: String
  type: String!
}

interface Destination {
  type: String!
}

input DestinationInput {
  AzureServiceBus: AzureServiceBusDestinationInput
  ConfluentCloud: ConfluentCloudDestinationInput
  EventBridge: EventBridgeDestinationInput
  EventGrid: EventGridDestinationInput
  GoogleCloudPubSub: GoogleCloudPubSubDestinationInput
  SNS: SNSDestinationInput
  SQS: SQSDestinationInput
}

type Dimensions {
  height: Int!
  width: Int!
}

input DimensionsInput {
  height: Int!
  width: Int!
}

type DimensionsProductSearch {
  height: Int!
  width: Int!
}

type DirectDiscount {
  id: String!
  target: CartDiscountTarget
  value: CartDiscountValue!
}

input DirectDiscountDraft {
  target: CartDiscountTargetInput
  value: CartDiscountValueInput!
}

type DirectDiscountDraftOutput {
  target: CartDiscountTarget
  value: CartDiscountValue!
}

"""
With discount codes it is possible to give specific cart discounts to an eligible amount of users. They are defined by a string value which can be added to a cart so that specific cart discounts can be applied to the cart.
"""
type DiscountCode implements ReferenceExpandable & Versioned {
  """
  How many times this discount code was applied (only applications that were part of a successful checkout are considered)
  """
  applicationCount: Long!
  applicationVersion: Long
  cartDiscountRefs: [Reference!]!
  cartDiscounts: [CartDiscount!]!
  cartPredicate: String
  code: String!
  createdAt: DateTime!
  createdBy: Initiator
  custom: CustomFieldsType
  description(
    """
    List of languages the client is able to understand, and which locale variant is preferred.
    """
    acceptLanguage: [Locale!]

    """
    String is defined for different locales. This argument specifies the desired locale.
    """
    locale: Locale
  ): String
  descriptionAllLocales: [LocalizedString!]
  groups: [String!]!
  id: String!
  isActive: Boolean!
  key: String
  lastModifiedAt: DateTime!
  lastModifiedBy: Initiator
  maxApplications: Long
  maxApplicationsPerCustomer: Long
  name(
    """
    List of languages the client is able to understand, and which locale variant is preferred.
    """
    acceptLanguage: [Locale!]

    """
    String is defined for different locales. This argument specifies the desired locale.
    """
    locale: Locale
  ): String
  nameAllLocales: [LocalizedString!]
  referenceRefs: [Reference!]!
  validFrom: DateTime
  validUntil: DateTime
  version: Long!
}

type DiscountCodeCreated implements MessagePayload {
  discountCode: DiscountCode!
  type: String!
}

type DiscountCodeDeleted implements MessagePayload {
  type: String!
}

input DiscountCodeDraft {
  cartDiscounts: [ReferenceInput!]!
  cartPredicate: String
  code: String!
  custom: CustomFieldsDraft
  description: [LocalizedStringItemInputType!]
  groups: [String!] = []
  isActive: Boolean = true
  key: String
  maxApplications: Long
  maxApplicationsPerCustomer: Long
  name: [LocalizedStringItemInputType!]
  validFrom: DateTime
  validUntil: DateTime
}

type DiscountCodeInfo {
  discountCode: DiscountCode
  discountCodeRef: Reference!
  state: DiscountCodeState
}

type DiscountCodeKeySet implements MessagePayload {
  key: String
  oldKey: String
  type: String!
}

type DiscountCodeQueryResult {
  count: Int!
  exists: Boolean!
  offset: Int!
  results: [DiscountCode!]!
  total: Long!
}

enum DiscountCodeState {
  """
  The discount code is active and none of the discounts were applied because the discount application was stopped by one discount that has the StackingMode of StopAfterThisDiscount defined
  """
  ApplicationStoppedByPreviousDiscount

  """
  The discount code is active and it contains at least one active and valid CartDiscount. But its cart predicate does not match the cart or none of the contained active discount’s cart predicates match the cart
  """
  DoesNotMatchCart

  """
  The discount code is active and it contains at least one active and valid CartDiscount. The discount code cartPredicate matches the cart and at least one of the contained active discount’s cart predicates matches the cart.
  """
  MatchesCart

  """
  maxApplications or maxApplicationsPerCustomer for discountCode has been reached.
  """
  MaxApplicationReached

  """
  The discount code is not active or it does not contain any active cart discounts.
  """
  NotActive

  """
  The discount code is not valid or it does not contain any valid cart discounts. Validity is determined based on the validFrom and validUntil dates
  """
  NotValid
}

input DiscountCodeUpdateAction {
  changeCartDiscounts: ChangeDiscountCodeCartDiscounts
  changeGroups: ChangeDiscountCodeGroups
  changeIsActive: ChangeDiscountCodeIsActive
  setCartPredicate: SetDiscountCodeCartPredicate
  setCustomField: SetDiscountCodeCustomField
  setCustomType: SetDiscountCodeCustomType
  setDescription: SetDiscountCodeDescription
  setKey: SetDiscountCodeKey
  setMaxApplications: SetDiscountCodeMaxApplications
  setMaxApplicationsPerCustomer: SetDiscountCodeMaxApplicationsPerCustomer
  setName: SetDiscountCodeName
  setValidFrom: SetDiscountCodeValidFrom
  setValidFromAndUntil: SetDiscountCodeValidFromAndUntil
  setValidUntil: SetDiscountCodeValidUntil
}

type DiscountOnTotalPrice {
  discountedAmount: BaseMoney!
  discountedGrossAmount: BaseMoney
  discountedNetAmount: BaseMoney
  includedDiscounts: [DiscountedTotalPricePortion!]!
}

type DiscountedLineItemPortion {
  discount: CartDiscount
  discountRef: Reference!
  discountedAmount: BaseMoney!
}

input DiscountedLineItemPortionDraft {
  discount: ReferenceInput!
  discountedAmount: BaseMoneyInput!
}

type DiscountedLineItemPrice {
  includedDiscounts: [DiscountedLineItemPortion!]!
  value: BaseMoney!
}

input DiscountedLineItemPriceDraft {
  includedDiscounts: [DiscountedLineItemPortionDraft!] = []
  value: BaseMoneyInput!
}

type DiscountedLineItemPriceForQuantity {
  discountedPrice: DiscountedLineItemPrice!
  quantity: Long!
}

type DiscountedProductPriceValue {
  discount: ProductDiscount
  discountRef: Reference!
  value: BaseMoney!
}

input DiscountedProductPriceValueInput {
  discount: ResourceIdentifierInput!
  value: BaseMoneyInput!
}

type DiscountedProductSearchPriceValue {
  discount: ProductDiscount
  discountRef: Reference!
  value: BaseMoney!
}

type DiscountedTotalPricePortion {
  discount: CartDiscount
  discountRef: Reference!
  discountedAmount: BaseMoney!
}

type EnumAttribute implements Attribute {
  key: String!
  label: String!
  name: String!
}

type EnumAttributeDefinitionType implements AttributeDefinitionType {
  name: String!
  values(
    """
    The keys of the enum values to exclude.
    
    If neither `includeKeys` nor `excludeKeys` are provided, then all enum values are returned.
    """
    excludeKeys: [String!]

    """
    The keys of the enum values to include.
    
    If neither `includeKeys` nor `excludeKeys` are provided, then all enum values are returned.
    """
    includeKeys: [String!]
    limit: Int
    offset: Int
    sort: [String!]
  ): PlainEnumValueResult!
}

type EnumField implements CustomField {
  key: String!
  name: String!
}

type EnumType implements FieldType {
  name: String!
  values: [EnumValue!]!
}

input EnumTypeDraft {
  values: [PlainEnumValueDraft!]!
}

type EnumValue {
  key: String!
  label: String!
}

input EnumValueInput {
  key: String!
  label: String!
}

type EventBridgeDestination implements Destination {
  accountId: String!
  region: String!
  source: String!
  type: String!
}

input EventBridgeDestinationInput {
  accountId: String!
  region: String!
}

type EventGridDestination implements Destination {
  accessKey: String!
  type: String!
  uri: String!
}

input EventGridDestinationInput {
  accessKey: String!
  uri: String!
}

input ExcludeProductSelectionProduct {
  product: ResourceIdentifierInput!
  variantExclusion: ProductVariantExclusionDraft
}

input ExistsFilterInput {
  path: String!
}

type Extension implements ReferenceExpandable & Versioned {
  createdAt: DateTime!
  createdBy: Initiator
  destination: ExtensionDestination!
  id: String!
  key: String
  lastModifiedAt: DateTime!
  lastModifiedBy: Initiator
  timeoutInMs: Int
  triggers: [Trigger!]!
  version: Long!
}

interface ExtensionDestination {
  type: String!
}

input ExtensionDestinationInput {
  AWSLambda: AWSLambdaDestinationInput
  GoogleCloudFunction: GoogleCloudFunctionDestinationInput
  HTTP: HttpDestinationInput
}

input ExtensionDraft {
  destination: ExtensionDestinationInput!
  key: String
  timeoutInMs: Int
  triggers: [TriggerInput!]!
}

type ExtensionLimitsProjection {
  timeoutInMs: Limit!
}

type ExtensionQueryResult {
  count: Int!
  exists: Boolean!
  offset: Int!
  results: [Extension!]!
  total: Long!
}

input ExtensionUpdateAction {
  changeDestination: ChangeExtensionDestination
  changeTriggers: ChangeExtensionTriggers
  setKey: SetExtensionKey
  setTimeoutInMs: SetExtensionTimeoutInMs
}

type ExternalDiscountValue implements ProductDiscountValue {
  type: String!
}

input ExternalDiscountValueInput {
  dummy: String
}

type ExternalLineItemTotalPrice {
  price: BaseMoney!
  totalPrice: Money!
}

input ExternalLineItemTotalPriceDraft {
  price: BaseMoneyInput!
  totalPrice: MoneyInput!
}

type ExternalOAuth {
  authorizationHeader: String!
  url: String!
}

input ExternalOAuthDraft {
  authorizationHeader: String!
  url: String!
}

input ExternalTaxAmountDraft {
  taxRate: ExternalTaxRateDraft!
  totalGross: MoneyInput!
}

type ExternalTaxAmountDraftOutput {
  taxRate: ExternalTaxRateDraftOutput!
  totalGross: Money!
}

input ExternalTaxRateDraft {
  amount: Float!
  country: Country!
  includedInPrice: Boolean = false
  name: String!
  state: String
  subRates: [SubRateDraft!] = []
}

type ExternalTaxRateDraftOutput {
  amount: Float
  country: Country!
  includedInPrice: Boolean!
  name: String!
  state: String
  subRates: [SubRate!]!
}

interface FacetResult {
  type: String!
}

type FacetResultValue {
  facet: String!
  value: FacetResult!
}

"""
Field definitions describe custom fields and allow you to define some meta-information associated with the field.
"""
type FieldDefinition {
  inputHint: TextInputHint!
  label(
    """
    List of languages the client is able to understand, and which locale variant is preferred.
    """
    acceptLanguage: [Locale!]

    """
    String is defined for different locales. This argument specifies the desired locale.
    """
    locale: Locale
  ): String
  labelAllLocales: [LocalizedString!]!
  name: String!
  required: Boolean!
  type: FieldType!
}

input FieldDefinitionInput {
  inputHint: TextInputHint!
  label: [LocalizedStringItemInputType!]!
  name: String!
  required: Boolean!
  type: FieldTypeInput!
}

interface FieldType {
  name: String!
}

input FieldTypeEnumTypeDraft {
  values: [EnumValueInput!]!
}

input FieldTypeInput {
  Boolean: SimpleFieldTypeDraft
  Date: SimpleFieldTypeDraft
  DateTime: SimpleFieldTypeDraft
  Enum: FieldTypeEnumTypeDraft
  LocalizedEnum: FieldTypeLocalizedEnumTypeDraft
  LocalizedString: SimpleFieldTypeDraft
  Money: SimpleFieldTypeDraft
  Number: SimpleFieldTypeDraft
  Reference: FieldTypeReferenceTypeDraft
  Set: FieldTypeSetTypeDraft
  String: SimpleFieldTypeDraft
  Time: SimpleFieldTypeDraft
}

input FieldTypeLocalizedEnumTypeDraft {
  values: [LocalizedEnumValueInput!]!
}

input FieldTypeReferenceTypeDraft {
  referenceTypeId: String!
}

input FieldTypeSetElementTypeDraft {
  Boolean: SimpleFieldTypeDraft
  Date: SimpleFieldTypeDraft
  DateTime: SimpleFieldTypeDraft
  Enum: FieldTypeEnumTypeDraft
  LocalizedEnum: FieldTypeLocalizedEnumTypeDraft
  LocalizedString: SimpleFieldTypeDraft
  Money: SimpleFieldTypeDraft
  Number: SimpleFieldTypeDraft
  Reference: FieldTypeReferenceTypeDraft
  String: SimpleFieldTypeDraft
  Time: SimpleFieldTypeDraft
}

input FieldTypeSetTypeDraft {
  elementType: FieldTypeSetElementTypeDraft!
}

type FixedPriceDiscountValue implements CartDiscountValue {
  money: [BaseMoney!]!
  type: String!
}

input FixedPriceDiscountValueInput {
  money: [CartDiscountValueBaseMoneyInput!]!
}

input FreezeCart {
  dummy: String
}

interface Geometry {
  type: String!
}

input GeometryInput {
  coordinates: [Float!]
  type: String!
}

type GiftLineItemValue implements CartDiscountValue {
  distributionChannelRef: ChannelReferenceIdentifier
  productRef: ProductReferenceIdentifier!
  supplyChannelRef: ChannelReferenceIdentifier
  type: String!
  variantId: Int!
}

input GiftLineItemValueInput {
  distributionChannel: ResourceIdentifierInput
  product: ResourceIdentifierInput!
  supplyChannel: ResourceIdentifierInput
  variantId: Int!
}

type GoogleCloudFunctionDestination implements ExtensionDestination {
  type: String!
  url: String!
}

input GoogleCloudFunctionDestinationInput {
  url: String!
}

type GoogleCloudPubSubDestination implements Destination {
  projectId: String!
  topic: String!
  type: String!
}

input GoogleCloudPubSubDestinationInput {
  projectId: String!
  topic: String!
}

interface HasProductTailoringData {
  description(
    """
    List of languages the client is able to understand, and which locale variant is preferred.
    """
    acceptLanguage: [Locale!]

    """
    String is defined for different locales. This argument specifies the desired locale.
    """
    locale: Locale
  ): String
  descriptionAllLocales: [LocalizedString!]
  metaDescription(
    """
    List of languages the client is able to understand, and which locale variant is preferred.
    """
    acceptLanguage: [Locale!]

    """
    String is defined for different locales. This argument specifies the desired locale.
    """
    locale: Locale
  ): String
  metaDescriptionAllLocales: [LocalizedString!]
  metaKeywords(
    """
    List of languages the client is able to understand, and which locale variant is preferred.
    """
    acceptLanguage: [Locale!]

    """
    String is defined for different locales. This argument specifies the desired locale.
    """
    locale: Locale
  ): String
  metaKeywordsAllLocales: [LocalizedString!]
  metaTitle(
    """
    List of languages the client is able to understand, and which locale variant is preferred.
    """
    acceptLanguage: [Locale!]

    """
    String is defined for different locales. This argument specifies the desired locale.
    """
    locale: Locale
  ): String
  metaTitleAllLocales: [LocalizedString!]
  name(
    """
    List of languages the client is able to understand, and which locale variant is preferred.
    """
    acceptLanguage: [Locale!]

    """
    String is defined for different locales. This argument specifies the desired locale.
    """
    locale: Locale
  ): String
  nameAllLocales: [LocalizedString!]
  slug(
    """
    List of languages the client is able to understand, and which locale variant is preferred.
    """
    acceptLanguage: [Locale!]

    """
    String is defined for different locales. This argument specifies the desired locale.
    """
    locale: Locale
  ): String
  slugAllLocales: [LocalizedString!]
}

type HighPrecisionMoney implements BaseMoney {
  centAmount: Long!
  currencyCode: Currency!
  fractionDigits: Int!
  preciseAmount: Long!
  type: String!
}

input HighPrecisionMoneyInput {
  centAmount: Long
  currencyCode: Currency!
  fractionDigits: Int!
  preciseAmount: Long!
}

type HttpDestination implements ExtensionDestination {
  authentication: HttpDestinationAuthentication
  type: String!
  url: String!
}

interface HttpDestinationAuthentication {
  type: String!
}

input HttpDestinationAuthenticationInput {
  AuthorizationHeader: AuthorizationHeaderInput
  AzureFunctions: AzureFunctionsAuthenticationInput
}

input HttpDestinationInput {
  authentication: HttpDestinationAuthenticationInput
  url: String!
}

type Image {
  dimensions: Dimensions!
  label: String
  url: String!
}

input ImageInput {
  dimensions: DimensionsInput!
  label: String
  url: String!
}

type ImageProductSearch {
  dimensions: DimensionsProductSearch!
  label: String
  url: String!
}

input ImportOrderCustomLineItemState {
  customLineItemId: String
  customLineItemKey: String
  state: [ItemStateDraftType!]!
}

input ImportOrderDraft {
  billingAddress: AddressInput
  completedAt: DateTime
  country: Country
  custom: CustomFieldsDraft
  customLineItems: [CustomLineItemImportDraft!]! = []
  customerEmail: String
  customerGroup: ReferenceInput
  customerId: String
  inventoryMode: InventoryMode = None
  itemShippingAddresses: [AddressInput!] = []
  lineItems: [LineItemImportDraft!]! = []
  orderNumber: String
  orderState: OrderState
  origin: CartOrigin = Customer
  paymentInfo: ReferenceInput
  paymentState: PaymentState
  purchaseOrderNumber: String
  shipmentState: ShipmentState
  shippingAddress: AddressInput
  shippingDetails: ItemShippingDetailsDraft
  shippingInfo: ShippingInfoImportDraft
  state: ReferenceInput
  store: ReferenceInput
  taxCalculationMode: TaxCalculationMode = LineItemLevel
  taxedPrice: TaxedPriceDraft
  totalPrice: MoneyInput!
}

input ImportOrderLineItemState {
  lineItemId: String
  lineItemKey: String
  state: [ItemStateDraftType!]!
}

input ImportStagedOrderCustomLineItemState {
  customLineItemId: String
  customLineItemKey: String
  state: [ItemStateDraftType!]!
}

type ImportStagedOrderCustomLineItemStateOutput implements StagedOrderUpdateActionOutput {
  customLineItemId: String
  customLineItemKey: String
  state: Set!
  type: String!
}

input ImportStagedOrderLineItemState {
  lineItemId: String
  lineItemKey: String
  state: [ItemStateDraftType!]!
}

type ImportStagedOrderLineItemStateOutput implements StagedOrderUpdateActionOutput {
  lineItemId: String
  lineItemKey: String
  state: Set!
  type: String!
}

type InStore implements CartDiscountQueryInterface & CartQueryInterface & CustomerActiveCartInterface & CustomerQueryInterface & MeFieldInterface & OrderQueryInterface & ShippingMethodsByCartInterface {
  cart(id: String!): Cart
  cartDiscount(
    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
  ): CartDiscount
  cartDiscounts(limit: Int, offset: Int, sort: [String!], where: String): CartDiscountQueryResult!
  carts(limit: Int, offset: Int, sort: [String!], where: String): CartQueryResult!
  customer(
    """Queries a customer with specified email token"""
    emailToken: String

    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String

    """Queries a customer with specified password token"""
    passwordToken: String
  ): Customer
  customerActiveCart(customerId: String!): Cart
  customers(limit: Int, offset: Int, sort: [String!], where: String): CustomerQueryResult!

  """
  This field can only be used with an access token created with the password flow or with an anonymous session.
  
  It gives access to the data that is specific to the customer or the anonymous session linked to the access token.
  """
  me: InStoreMe!
  order(
    """Queries with specified ID"""
    id: String
    orderNumber: String
  ): Order
  orders(limit: Int, offset: Int, sort: [String!], where: String): OrderQueryResult!
  product(
    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
    localeProjection: [Locale!]
    projectExpandedProducts: Boolean = false

    """Queries for a product with specified SKU"""
    sku: String

    """
    Queries for a [Product](https://docs.commercetools.com/api/projects/products#product) with specified [ProductVariant](https://docs.commercetools.com/api/projects/products#productvariant) `key`
    """
    variantKey: String
  ): Product
  productSelectionAssignments(limit: Int, offset: Int, sort: [String!], where: String): ProductAssignmentQueryResult!

  """
  BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta
  """
  productTailoring(
    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String

    """Queries with specified Product ID"""
    productId: String

    """Queries with specified Product key"""
    productKey: String
  ): ProductTailoring
  productTailoringList(limit: Int, offset: Int, sort: [String!], where: String): ProductTailoringQueryResult!
  shippingMethodsByCart(id: String!): [ShippingMethod!]!
  shoppingList(
    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
  ): ShoppingList
  shoppingLists(limit: Int, offset: Int, sort: [String!], where: String): ShoppingListQueryResult!
}

type InStoreMe implements ActiveCartInterface & CartQueryInterface & MeQueryInterface & OrderQueryInterface & ShoppingListQueryInterface {
  activeCart: Cart

  """
  BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta
  """
  cart(id: String!): Cart

  """
  BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta
  """
  carts(limit: Int, offset: Int, sort: [String!], where: String): CartQueryResult!

  """
  BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta
  """
  customer: Customer

  """
  BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta
  """
  order(
    """Queries with specified ID"""
    id: String
    orderNumber: String
  ): Order

  """
  BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta
  """
  orders(limit: Int, offset: Int, sort: [String!], where: String): OrderQueryResult!

  """
  BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta
  """
  shoppingList(
    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
  ): ShoppingList

  """
  BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta
  """
  shoppingLists(limit: Int, offset: Int, sort: [String!], where: String): ShoppingListQueryResult!
}

type InheritedAssociate {
  associateRoleAssignments: [InheritedAssociateRoleAssignment!]!
  customer: Customer
  customerRef: Reference
}

type InheritedAssociateRoleAssignment {
  associateRole: AssociateRole!
  associateRoleRef: KeyReference!
  source: BusinessUnit!
  sourceRef: KeyReference!
}

type InheritedStore {
  store: Store
  storeRef: KeyReference!
}

type Initiator {
  anonymousId: String
  associateRef: Reference
  attributedTo: Attribution
  clientId: String
  customerRef: Reference
  externalUserId: String
  isPlatformClient: Boolean
  userRef: Reference
}

type InterfaceInteractionsRaw {
  fields(
    """
    The names of the custom fields to exclude.
    
    If neither `includeNames` nor `excludeNames` are provided, then all custom fields are returned.
    """
    excludeNames: [String!]

    """
    The names of the custom fields to include.
    
    If neither `includeNames` nor `excludeNames` are provided, then all custom fields are returned.
    """
    includeNames: [String!]
  ): [RawCustomField!]!
  type: TypeDefinition
  typeRef: Reference!
}

type InterfaceInteractionsRawResult {
  limit: Int
  offset: Int
  results: [InterfaceInteractionsRaw!]!
  total: Int!
}

"""
Inventory allows you to track stock quantity per SKU and optionally per supply channel
"""
type InventoryEntry implements ReferenceExpandable & Versioned {
  availableQuantity: Long!
  createdAt: DateTime!
  createdBy: Initiator
  custom: CustomFieldsType
  expectedDelivery: DateTime
  id: String!
  key: String
  lastModifiedAt: DateTime!
  lastModifiedBy: Initiator
  quantityOnStock: Long!
  restockableInDays: Int
  sku: String!
  supplyChannel: Channel
  supplyChannelRef: Reference
  version: Long!
}

type InventoryEntryCreated implements MessagePayload {
  inventoryEntry: InventoryEntry!
  type: String!
}

type InventoryEntryDeleted implements MessagePayload {
  sku: String!
  supplyChannel: Channel
  supplyChannelRef: Reference
  type: String!
}

input InventoryEntryDraft {
  custom: CustomFieldsDraft
  expectedDelivery: DateTime
  key: String
  quantityOnStock: Long!
  restockableInDays: Int
  sku: String!
  supplyChannel: ResourceIdentifierInput
}

type InventoryEntryQuantitySet implements MessagePayload {
  newAvailableQuantity: Long!
  newQuantityOnStock: Long!
  oldAvailableQuantity: Long!
  oldQuantityOnStock: Long!
  supplyChannel: Channel
  supplyChannelRef: Reference
  type: String!
}

type InventoryEntryQueryResult {
  count: Int!
  exists: Boolean!
  offset: Int!
  results: [InventoryEntry!]!
  total: Long!
}

input InventoryEntryUpdateAction {
  addQuantity: AddInventoryEntryQuantity
  changeQuantity: ChangeInventoryEntryQuantity
  removeQuantity: RemoveInventoryEntryQuantity
  setCustomField: SetInventoryEntryCustomField
  setCustomType: SetInventoryEntryCustomType
  setExpectedDelivery: SetInventoryEntryExpectedDelivery
  setRestockableInDays: SetInventoryEntryRestockableInDays
  setSupplyChannel: SetInventoryEntrySupplyChannel
}

enum InventoryMode {
  """
  Adding items to cart and ordering is independent of inventory. No inventory checks or modifications.
  This is the default mode for a new cart.
  """
  None

  """
  Creating an order will fail with an OutOfStock error if an unavailable line item exists. Line items in the cart
  are only reserved for the duration of the ordering transaction.
  """
  ReserveOnOrder

  """
  Orders are tracked on inventory. That means, ordering a LineItem will decrement the available quantity on the
  respective InventoryEntry. Creating an order will succeed even if the line item’s available quantity is zero or
  negative. But creating an order will fail with an OutOfStock error if no matching inventory entry exists for a
  line item.
  """
  TrackOnly
}

type ItemShippingDetails {
  targets: [ItemShippingTarget!]!
  valid: Boolean!
}

input ItemShippingDetailsDraft {
  targets: [ShippingTargetDraft!]!
}

type ItemShippingDetailsDraftOutput {
  targets: [ItemShippingTarget!]!
}

input ItemShippingDetailsDraftType {
  targets: [ShippingTargetDraftType!]!
}

type ItemShippingTarget {
  addressKey: String!
  quantity: Long!
  shippingMethodKey: String
}

type ItemState {
  quantity: Long!
  state: State
  stateRef: Reference!
}

input ItemStateDraftType {
  quantity: Long!
  state: ReferenceInput!
}

"""Raw JSON value"""
scalar Json

type KeyReference {
  key: String!
  typeId: String!
}

"""A key that references a resource."""
scalar KeyReferenceInput

type Limit {
  limit: Long
}

interface LimitWithCurrent {
  current: Long
  limit: Long
}

"""
A line item is a snapshot of a product variant at the time it was added to the cart.

Since a product variant may change at any time, the ProductVariant data is copied into the field variant.
The relation to the Product is kept but the line item will not automatically update if the product variant changes.
On the cart, the line item can be updated manually. The productSlug refers to the current version of the product.
It can be used to link to the product. If the product has been deleted, the line item remains but refers to a
non-existent product and the productSlug is left empty.

Please also note that creating an order is impossible if the product or product variant a line item relates to has been deleted.
"""
type LineItem {
  addedAt: DateTime
  custom: CustomFieldsType
  discountedPricePerQuantity: [DiscountedLineItemPriceForQuantity!]!
  distributionChannel: Channel
  distributionChannelRef: Reference
  id: String!
  inventoryMode: InventoryMode
  key: String
  lastModifiedAt: DateTime
  lineItemMode: LineItemMode!
  name(
    """
    List of languages the client is able to understand, and which locale variant is preferred.
    """
    acceptLanguage: [Locale!]

    """
    String is defined for different locales. This argument specifies the desired locale.
    """
    locale: Locale
  ): String
  nameAllLocales: [LocalizedString!]!
  perMethodTaxRate: [MethodTaxRate!]!
  price: ProductPrice!
  priceMode: LineItemPriceMode!
  productId: String!
  productKey: String
  productSlug(
    """
    List of languages the client is able to understand, and which locale variant is preferred.
    """
    acceptLanguage: [Locale!]

    """
    String is defined for different locales. This argument specifies the desired locale.
    """
    locale: Locale
  ): String
  productSlugAllLocales: [LocalizedString!]
  productType: ProductTypeDefinition
  productTypeRef: Reference
  quantity: Long!
  shippingDetails: ItemShippingDetails
  state: [ItemState!]!
  supplyChannel: Channel
  supplyChannelRef: Reference
  taxRate: TaxRate
  taxedPrice: TaxedItemPrice
  taxedPricePortions: [MethodTaxedPrice!]!
  totalPrice: Money
  variant: ProductVariant
}

input LineItemDraft {
  addedAt: DateTime
  custom: CustomFieldsDraft
  distributionChannel: ResourceIdentifierInput
  externalPrice: BaseMoneyInput
  externalTaxRate: ExternalTaxRateDraft
  externalTotalPrice: ExternalLineItemTotalPriceDraft
  inventoryMode: InventoryMode
  key: String
  productId: String
  quantity: Long
  shippingDetails: ItemShippingDetailsDraft
  sku: String
  supplyChannel: ResourceIdentifierInput
  variantId: Int
}

type LineItemDraftOutput {
  addedAt: DateTime
  custom: CustomFieldsCommand
  distributionChannelResId: ResourceIdentifier
  externalPrice: BaseMoney
  externalTaxRate: ExternalTaxRateDraftOutput
  externalTotalPrice: ExternalLineItemTotalPrice
  inventoryMode: InventoryMode
  key: String
  perMethodExternalTaxRate: [MethodExternalTaxRateDraftOutput!]!
  productId: String
  quantity: Long
  shippingDetails: ItemShippingDetailsDraftOutput
  sku: String
  supplyChannelResId: ResourceIdentifier
  variantId: Int
}

input LineItemImportDraft {
  custom: CustomFieldsDraft
  distributionChannel: ResourceIdentifierInput
  key: String
  name: [LocalizedStringItemInputType!]!
  price: ProductPriceDataInput!
  productId: String
  quantity: Long!
  shippingDetails: ItemShippingDetailsDraft
  state: [ItemStateDraftType!]
  supplyChannel: ResourceIdentifierInput
  taxRate: TaxRateInput
  variant: ProductVariantImportDraft!
}

enum LineItemMode {
  """
  The line item was added automatically, because a discount has added a free gift to the cart.
  The quantity can not be increased, and it won’t be merged when the same product variant is added.
  If the gift is removed, an entry is added to the "refusedGifts" array and the discount won’t be applied again
  to the cart. The price can not be changed externally.
  All other updates, such as the ones related to custom fields, can be used.
  """
  GiftLineItem

  """
  The line item was added during cart creation or with the update action addLineItem. Its quantity can be
  changed without restrictions.
  """
  Standard
}

enum LineItemPriceMode {
  """
  The line item price was set externally. Cart discounts can apply to line items with this price mode. All update actions that change the quantity of a line item with this price mode require the externalPrice field to be given.
  """
  ExternalPrice

  """The line item price with the total was set externally."""
  ExternalTotal

  """
  The price is selected form the product variant. This is the default mode.
  """
  Platform
}

type LineItemReturnItem implements ReturnItem {
  comment: String
  createdAt: DateTime!
  custom: CustomFieldsType
  id: String!
  key: String
  lastModifiedAt: DateTime!
  lineItemId: String!
  paymentState: ReturnPaymentState!
  quantity: Long!
  shipmentState: ReturnShipmentState!
  type: String!
}

type LineItemStateTransition implements MessagePayload & OrderMessagePayload {
  fromState: State
  fromStateRef: Reference!
  lineItemId: String!
  lineItemKey: String
  quantity: Long!
  toState: State
  toStateRef: Reference!
  transitionDate: DateTime!
  type: String!
}

type LineItemsTarget implements CartDiscountTarget {
  predicate: String!
  type: String!
}

input LineItemsTargetInput {
  predicate: String!
}

"""Locale is a scalar value represented as a string language tag."""
scalar Locale

type LocalizableEnumAttributeDefinitionType implements AttributeDefinitionType {
  name: String!
  values(
    """
    The keys of the enum values to exclude.
    
    If neither `includeKeys` nor `excludeKeys` are provided, then all enum values are returned.
    """
    excludeKeys: [String!]

    """
    The keys of the enum values to include.
    
    If neither `includeKeys` nor `excludeKeys` are provided, then all enum values are returned.
    """
    includeKeys: [String!]
    limit: Int
    offset: Int
    sort: [String!]
  ): LocalizableEnumValueTypeResult!
}

input LocalizableEnumTypeDraft {
  values: [LocalizedEnumValueDraft!]!
}

type LocalizableEnumValueType {
  key: String!
  label(
    """
    List of languages the client is able to understand, and which locale variant is preferred.
    """
    acceptLanguage: [Locale!]

    """
    String is defined for different locales. This argument specifies the desired locale.
    """
    locale: Locale
  ): String
  labelAllLocales: [LocalizedString!]!
}

type LocalizableEnumValueTypeResult {
  limit: Int
  offset: Int
  results: [LocalizableEnumValueType!]!
  total: Int!
}

type LocalizableTextAttributeDefinitionType implements AttributeDefinitionType {
  name: String!
}

type LocalizedEnumAttribute implements Attribute {
  key: String!
  label(
    """
    String is defined for different locales. This argument specifies the desired locale.
    """
    locale: Locale!
  ): String
  name: String!
}

type LocalizedEnumField implements CustomField {
  key: String!
  label(
    """
    String is defined for different locales. This argument specifies the desired locale.
    """
    locale: Locale!
  ): String
  name: String!
}

type LocalizedEnumType implements FieldType {
  name: String!
  values: [LocalizedEnumValue!]!
}

type LocalizedEnumValue {
  key: String!
  label(
    """
    List of languages the client is able to understand, and which locale variant is preferred.
    """
    acceptLanguage: [Locale!]

    """
    String is defined for different locales. This argument specifies the desired locale.
    """
    locale: Locale
  ): String
  labelAllLocales: [LocalizedString!]!
}

input LocalizedEnumValueDraft {
  key: String!
  label: [LocalizedStringItemInputType!]!
}

input LocalizedEnumValueInput {
  key: String!
  label: [LocalizedStringItemInputType!]!
}

type LocalizedString {
  locale: Locale!
  value: String!
}

type LocalizedStringAttribute implements Attribute {
  name: String!
  value(
    """
    String is defined for different locales. This argument specifies the desired locale.
    """
    locale: Locale!
  ): String
}

type LocalizedStringField implements CustomField {
  name: String!
  value(
    """
    String is defined for different locales. This argument specifies the desired locale.
    """
    locale: Locale!
  ): String
}

input LocalizedStringItemInputType {
  locale: Locale!
  value: String!
}

type LocalizedStringType implements FieldType {
  name: String!
}

type Location {
  country: Country!
  state: String
}

"""
The `Long` scalar type represents non-fractional signed whole numeric values. Long can represent values between -(2^63) and 2^63 - 1.
"""
scalar Long

type Me implements ActiveCartInterface & CartQueryInterface & MeQueryInterface & OrderQueryInterface & ShoppingListQueryInterface {
  activeCart: Cart

  """
  BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta
  """
  businessUnit(
    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
  ): BusinessUnit

  """
  BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta
  """
  businessUnits(limit: Int, offset: Int, sort: [String!], where: String): BusinessUnitQueryResult!

  """
  BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta
  """
  cart(id: String!): Cart

  """
  BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta
  """
  carts(limit: Int, offset: Int, sort: [String!], where: String): CartQueryResult!

  """
  BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta
  """
  customer: Customer

  """
  BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta
  """
  order(
    """Queries with specified ID"""
    id: String
    orderNumber: String
  ): Order

  """
  BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta
  """
  orders(limit: Int, offset: Int, sort: [String!], where: String): OrderQueryResult!

  """
  BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta
  """
  payment(id: String!): MyPayment

  """
  BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta
  """
  payments(limit: Int, offset: Int, sort: [String!], where: String): MyPaymentQueryResult!

  """
  BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta
  """
  quote(
    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
  ): Quote

  """
  BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta
  """
  quoteRequest(
    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
  ): QuoteRequest

  """
  BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta
  """
  quoteRequests(limit: Int, offset: Int, sort: [String!], where: String): QuoteRequestQueryResult!

  """
  BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta
  """
  quotes(limit: Int, offset: Int, sort: [String!], where: String): QuoteQueryResult!

  """
  BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta
  """
  shoppingList(
    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
  ): ShoppingList

  """
  BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta
  """
  shoppingLists(limit: Int, offset: Int, sort: [String!], where: String): ShoppingListQueryResult!
}

"""
The me field gives access to the data that is specific to the customer or anonymous session linked to the access token.
"""
interface MeFieldInterface {
  me: MeQueryInterface!
}

interface MeQueryInterface implements ActiveCartInterface & CartQueryInterface & OrderQueryInterface & ShoppingListQueryInterface {
  activeCart: Cart
  cart(id: String!): Cart
  carts(limit: Int, offset: Int, sort: [String!], where: String): CartQueryResult!
  order(
    """Queries with specified ID"""
    id: String
    orderNumber: String
  ): Order
  orders(limit: Int, offset: Int, sort: [String!], where: String): OrderQueryResult!
  shoppingList(
    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
  ): ShoppingList
  shoppingLists(limit: Int, offset: Int, sort: [String!], where: String): ShoppingListQueryResult!
}

type Message implements ReferenceExpandable & Versioned {
  createdAt: DateTime!
  createdBy: Initiator
  id: String!
  lastModifiedAt: DateTime!
  lastModifiedBy: Initiator
  payload: MessagePayload!
  resourceRef: Reference!
  resourceVersion: Long!
  sequenceNumber: Long!
  type: String!
  userProvidedIdentifiers: UserProvidedIdentifiers
  version: Long!
}

interface MessagePayload {
  type: String!
}

type MessageQueryResult {
  count: Int!
  exists: Boolean!
  offset: Int!
  results: [Message!]!
  total: Long!
}

type MessageSubscription {
  resourceTypeId: String!
  types: [String!]!
}

input MessageSubscriptionInput {
  resourceTypeId: String!
  types: [String!]
}

type MessagesConfiguration {
  deleteDaysAfterCreation: Int
  enabled: Boolean!
}

input MessagesConfigurationDraft {
  deleteDaysAfterCreation: Int!
  enabled: Boolean!
}

input MethodExternalTaxRateDraft {
  shippingMethodKey: String!
  taxRate: ExternalTaxRateDraft
}

type MethodExternalTaxRateDraftOutput {
  shippingMethodKey: String!
  taxRate: ExternalTaxRateDraftOutput
}

type MethodTaxRate {
  shippingMethodKey: String!
  taxRate: TaxRate
}

type MethodTaxedPrice {
  shippingMethodKey: String!
  taxedPrice: TaxedItemPrice
}

input MissingFilterInput {
  path: String!
}

type Money implements BaseMoney {
  centAmount: Long!
  currencyCode: Currency!

  """
  For the `Money` it equals to the default number of fraction digits used with the currency.
  """
  fractionDigits: Int!
  type: String!
}

type MoneyAttribute implements Attribute {
  centAmount: Long!
  currencyCode: Currency!
  name: String!
}

type MoneyAttributeDefinitionType implements AttributeDefinitionType {
  name: String!
}

input MoneyDraft {
  centAmount: Long!
  currencyCode: Currency!
}

type MoneyField implements CustomField {
  centAmount: Long!
  currencyCode: Currency!
  name: String!
}

input MoneyInput {
  centAmount: Long!
  currencyCode: Currency!
}

type MoneyType implements FieldType {
  name: String!
}

input MoveProductImageToPosition {
  imageUrl: String!
  position: Int!
  sku: String
  staged: Boolean
  variantId: Int
}

type MultiBuyCustomLineItemsTarget implements CartDiscountTarget {
  discountedQuantity: Long!
  maxOccurrence: Int
  predicate: String!
  selectionMode: SelectionMode!
  triggerQuantity: Long!
  type: String!
}

input MultiBuyCustomLineItemsTargetInput {
  discountedQuantity: Long!
  maxOccurrence: Int
  predicate: String!
  selectionMode: SelectionMode
  triggerQuantity: Long!
}

type MultiBuyLineItemsTarget implements CartDiscountTarget {
  discountedQuantity: Long!
  maxOccurrence: Int
  predicate: String!
  selectionMode: SelectionMode!
  triggerQuantity: Long!
  type: String!
}

input MultiBuyLineItemsTargetInput {
  discountedQuantity: Long!
  maxOccurrence: Int
  predicate: String!
  selectionMode: SelectionMode
  triggerQuantity: Long!
}

type Mutation {
  createApiClient(draft: CreateApiClient!): APIClientWithSecret
  createApprovalRule(
    """Create/modify entity as an associate in business-unit."""
    asAssociate: AsAssociateArgument!
    draft: ApprovalRuleDraft!
  ): ApprovalRule
  createAssociateRole(draft: AssociateRoleDraft!): AssociateRole
  createAttributeGroup(draft: AttributeGroupDraft!): AttributeGroup
  createBusinessUnit(
    """Create/modify entity as an associate in business-unit."""
    asAssociate: AsAssociateArgument
    draft: BusinessUnitDraft!
  ): BusinessUnit
  createCart(
    """Create/modify entity as an associate in business-unit."""
    asAssociate: AsAssociateArgument
    draft: CartDraft!

    """
    The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions.
    """
    storeKey: KeyReferenceInput
  ): Cart
  createCartDiscount(
    draft: CartDiscountDraft!

    """
    The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions.
    """
    storeKey: KeyReferenceInput
  ): CartDiscount
  createCategory(draft: CategoryDraft!): Category
  createChannel(draft: ChannelDraft!): Channel
  createCustomerGroup(draft: CustomerGroupDraft!): CustomerGroup
  createDiscountCode(draft: DiscountCodeDraft!): DiscountCode
  createExtension(draft: ExtensionDraft!): Extension
  createInventoryEntry(draft: InventoryEntryDraft!): InventoryEntry
  createMyBusinessUnit(draft: MyBusinessUnitDraft!): BusinessUnit

  """
  BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta
  """
  createMyCart(
    draft: MyCartDraft!

    """
    The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions.
    """
    storeKey: KeyReferenceInput
  ): Cart

  """
  BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta
  """
  createMyOrderFromCart(
    draft: OrderMyCartCommand!

    """
    The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions.
    """
    storeKey: KeyReferenceInput
  ): Order

  """
  BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta
  """
  createMyOrderFromQuote(draft: OrderMyQuoteCommand!): Order

  """
  BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta
  """
  createMyPayment(draft: MyPaymentDraft!): MyPayment
  createMyQuoteRequest(draft: MyQuoteRequestDraft!): QuoteRequest

  """
  BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta
  """
  createMyShoppingList(
    draft: MyShoppingListDraft!

    """
    The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions.
    """
    storeKey: KeyReferenceInput
  ): ShoppingList
  createOrUpdateCustomObject(draft: CustomObjectDraft!): CustomObject
  createOrderEdit(draft: OrderEditDraft!): OrderEdit
  createOrderFromCart(
    """Create/modify entity as an associate in business-unit."""
    asAssociate: AsAssociateArgument
    draft: OrderCartCommand!

    """
    The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions.
    """
    storeKey: KeyReferenceInput
  ): Order
  createOrderFromQuote(
    """Create/modify entity as an associate in business-unit."""
    asAssociate: AsAssociateArgument
    draft: OrderQuoteCommand!
  ): Order
  createPayment(draft: PaymentDraft!): Payment
  createProduct(draft: ProductDraft!): Product
  createProductDiscount(draft: ProductDiscountDraft!): ProductDiscount
  createProductSelection(draft: CreateProductSelectionDraft!): ProductSelection

  """
  BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta
  """
  createProductTailoring(
    draft: ProductTailoringDraft!

    """
    The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions.
    """
    storeKey: KeyReferenceInput
  ): ProductTailoring
  createProductType(draft: ProductTypeDraft!): ProductTypeDefinition
  createQuote(draft: QuoteDraft!): Quote
  createQuoteRequest(
    """Create/modify entity as an associate in business-unit."""
    asAssociate: AsAssociateArgument
    draft: QuoteRequestDraft!
  ): QuoteRequest
  createReview(draft: ReviewDraft!): Review
  createShippingMethod(draft: ShippingMethodDraft!): ShippingMethod
  createShoppingList(
    draft: ShoppingListDraft!

    """
    The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions.
    """
    storeKey: KeyReferenceInput
  ): ShoppingList
  createStagedQuote(draft: StagedQuoteDraft!): StagedQuote
  createStandalonePrice(draft: CreateStandalonePrice!): StandalonePrice
  createState(draft: StateDraft!): State
  createStore(draft: CreateStore!): Store
  createSubscription(draft: SubscriptionDraft!): CommercetoolsSubscription
  createTaxCategory(draft: TaxCategoryDraft!): TaxCategory
  createTypeDefinition(draft: TypeDefinitionDraft!): TypeDefinition
  createZone(draft: CreateZone!): Zone

  """
  BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta
  """
  customerChangeMyPassword(
    currentPassword: String!
    newPassword: String!

    """
    The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions.
    """
    storeKey: KeyReferenceInput
    version: Long!
  ): Customer
  customerChangePassword(
    currentPassword: String!
    id: String!
    newPassword: String!

    """
    The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions.
    """
    storeKey: KeyReferenceInput
    version: Long!
  ): Customer

  """Verifies customer's email using a token."""
  customerConfirmEmail(
    """
    The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions.
    """
    storeKey: KeyReferenceInput
    tokenValue: String!
    version: Long
  ): Customer

  """
  BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta
  """
  customerConfirmMyEmail(
    """
    The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions.
    """
    storeKey: KeyReferenceInput
    tokenValue: String!
  ): Customer
  customerCreateEmailVerificationToken(
    id: String!

    """
    The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions.
    """
    storeKey: KeyReferenceInput

    """The validity of the created token in minutes."""
    ttlMinutes: Int!
    version: Long
  ): CustomerEmailToken!

  """
  The token value is used to reset the password of the customer with the given email. The token is valid only for 10 minutes.
  """
  customerCreatePasswordResetToken(
    email: String!

    """
    The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions.
    """
    storeKey: KeyReferenceInput

    """The validity of the created token in minutes."""
    ttlMinutes: Int
  ): CustomerPasswordToken

  """
  BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta
  """
  customerResetMyPassword(
    newPassword: String!

    """
    The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions.
    """
    storeKey: KeyReferenceInput
    tokenValue: String!
  ): Customer

  """
  The following workflow can be used to reset the customer’s password:
  
  1. Create a password reset token and send it embedded in a link to the customer.
  2. When the customer clicks on the link, you may optionally retrieve customer by password token.
  3. When the customer entered new password, use reset customer’s password to reset the password.
  """
  customerResetPassword(
    newPassword: String!

    """
    The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions.
    """
    storeKey: KeyReferenceInput
    tokenValue: String!
    version: Long
  ): Customer

  """
  Retrieves the authenticated customer (a customer that matches the given email/password pair).
  
  There may be carts and orders created before the sign in that should be assigned to the customer account. With the `anonymousCartId`, a single anonymous cart can be assigned. With the `anonymousId`, all orders and carts that have this `anonymousId` set will be assigned to the customer.
  If both `anonymousCartId` and `anonymousId` are given, the anonymous cart must have the `anonymousId`.
  
  Additionally, there might also exist one or more active customer carts from an earlier session. On customer sign in there are several ways how to proceed with this cart and the cart referenced by the `anonymousCartId`.
  
  * If the customer does not have a cart yet, the anonymous cart becomes the customer's cart.
  * If the customer already has one or more carts, the content of the anonymous cart will be copied to the customer's active cart that has been modified most recently.
  
    In this case the `CartState` of the anonymous cart gets changed to `Merged` while the customer's cart remains the `Active` cart.
  
    If a `LineItem` in the anonymous cart matches an existing line item, or a `CustomLineItem` matches an existing custom line item in the customer's cart, the maximum quantity of both line items is used as the new quantity.
  
    `ItemShippingDetails` are copied from the item with the highest quantity.
  
    If `itemShippingAddresses` are different in the two carts, the resulting cart contains the addresses of both the customer cart and the anonymous cart.
  
    Note, that it is not possible to merge carts that differ in their currency (set during creation of the cart).
  
  If a cart is is returned as part of the `CustomerSignInResult`, it has been recalculated (it will have up-to-date prices, taxes and discounts, and invalid line items have been removed).
  """
  customerSignIn(
    draft: CustomerSignInDraft!

    """
    The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions.
    """
    storeKey: KeyReferenceInput
  ): CustomerSignInResult!

  """
  BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta
  
  Retrieves the authenticated customer (a customer that matches the given email/password pair).
  
  If used with an access token for Anonymous Sessions, all orders and carts belonging to the `anonymousId` will be assigned to the newly created customer.
  
  * If the customer does not have a cart yet, the anonymous cart that was modified most recently becomes the customer's cart.
  * If the customer already has a cart, the most recently modified anonymous cart will be handled according to the `AnonymousCartSignInMode`.
  
  If a cart is is returned as part of the `CustomerSignInResult`, it has been recalculated (it will have up-to-date prices, taxes and discounts, and invalid line items have been removed).
  """
  customerSignMeIn(
    draft: CustomerSignMeInDraft!

    """
    The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions.
    """
    storeKey: KeyReferenceInput
  ): CustomerSignInResult!

  """
  BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta If used with an access token for Anonymous Sessions, all orders and carts belonging to the anonymousId will be assigned to the newly created customer.
  """
  customerSignMeUp(
    draft: CustomerSignMeUpDraft!

    """
    The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions.
    """
    storeKey: KeyReferenceInput
  ): CustomerSignInResult!

  """
  Creates a customer. If an anonymous cart is given then the cart is assigned to the created customer and the version number of the Cart will increase. If the id of an anonymous session is given, all carts and orders will be assigned to the created customer.
  """
  customerSignUp(
    draft: CustomerSignUpDraft!

    """
    The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions.
    """
    storeKey: KeyReferenceInput
  ): CustomerSignInResult!
  deleteApiClient(id: String!): APIClientWithoutSecret
  deleteAssociateRole(
    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
    personalDataErasure: Boolean = false
    version: Long!
  ): AssociateRole
  deleteAttributeGroup(
    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
    version: Long!
  ): AttributeGroup
  deleteBusinessUnit(
    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
    personalDataErasure: Boolean = false
    version: Long!
  ): BusinessUnit
  deleteCart(
    """Create/modify entity as an associate in business-unit."""
    asAssociate: AsAssociateArgument

    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
    personalDataErasure: Boolean = false

    """
    The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions.
    """
    storeKey: KeyReferenceInput
    version: Long!
  ): Cart
  deleteCartDiscount(
    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String

    """
    The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions.
    """
    storeKey: KeyReferenceInput
    version: Long!
  ): CartDiscount
  deleteCategory(
    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
    version: Long!
  ): Category
  deleteChannel(id: String!, version: Long!): Channel
  deleteCustomObject(
    container: String

    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
    personalDataErasure: Boolean = false
    version: Long
  ): CustomObject
  deleteCustomer(
    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
    personalDataErasure: Boolean = false

    """
    The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions.
    """
    storeKey: KeyReferenceInput
    version: Long!
  ): Customer
  deleteCustomerGroup(
    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
    version: Long!
  ): CustomerGroup
  deleteDiscountCode(
    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
    version: Long!
  ): DiscountCode
  deleteExtension(
    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
    version: Long!
  ): Extension
  deleteInventoryEntry(
    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
    version: Long!
  ): InventoryEntry

  """
  BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta
  """
  deleteMyCart(
    id: String!

    """
    The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions.
    """
    storeKey: KeyReferenceInput
    version: Long!
  ): Cart

  """
  BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta
  """
  deleteMyCustomer(
    personalDataErasure: Boolean = false

    """
    The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions.
    """
    storeKey: KeyReferenceInput
    version: Long!
  ): Customer
  deleteMyPayment(id: String!, version: Long!): MyPayment

  """
  BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta
  """
  deleteMyShoppingList(
    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String

    """
    The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions.
    """
    storeKey: KeyReferenceInput
    version: Long!
  ): ShoppingList
  deleteOrder(
    """Queries with specified ID"""
    id: String
    orderNumber: String
    personalDataErasure: Boolean = false

    """
    The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions.
    """
    storeKey: KeyReferenceInput
    version: Long!
  ): Order
  deleteOrderEdit(
    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
    version: Long!
  ): OrderEdit
  deletePayment(
    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
    personalDataErasure: Boolean = false
    version: Long!
  ): Payment
  deleteProduct(
    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
    version: Long!
  ): Product
  deleteProductDiscount(
    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
    version: Long!
  ): ProductDiscount
  deleteProductSelection(
    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
    version: Long!
  ): ProductSelection

  """
  BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta
  """
  deleteProductTailoring(
    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String

    """Queries with specified Product ID"""
    productId: String

    """Queries with specified Product key"""
    productKey: String

    """
    The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions.
    """
    storeKey: KeyReferenceInput
    version: Long!
  ): ProductTailoring
  deleteProductType(
    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
    version: Long!
  ): ProductTypeDefinition
  deleteQuote(
    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
    personalDataErasure: Boolean = false
    version: Long!
  ): Quote
  deleteQuoteRequest(
    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
    personalDataErasure: Boolean = false
    version: Long!
  ): QuoteRequest
  deleteReview(
    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
    personalDataErasure: Boolean = false
    version: Long!
  ): Review
  deleteShippingMethod(
    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
    version: Long!
  ): ShippingMethod
  deleteShoppingList(
    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
    personalDataErasure: Boolean = false

    """
    The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions.
    """
    storeKey: KeyReferenceInput
    version: Long!
  ): ShoppingList
  deleteStagedQuote(
    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
    personalDataErasure: Boolean = false
    version: Long!
  ): StagedQuote
  deleteStandalonePrice(
    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
    version: Long!
  ): StandalonePrice
  deleteState(
    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
    version: Long!
  ): State
  deleteStore(
    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
    version: Long!
  ): Store
  deleteSubscription(
    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
    version: Long!
  ): CommercetoolsSubscription
  deleteTaxCategory(
    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
    version: Long!
  ): TaxCategory
  deleteTypeDefinition(
    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
    version: Long!
  ): TypeDefinition
  deleteZone(
    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
    version: Long!
  ): Zone
  importOrder(draft: ImportOrderDraft!): Order
  replicateCart(
    """Create/modify entity as an associate in business-unit."""
    asAssociate: AsAssociateArgument
    key: String
    reference: ReferenceInput!

    """
    The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions.
    """
    storeKey: KeyReferenceInput
  ): Cart

  """
  BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta
  """
  replicateMyCart(reference: ReferenceInput!): Cart

  """
  BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta Signs up a new customer and associates it with the business unit.
  """
  signUpInMyBusinessUnit(draft: SignUpInMyBusinessUnitDraft!): CustomerSignInResult!
  updateApprovalFlow(
    actions: [ApprovalFlowUpdateAction!]!

    """Create/modify entity as an associate in business-unit."""
    asAssociate: AsAssociateArgument!
    id: String!
    version: Long!
  ): ApprovalFlow
  updateApprovalRule(
    actions: [ApprovalRuleUpdateAction!]!

    """Create/modify entity as an associate in business-unit."""
    asAssociate: AsAssociateArgument!

    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
    version: Long!
  ): ApprovalRule
  updateAssociateRole(
    actions: [AssociateRoleUpdateAction!]!

    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
    version: Long!
  ): AssociateRole
  updateAttributeGroup(
    actions: [AttributeGroupUpdateAction!]!

    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
    version: Long!
  ): AttributeGroup
  updateBusinessUnit(
    actions: [BusinessUnitUpdateAction!]!

    """Create/modify entity as an associate in business-unit."""
    asAssociate: AsAssociateArgument

    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
    version: Long!
  ): BusinessUnit
  updateCart(
    actions: [CartUpdateAction!]!

    """Create/modify entity as an associate in business-unit."""
    asAssociate: AsAssociateArgument

    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String

    """
    The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions.
    """
    storeKey: KeyReferenceInput
    version: Long!
  ): Cart
  updateCartDiscount(
    actions: [CartDiscountUpdateAction!]!

    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String

    """
    The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions.
    """
    storeKey: KeyReferenceInput
    version: Long!
  ): CartDiscount
  updateCategory(
    actions: [CategoryUpdateAction!]!

    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
    version: Long!
  ): Category
  updateChannel(actions: [ChannelUpdateAction!]!, id: String!, version: Long!): Channel
  updateCustomer(
    actions: [CustomerUpdateAction!]!

    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String

    """
    The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions.
    """
    storeKey: KeyReferenceInput
    version: Long!
  ): Customer
  updateCustomerGroup(
    actions: [CustomerGroupUpdateAction!]!

    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
    version: Long!
  ): CustomerGroup
  updateDiscountCode(
    actions: [DiscountCodeUpdateAction!]!

    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
    version: Long!
  ): DiscountCode
  updateExtension(
    actions: [ExtensionUpdateAction!]!

    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
    version: Long!
  ): Extension
  updateInventoryEntry(
    actions: [InventoryEntryUpdateAction!]!

    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
    version: Long!
  ): InventoryEntry
  updateMyBusinessUnit(
    actions: [MyBusinessUnitUpdateAction!]!

    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
    version: Long!
  ): BusinessUnit

  """
  BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta
  """
  updateMyCart(
    actions: [MyCartUpdateAction!]!
    id: String!

    """
    The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions.
    """
    storeKey: KeyReferenceInput
    version: Long!
  ): Cart

  """
  BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta
  """
  updateMyCustomer(
    actions: [MyCustomerUpdateAction!]!

    """
    The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions.
    """
    storeKey: KeyReferenceInput
    version: Long!
  ): Customer
  updateMyPayment(actions: [MyPaymentUpdateAction!]!, id: String!, version: Long!): MyPayment
  updateMyQuote(
    actions: [MyQuoteUpdateAction!]!

    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
    version: Long!
  ): Quote
  updateMyQuoteRequest(
    actions: [MyQuoteRequestUpdateAction!]!

    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
    version: Long!
  ): QuoteRequest

  """
  BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta
  """
  updateMyShoppingList(
    actions: [MyShoppingListUpdateAction!]!

    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String

    """
    The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions.
    """
    storeKey: KeyReferenceInput
    version: Long!
  ): ShoppingList
  updateOrder(
    actions: [OrderUpdateAction!]!

    """Create/modify entity as an associate in business-unit."""
    asAssociate: AsAssociateArgument

    """Queries with specified ID"""
    id: String
    orderNumber: String

    """
    The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions.
    """
    storeKey: KeyReferenceInput
    version: Long!
  ): Order
  updateOrderEdit(
    actions: [OrderEditUpdateAction!]!
    dryRun: Boolean = false

    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
    version: Long!
  ): OrderEdit
  updatePayment(
    actions: [PaymentUpdateAction!]!

    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
    version: Long!
  ): Payment
  updateProduct(
    actions: [ProductUpdateAction!]!

    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
    version: Long!
  ): Product
  updateProductDiscount(
    actions: [ProductDiscountUpdateAction!]!

    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
    version: Long!
  ): ProductDiscount
  updateProductSelection(
    actions: [ProductSelectionUpdateAction!]!

    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
    version: Long!
  ): ProductSelection

  """
  BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta
  """
  updateProductTailoring(
    actions: [ProductTailoringUpdateAction!]!

    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String

    """Queries with specified Product ID"""
    productId: String

    """Queries with specified Product key"""
    productKey: String

    """
    The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions.
    """
    storeKey: KeyReferenceInput
    version: Long!
  ): ProductTailoring
  updateProductType(
    actions: [ProductTypeUpdateAction!]!

    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
    version: Long!
  ): ProductTypeDefinition
  updateProject(actions: [ProjectSettingsUpdateAction!]!, version: Long!): ProjectProjection
  updateQuote(
    actions: [QuoteUpdateAction!]!

    """Create/modify entity as an associate in business-unit."""
    asAssociate: AsAssociateArgument

    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
    version: Long!
  ): Quote
  updateQuoteRequest(
    actions: [QuoteRequestUpdateAction!]!

    """Create/modify entity as an associate in business-unit."""
    asAssociate: AsAssociateArgument

    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
    version: Long!
  ): QuoteRequest
  updateReview(
    actions: [ReviewUpdateAction!]!

    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
    version: Long!
  ): Review
  updateShippingMethod(
    actions: [ShippingMethodUpdateAction!]!

    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
    version: Long!
  ): ShippingMethod
  updateShoppingList(
    actions: [ShoppingListUpdateAction!]!

    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String

    """
    The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions.
    """
    storeKey: KeyReferenceInput
    version: Long!
  ): ShoppingList
  updateStagedQuote(
    actions: [StagedQuoteUpdateAction!]!

    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
    version: Long!
  ): StagedQuote
  updateStandalonePrice(
    actions: [StandalonePriceUpdateAction!]!

    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
    version: Long!
  ): StandalonePrice
  updateState(
    actions: [StateUpdateAction!]!

    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
    version: Long!
  ): State
  updateStore(
    actions: [StoreUpdateAction!]!

    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
    version: Long!
  ): Store
  updateSubscription(
    actions: [SubscriptionUpdateAction!]!

    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
    version: Long!
  ): CommercetoolsSubscription
  updateTaxCategory(
    actions: [TaxCategoryUpdateAction!]!

    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
    version: Long!
  ): TaxCategory
  updateTypeDefinition(
    actions: [TypeUpdateAction!]!

    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
    version: Long!
  ): TypeDefinition
  updateZone(
    actions: [ZoneUpdateAction!]!

    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
    version: Long!
  ): Zone
}

"""
BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta
"""
input MyBusinessUnitDraft {
  addresses: [AddressInput!]

  """
  The indices of the billing addresses in the `addresses` list. The `billingAddressIds` of the customer will be set to the IDs of that addresses.
  """
  billingAddresses: [Int!] = []
  contactEmail: String
  custom: CustomFieldsDraft

  """
  The index of the address in the `addresses` list. The `defaultBillingAddressId` of the customer will be set to the ID of that address.
  """
  defaultBillingAddress: Int

  """
  The index of the address in the `addresses` list. The `defaultShippingAddressId` of the customer will be set to the ID of that address.
  """
  defaultShippingAddress: Int
  key: String!
  name: String!
  parentUnit: ResourceIdentifierInput

  """
  The indices of the shipping addresses in the `addresses` list. The `shippingAddressIds` of the `Customer` will be set to the IDs of that addresses.
  """
  shippingAddresses: [Int!] = []
  storeMode: String
  unitType: BusinessUnitType!
}

"""
BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta
"""
input MyBusinessUnitUpdateAction {
  addAddress: AddMyBusinessUnitAddress
  addBillingAddressId: AddMyBusinessUnitBillingAddressId
  addShippingAddressId: AddMyBusinessUnitShippingAddressId
  changeAddress: ChangeMyBusinessUnitAddress
  changeAssociate: ChangeMyBusinessUnitAssociate
  changeName: ChangeMyBusinessUnitName
  changeParentUnit: ChangeMyBusinessUnitParentUnit
  removeAddress: RemoveMyBusinessUnitAddress
  removeAssociate: RemoveMyBusinessUnitAssociate
  removeBillingAddressId: RemoveMyBusinessUnitBillingAddressId
  removeShippingAddressId: RemoveMyBusinessUnitShippingAddressId
  setAddressCustomField: SetMyBusinessUnitAddressCustomField
  setAddressCustomType: SetMyBusinessUnitAddressCustomType
  setContactEmail: SetMyBusinessUnitContactEmail
  setCustomField: SetMyBusinessUnitCustomField
  setCustomType: SetMyBusinessUnitCustomType
  setDefaultBillingAddress: SetMyBusinessUnitDefaultBillingAddress
  setDefaultShippingAddress: SetMyBusinessUnitDefaultShippingAddress
}

input MyCartDraft {
  billingAddress: AddressInput
  businessUnit: ResourceIdentifierInput
  country: Country
  currency: Currency!
  custom: CustomFieldsDraft
  customShipping: [CustomShippingDraft!] = []
  customerEmail: String
  deleteDaysAfterLastModification: Int
  discountCodes: [String!] = []
  inventoryMode: InventoryMode = None
  itemShippingAddresses: [AddressInput!] = []
  lineItems: [MyLineItemDraft!] = []
  locale: Locale
  shipping: [ShippingDraft!] = []
  shippingAddress: AddressInput
  shippingMethod: ResourceIdentifierInput
  shippingMode: ShippingMode = Single
  store: ResourceIdentifierInput
  taxMode: TaxMode = Platform
}

input MyCartUpdateAction {
  addDiscountCode: AddCartDiscountCode
  addItemShippingAddress: AddCartItemShippingAddress
  addLineItem: AddMyCartLineItem
  addPayment: AddCartPayment
  addShoppingList: AddCartShoppingList
  applyDeltaToLineItemShippingDetailsTargets: ApplyCartDeltaToLineItemShippingDetailsTargets
  changeLineItemQuantity: ChangeCartLineItemQuantity
  changeTaxMode: ChangeMyCartTaxMode
  recalculate: RecalculateCart
  removeDiscountCode: RemoveCartDiscountCode
  removeItemShippingAddress: RemoveCartItemShippingAddress
  removeLineItem: RemoveCartLineItem
  removePayment: RemoveCartPayment
  setBillingAddress: SetCartBillingAddress
  setBillingAddressCustomField: SetCartBillingAddressCustomField
  setBillingAddressCustomType: SetCartBillingAddressCustomType
  setBusinessUnit: SetCartBusinessUnit
  setCountry: SetCartCountry
  setCustomField: SetCartCustomField
  setCustomType: SetCartCustomType
  setCustomerEmail: SetCartCustomerEmail
  setDeleteDaysAfterLastModification: SetCartDeleteDaysAfterLastModification
  setItemShippingAddressCustomField: SetCartItemShippingAddressCustomField
  setItemShippingAddressCustomType: SetCartItemShippingAddressCustomType
  setLineItemCustomField: SetCartLineItemCustomField
  setLineItemCustomType: SetCartLineItemCustomType
  setLineItemDistributionChannel: SetCartLineItemDistributionChannel
  setLineItemShippingDetails: SetCartLineItemShippingDetails
  setLineItemSupplyChannel: SetCartLineItemSupplyChannel
  setLocale: SetCartLocale
  setShippingAddress: SetCartShippingAddress
  setShippingAddressCustomField: SetCartShippingAddressCustomField
  setShippingAddressCustomType: SetCartShippingAddressCustomType
  setShippingCustomField: SetCartShippingCustomField
  setShippingCustomType: SetCartShippingCustomType
  setShippingMethod: SetMyCartShippingMethod
  updateItemShippingAddress: UpdateCartItemShippingAddress
}

input MyCustomerUpdateAction {
  addAddress: AddCustomerAddress
  addBillingAddressId: AddCustomerBillingAddressId
  addShippingAddressId: AddCustomerShippingAddressId
  changeAddress: ChangeCustomerAddress
  changeEmail: ChangeCustomerEmail
  removeAddress: RemoveCustomerAddress
  removeBillingAddressId: RemoveCustomerBillingAddressId
  removeShippingAddressId: RemoveCustomerShippingAddressId
  setAddressCustomField: SetCustomerAddressCustomField
  setAddressCustomType: SetCustomerAddressCustomType
  setCompanyName: SetCustomerCompanyName
  setCustomField: SetCustomerCustomField
  setCustomType: SetCustomerCustomType
  setDateOfBirth: SetCustomerDateOfBirth
  setDefaultBillingAddress: SetCustomerDefaultBillingAddress
  setDefaultShippingAddress: SetCustomerDefaultShippingAddress
  setFirstName: SetCustomerFirstName
  setLastName: SetCustomerLastName
  setLocale: SetCustomerLocale
  setMiddleName: SetCustomerMiddleName
  setSalutation: SetCustomerSalutation
  setTitle: SetCustomerTitle
  setVatId: SetCustomerVatId
}

input MyLineItemDraft {
  addedAt: DateTime
  custom: CustomFieldsDraft
  distributionChannel: ResourceIdentifierInput
  key: String
  productId: String
  quantity: Long
  shippingDetails: ItemShippingDetailsDraft
  sku: String
  supplyChannel: ResourceIdentifierInput
  variantId: Int
}

"""
My Payments endpoint provides access to payments scoped to a specific user.
[documentation](https://docs.commercetools.com/api/projects/me-payments#mypayment)
"""
type MyPayment {
  amountPlanned: Money!
  anonymousId: String
  custom: CustomFieldsType
  customer: Customer
  customerRef: Reference
  id: String!
  paymentMethodInfo: PaymentMethodInfo!
  transactions: [Transaction!]!
  version: Long!
}

input MyPaymentDraft {
  amountPlanned: MoneyInput!
  custom: CustomFieldsDraft
  paymentMethodInfo: PaymentMethodInfoInput
  transaction: MyTransactionDraft
}

type MyPaymentQueryResult {
  count: Int!
  exists: Boolean!
  offset: Int!
  results: [MyPayment!]!
  total: Long!
}

input MyPaymentUpdateAction {
  addTransaction: AddMyPaymentTransaction
  changeAmountPlanned: ChangePaymentAmountPlanned
  setCustomField: SetPaymentCustomField
  setMethodInfoInterface: SetPaymentMethodInfoInterface
  setMethodInfoMethod: SetPaymentMethodInfoMethod
  setMethodInfoName: SetPaymentMethodInfoName
}

input MyQuoteRequestDraft {
  cartId: String!
  cartVersion: Long!
  comment: String
}

input MyQuoteRequestUpdateAction {
  cancelQuoteRequest: CancelQuoteRequest
  setCustomField: SetMyQuoteRequestCustomField
  setCustomType: SetMyQuoteRequestCustomType
}

enum MyQuoteState {
  Accepted
  Declined
}

input MyQuoteUpdateAction {
  changeMyQuoteState: ChangeMyQuoteMyQuoteState
  requestQuoteRenegotiation: RequestQuoteRenegotiation
  setCustomField: SetQuoteCustomField
  setCustomType: SetQuoteCustomType
}

input MyShoppingListDraft {
  custom: CustomFieldsDraft
  deleteDaysAfterLastModification: Int
  description: [LocalizedStringItemInputType!]
  lineItems: [ShoppingListLineItemDraft!] = []
  name: [LocalizedStringItemInputType!]!
  textLineItems: [TextLineItemDraft!] = []
}

input MyShoppingListUpdateAction {
  addLineItem: AddShoppingListLineItem
  addTextLineItem: AddShoppingListTextLineItem
  changeLineItemQuantity: ChangeShoppingListLineItemQuantity
  changeLineItemsOrder: ChangeShoppingListLineItemsOrder
  changeName: ChangeShoppingListName
  changeTextLineItemName: ChangeShoppingListTextLineItemName
  changeTextLineItemQuantity: ChangeShoppingListTextLineItemQuantity
  changeTextLineItemsOrder: ChangeShoppingListTextLineItemsOrder
  removeLineItem: RemoveShoppingListLineItem
  removeTextLineItem: RemoveShoppingListTextLineItem
  setCustomField: SetShoppingListCustomField
  setCustomType: SetShoppingListCustomType
  setDeleteDaysAfterLastModification: SetShoppingListDeleteDaysAfterLastModification
  setDescription: SetShoppingListDescription
  setLineItemCustomField: SetShoppingListLineItemCustomField
  setLineItemCustomType: SetShoppingListLineItemCustomType
  setStore: SetShoppingListStore
  setTextLineItemCustomField: SetShoppingListTextLineItemCustomField
  setTextLineItemCustomType: SetShoppingListTextLineItemCustomType
  setTextLineItemDescription: SetShoppingListTextLineItemDescription
}

input MyTransactionDraft {
  amount: MoneyInput!
  custom: CustomFieldsDraft
  interactionId: String
  timestamp: DateTime
  type: TransactionType!
}

type NestedAttributeDefinitionType implements AttributeDefinitionType {
  name: String!
  typeRef: Reference!
}

type NotProcessed implements OrderEditResult {
  type: String!
}

interface NotificationFormat {
  type: String!
}

type NumberAttribute implements Attribute {
  name: String!
  value: BigDecimal!
}

type NumberAttributeDefinitionType implements AttributeDefinitionType {
  name: String!
}

type NumberField implements CustomField {
  name: String!
  value: BigDecimal!
}

type NumberType implements FieldType {
  name: String!
}

"""
An order can be created from a cart, usually after a checkout process has been completed.
[documentation](https://docs.commercetools.com/api/projects/orders)
"""
type Order implements ReferenceExpandable & Versioned {
  anonymousId: String
  billingAddress: Address
  businessUnit: BusinessUnit
  businessUnitRef: KeyReference
  cart: Cart
  cartRef: Reference
  completedAt: DateTime
  country: Country
  createdAt: DateTime!
  createdBy: Initiator
  custom: CustomFieldsType
  customLineItems: [CustomLineItem!]!
  customer: Customer
  customerEmail: String
  customerGroup: CustomerGroup
  customerGroupRef: Reference
  customerId: String
  directDiscounts: [DirectDiscount!]!
  discountCodes: [DiscountCodeInfo!]!
  discountOnTotalPrice: DiscountOnTotalPrice
  id: String!
  inventoryMode: InventoryMode!
  itemShippingAddresses: [Address!]!
  lastMessageSequenceNumber: Long! @deprecated(reason: "An internal field that should not be used in customer logic")
  lastModifiedAt: DateTime!
  lastModifiedBy: Initiator
  lineItems(
    """Queries with specified ID"""
    id: String
  ): [LineItem!]!
  locale: Locale
  orderNumber: String
  orderState: OrderState!
  origin: CartOrigin!
  paymentInfo: PaymentInfo
  paymentState: PaymentState
  purchaseOrderNumber: String
  quote: Quote
  quoteRef: Reference
  refusedGifts: [CartDiscount!]!
  refusedGiftsRefs: [Reference!]!
  returnInfo: [ReturnInfo!]!
  shipmentState: ShipmentState
  shipping: [Shipping!]!
  shippingAddress: Address
  shippingCustomFields: CustomFieldsType
  shippingInfo: ShippingInfo
  shippingKey: String
  shippingMode: ShippingMode!
  shippingRateInput: ShippingRateInput
  state: State
  stateRef: Reference
  store: Store
  storeRef: KeyReference
  syncInfo: [SyncInfo!]!
  taxCalculationMode: TaxCalculationMode!
  taxMode: TaxMode!
  taxRoundingMode: RoundingMode!
  taxedPrice: TaxedPrice
  taxedShippingPrice: TaxedPrice
  totalPrice: Money!
  version: Long!
}

type OrderBillingAddressSet implements MessagePayload & OrderMessagePayload {
  address: Address
  oldAddress: Address
  type: String!
}

input OrderCartCommand {
  cart: ResourceIdentifierInput
  custom: CustomFieldsDraft
  id: String
  orderNumber: String
  orderState: OrderState
  paymentState: PaymentState
  purchaseOrderNumber: String
  shipmentState: ShipmentState
  state: ResourceIdentifierInput
  version: Long!
}

type OrderCreated implements MessagePayload & OrderMessagePayload {
  order: Order!
  type: String!
}

type OrderCustomFieldAdded implements MessagePayload & OrderMessagePayload {
  name: String!
  type: String!
  value: Json!
}

type OrderCustomFieldChanged implements MessagePayload & OrderMessagePayload {
  name: String!
  previousValue: Json
  type: String!
  value: Json!
}

type OrderCustomFieldRemoved implements MessagePayload & OrderMessagePayload {
  name: String!
  type: String!
}

type OrderCustomLineItemAdded implements MessagePayload & OrderMessagePayload {
  customLineItem: CustomLineItem!
  type: String!
}

type OrderCustomLineItemDiscountSet implements MessagePayload & OrderMessagePayload {
  customLineItemId: String!
  customLineItemKey: String
  discountedPricePerQuantity: [DiscountedLineItemPriceForQuantity!]!
  taxedPrice: TaxedItemPrice
  type: String!
}

type OrderCustomLineItemQuantityChanged implements MessagePayload & OrderMessagePayload {
  customLineItemId: String!
  customLineItemKey: String
  oldQuantity: Long
  quantity: Long!
  type: String!
}

type OrderCustomLineItemRemoved implements MessagePayload & OrderMessagePayload {
  customLineItem: CustomLineItem
  customLineItemId: String!
  customLineItemKey: String
  type: String!
}

type OrderCustomTypeRemoved implements MessagePayload & OrderMessagePayload {
  previousTypeId: String
  type: String!
}

type OrderCustomTypeSet implements MessagePayload & OrderMessagePayload {
  customFields: CustomFieldsType!
  previousTypeId: String
  type: String!
}

type OrderCustomerEmailSet implements MessagePayload & OrderMessagePayload {
  email: String
  oldEmail: String
  type: String!
}

type OrderCustomerGroupSet implements MessagePayload & OrderMessagePayload {
  customerGroup: CustomerGroup
  customerGroupRef: Reference
  oldCustomerGroup: CustomerGroup
  oldCustomerGroupRef: Reference
  type: String!
}

type OrderCustomerSet implements MessagePayload & OrderMessagePayload {
  customer: Customer
  customerGroup: CustomerGroup
  customerGroupRef: Reference
  customerRef: Reference
  oldCustomer: Customer
  oldCustomerGroup: CustomerGroup
  oldCustomerGroupRef: Reference
  oldCustomerRef: Reference
  type: String!
}

type OrderDeleted implements MessagePayload & OrderMessagePayload {
  order: Order
  type: String!
}

type OrderDiscountCodeAdded implements MessagePayload & OrderMessagePayload {
  discountCode: DiscountCode
  discountCodeRef: Reference!
  type: String!
}

type OrderDiscountCodeRemoved implements MessagePayload & OrderMessagePayload {
  discountCode: DiscountCode
  discountCodeRef: Reference!
  type: String!
}

type OrderDiscountCodeStateSet implements MessagePayload & OrderMessagePayload {
  discountCode: DiscountCode
  discountCodeRef: Reference!
  oldState: DiscountCodeState
  state: DiscountCodeState!
  type: String!
}

type OrderEdit implements Versioned {
  comment: String
  createdAt: DateTime!
  createdBy: Initiator
  custom: CustomFieldsType
  id: String!
  key: String
  lastModifiedAt: DateTime!
  lastModifiedBy: Initiator
  resource: Order
  resourceRef: Reference!
  result: OrderEditResult!
  stagedActions: [StagedOrderUpdateActionOutput!]!
  version: Long!
}

type OrderEditApplied implements MessagePayload & OrderMessagePayload {
  edit: OrderEdit
  editRef: Reference!
  result: Applied!
  type: String!
}

input OrderEditDraft {
  comment: String
  custom: CustomFieldsDraft
  dryRun: Boolean
  key: String
  resource: ReferenceInput!
  stagedActions: [StagedOrderUpdateAction!]!
}

type OrderEditLimitWithCurrent implements LimitWithCurrent {
  current: Long!
  limit: Long
}

type OrderEditLimitsProjection {
  total: OrderEditLimitWithCurrent!
}

type OrderEditQueryResult {
  count: Int!
  exists: Boolean!
  offset: Int!
  results: [OrderEdit!]!
  total: Long!
}

interface OrderEditResult {
  type: String!
}

input OrderEditUpdateAction {
  addStagedAction: AddOrderEditStagedAction
  setComment: SetOrderEditComment
  setCustomField: SetOrderEditCustomField
  setCustomType: SetOrderEditCustomType
  setKey: SetOrderEditKey
  setStagedActions: SetOrderEditStagedActions
}

type OrderExcerpt {
  taxedPrice: TaxedPrice
  totalPrice: Money!
  version: Long
}

type OrderImported implements MessagePayload & OrderMessagePayload {
  order: Order!
  type: String!
}

type OrderLineItemAdded implements MessagePayload & OrderMessagePayload {
  addedQuantity: Long!
  lineItem: LineItem!
  type: String!
}

type OrderLineItemDiscountSet implements MessagePayload & OrderMessagePayload {
  discountedPricePerQuantity: [DiscountedLineItemPriceForQuantity!]!
  lineItemId: String!
  lineItemKey: String
  taxedPrice: TaxedItemPrice
  taxedPricePortions: [MethodTaxedPrice!]!
  totalPrice: Money!
  type: String!
}

type OrderLineItemDistributionChannelSet implements MessagePayload & OrderMessagePayload {
  distributionChannel: Channel
  distributionChannelRef: Reference
  lineItemId: String!
  lineItemKey: String
  type: String!
}

type OrderLineItemRemoved implements MessagePayload & OrderMessagePayload {
  lineItemId: String!
  lineItemKey: String
  newPrice: ProductPrice
  newQuantity: Long!
  newShippingDetails: ItemShippingDetails
  newState: Set!
  newTaxedPrice: TaxedItemPrice
  newTotalPrice: Money!
  removedQuantity: Long!
  type: String!
}

interface OrderMessagePayload {
  type: String!
}

input OrderMyCartCommand {
  id: String!
  version: Long!
}

input OrderMyQuoteCommand {
  id: String!
  quoteStateToAccepted: Boolean = false
  version: Long!
}

type OrderPaymentAdded implements MessagePayload & OrderMessagePayload {
  paymentRef: Reference!
  type: String!
}

type OrderPaymentRemoved implements MessagePayload & OrderMessagePayload {
  paymentRef: Reference!
  removedPaymentInfo: Boolean!
  type: String!
}

type OrderPaymentStateChanged implements MessagePayload & OrderMessagePayload {
  oldPaymentState: PaymentState
  paymentState: PaymentState!
  type: String!
}

"""
Fields to access orders. Includes direct access to a single order and searching for orders.
"""
interface OrderQueryInterface {
  order(
    """Queries with specified ID"""
    id: String
    orderNumber: String
  ): Order
  orders(limit: Int, offset: Int, sort: [String!], where: String): OrderQueryResult!
}

type OrderQueryResult {
  count: Int!
  exists: Boolean!
  offset: Int!
  results: [Order!]!
  total: Long!
}

input OrderQuoteCommand {
  custom: CustomFieldsDraft
  orderNumber: String
  orderState: OrderState
  paymentState: PaymentState
  quote: ResourceIdentifierInput
  quoteStateToAccepted: Boolean = false
  shipmentState: ShipmentState
  state: ResourceIdentifierInput
  version: Long!
}

type OrderReturnShipmentStateChanged implements MessagePayload & OrderMessagePayload {
  returnItemId: String!
  returnShipmentState: ReturnShipmentState!
  type: String!
}

type OrderSearchConfiguration {
  lastModifiedAt: DateTime!
  lastModifiedBy: Initiator
  status: OrderSearchStatus!
}

enum OrderSearchStatus {
  Activated
  Deactivated
}

type OrderShipmentStateChanged implements MessagePayload & OrderMessagePayload {
  oldShipmentState: ShipmentState
  shipmentState: ShipmentState!
  type: String!
}

type OrderShippingAddressSet implements MessagePayload & OrderMessagePayload {
  address: Address
  oldAddress: Address
  type: String!
}

type OrderShippingInfoSet implements MessagePayload & OrderMessagePayload {
  oldShippingInfo: ShippingInfo
  shippingInfo: ShippingInfo
  type: String!
}

type OrderShippingRateInputSet implements MessagePayload & OrderMessagePayload {
  oldShippingRateInput: ShippingRateInput
  shippingRateInput: ShippingRateInput
  type: String!
}

enum OrderState {
  Cancelled
  Complete
  Confirmed
  Open
}

type OrderStateChanged implements MessagePayload & OrderMessagePayload {
  oldOrderState: OrderState
  orderId: String!
  orderState: OrderState!
  type: String!
}

type OrderStateTransition implements MessagePayload & OrderMessagePayload {
  force: Boolean!
  oldState: State
  oldStateRef: Reference
  state: State
  stateRef: Reference!
  type: String!
}

type OrderStoreSet implements MessagePayload & OrderMessagePayload {
  oldStore: Store
  oldStoreRef: KeyReference
  store: Store
  storeRef: KeyReference
  type: String!
}

input OrderUpdateAction {
  addDelivery: AddOrderDelivery
  addItemShippingAddress: AddOrderItemShippingAddress
  addParcelToDelivery: AddOrderParcelToDelivery
  addPayment: AddOrderPayment
  addReturnInfo: AddOrderReturnInfo
  changeOrderState: ChangeOrderState
  changePaymentState: ChangeOrderPaymentState
  changeShipmentState: ChangeOrderShipmentState
  importCustomLineItemState: ImportOrderCustomLineItemState
  importLineItemState: ImportOrderLineItemState
  removeDelivery: RemoveOrderDelivery
  removeItemShippingAddress: RemoveOrderItemShippingAddress
  removeParcelFromDelivery: RemoveOrderParcelFromDelivery
  removePayment: RemoveOrderPayment
  setBillingAddress: SetOrderBillingAddress
  setBillingAddressCustomField: SetOrderBillingAddressCustomField
  setBillingAddressCustomType: SetOrderBillingAddressCustomType
  setCustomField: SetOrderCustomField
  setCustomLineItemCustomField: SetOrderCustomLineItemCustomField
  setCustomLineItemCustomType: SetOrderCustomLineItemCustomType
  setCustomLineItemShippingDetails: SetOrderCustomLineItemShippingDetails
  setCustomType: SetOrderCustomType
  setCustomerEmail: SetOrderCustomerEmail
  setCustomerId: SetOrderCustomerId
  setDeliveryAddress: SetOrderDeliveryAddress
  setDeliveryAddressCustomField: SetOrderDeliveryAddressCustomField
  setDeliveryAddressCustomType: SetOrderDeliveryAddressCustomType
  setDeliveryCustomField: SetOrderDeliveryCustomField
  setDeliveryCustomType: SetOrderDeliveryCustomType
  setDeliveryItems: SetOrderDeliveryItems
  setItemShippingAddressCustomField: SetOrderItemShippingAddressCustomField
  setItemShippingAddressCustomType: SetOrderItemShippingAddressCustomType
  setLineItemCustomField: SetOrderLineItemCustomField
  setLineItemCustomType: SetOrderLineItemCustomType
  setLineItemShippingDetails: SetOrderLineItemShippingDetails
  setLocale: SetOrderLocale
  setOrderNumber: SetOrderNumber
  setParcelCustomField: SetOrderParcelCustomField
  setParcelCustomType: SetOrderParcelCustomType
  setParcelItems: SetOrderParcelItems
  setParcelMeasurements: SetOrderParcelMeasurements
  setParcelTrackingData: SetOrderParcelTrackingData
  setPurchaseOrderNumber: SetOrderPurchaseOrderNumber
  setReturnInfo: SetOrderReturnInfo
  setReturnItemCustomField: SetOrderReturnItemCustomField
  setReturnItemCustomType: SetOrderReturnItemCustomType
  setReturnPaymentState: SetOrderReturnPaymentState
  setReturnShipmentState: SetOrderReturnShipmentState
  setShippingAddress: SetOrderShippingAddress
  setShippingAddressCustomField: SetOrderShippingAddressCustomField
  setShippingAddressCustomType: SetOrderShippingAddressCustomType
  setShippingCustomField: SetOrderShippingCustomField
  setShippingCustomType: SetOrderShippingCustomType
  setStore: SetOrderStore
  transitionCustomLineItemState: TransitionOrderCustomLineItemState
  transitionLineItemState: TransitionOrderLineItemState
  transitionState: TransitionOrderState
  updateItemShippingAddress: UpdateOrderItemShippingAddress
  updateSyncInfo: UpdateOrderSyncInfo
}

type Parcel {
  createdAt: DateTime!
  custom: CustomFieldsType
  id: String!
  items: [DeliveryItem!]!
  key: String
  measurements: ParcelMeasurements
  trackingData: TrackingData
}

type ParcelAddedToDelivery implements MessagePayload & OrderMessagePayload {
  delivery: Delivery!
  parcel: Parcel!
  shippingKey: String
  type: String!
}

type ParcelData {
  custom: CustomFieldsCommand
  items: [DeliveryItem!]!
  key: String
  measurements: ParcelMeasurements
  trackingData: TrackingData
}

input ParcelDataDraftType {
  custom: CustomFieldsDraft
  items: [DeliveryItemDraftType!] = []
  key: String
  measurements: ParcelMeasurementsDraftType
  trackingData: TrackingDataDraftType
}

input ParcelDraft {
  createdAt: DateTime!
  custom: CustomFieldsDraft
  id: String!
  items: [DeliveryItemDraftType!] = []
  key: String
  measurements: ParcelMeasurementsDraftType
  trackingData: TrackingDataDraftType
}

type ParcelItemsUpdated implements MessagePayload & OrderMessagePayload {
  deliveryId: String!
  items: [DeliveryItem!]!
  oldItems: [DeliveryItem!]!
  parcelId: String!
  shippingKey: String
  type: String!
}

type ParcelMeasurements {
  heightInMillimeter: Int
  lengthInMillimeter: Int
  weightInGram: Int
  widthInMillimeter: Int
}

input ParcelMeasurementsDraftType {
  heightInMillimeter: Int
  lengthInMillimeter: Int
  weightInGram: Int
  widthInMillimeter: Int
}

type ParcelMeasurementsUpdated implements MessagePayload & OrderMessagePayload {
  deliveryId: String!
  measurements: ParcelMeasurements
  parcelId: String!
  shippingKey: String
  type: String!
}

type ParcelRemovedFromDelivery implements MessagePayload & OrderMessagePayload {
  deliveryId: String!
  parcel: Parcel!
  shippingKey: String
  type: String!
}

type ParcelTrackingDataUpdated implements MessagePayload & OrderMessagePayload {
  deliveryId: String!
  parcelId: String!
  shippingKey: String
  trackingData: TrackingData
  type: String!
}

"""
Payments hold information about the current state of receiving and/or refunding money.
[documentation](https://docs.commercetools.com/api/projects/payments)
"""
type Payment implements Versioned {
  amountPlanned: Money!
  anonymousId: String
  createdAt: DateTime!
  createdBy: Initiator
  custom: CustomFieldsType
  customer: Customer
  customerRef: Reference
  id: String!
  interfaceId: String
  interfaceInteractionsRaw(limit: Int, offset: Int): InterfaceInteractionsRawResult!
  key: String
  lastModifiedAt: DateTime!
  lastModifiedBy: Initiator
  paymentMethodInfo: PaymentMethodInfo!
  paymentStatus: PaymentStatus!
  transactions: [Transaction!]!
  version: Long!
}

type PaymentCreated implements MessagePayload {
  payment: Payment!
  type: String!
}

input PaymentDraft {
  amountPlanned: MoneyInput!
  anonymousId: String
  custom: CustomFieldsDraft
  customer: ResourceIdentifierInput
  interfaceId: String
  interfaceInteractions: [CustomFieldsDraft!]
  key: String
  paymentMethodInfo: PaymentMethodInfoInput
  paymentStatus: PaymentStatusInput
  transactions: [TransactionDraft!]
}

type PaymentInfo {
  paymentRefs: [Reference!]!
  payments: [Payment!]!
}

type PaymentInteractionAdded implements MessagePayload {
  interaction: CustomFieldsType!
  type: String!
}

type PaymentMethodInfo {
  method: String
  name(
    """
    List of languages the client is able to understand, and which locale variant is preferred.
    """
    acceptLanguage: [Locale!]

    """
    String is defined for different locales. This argument specifies the desired locale.
    """
    locale: Locale
  ): String
  nameAllLocales: [LocalizedString!]
  paymentInterface: String
}

input PaymentMethodInfoInput {
  method: String
  name: [LocalizedStringItemInputType!]
  paymentInterface: String
}

type PaymentQueryResult {
  count: Int!
  exists: Boolean!
  offset: Int!
  results: [Payment!]!
  total: Long!
}

enum PaymentState {
  BalanceDue
  CreditOwed
  Failed
  Paid
  Pending
}

type PaymentStatus {
  interfaceCode: String
  interfaceText: String
  state: State
  stateRef: Reference
}

input PaymentStatusInput {
  interfaceCode: String
  interfaceText: String
  state: ResourceIdentifierInput
}

type PaymentStatusInterfaceCodeSet implements MessagePayload {
  interfaceCode: String
  paymentId: String!
  type: String!
}

type PaymentStatusStateTransition implements MessagePayload {
  force: Boolean!
  state: State
  stateRef: Reference
  type: String!
}

type PaymentTransactionAdded implements MessagePayload {
  transaction: Transaction!
  type: String!
}

type PaymentTransactionStateChanged implements MessagePayload {
  state: TransactionState!
  transactionId: String!
  type: String!
}

input PaymentUpdateAction {
  addInterfaceInteraction: AddPaymentInterfaceInteraction
  addTransaction: AddPaymentTransaction
  changeAmountPlanned: ChangePaymentAmountPlanned
  changeTransactionInteractionId: ChangePaymentTransactionInteractionId
  changeTransactionState: ChangePaymentTransactionState
  changeTransactionTimestamp: ChangePaymentTransactionTimestamp
  setAmountPaid: SetPaymentAmountPaid
  setAmountRefunded: SetPaymentAmountRefunded
  setAnonymousId: SetPaymentAnonymousId
  setAuthorization: SetPaymentAuthorization
  setCustomField: SetPaymentCustomField
  setCustomType: SetPaymentCustomType
  setCustomer: SetPaymentCustomer
  setExternalId: SetPaymentExternalId
  setInterfaceId: SetPaymentInterfaceId
  setKey: SetPaymentKey
  setMethodInfoInterface: SetPaymentMethodInfoInterface
  setMethodInfoMethod: SetPaymentMethodInfoMethod
  setMethodInfoName: SetPaymentMethodInfoName
  setStatusInterfaceCode: SetPaymentStatusInterfaceCode
  setStatusInterfaceText: SetPaymentStatusInterfaceText
  setTransactionCustomField: SetPaymentTransactionCustomField
  setTransactionCustomType: SetPaymentTransactionCustomType
  transitionState: TransitionPaymentState
}

enum Permission {
  AcceptMyQuotes
  AcceptOthersQuotes
  AddChildUnits
  CreateApprovalRules
  CreateMyCarts
  CreateMyOrdersFromMyCarts
  CreateMyOrdersFromMyQuotes
  CreateMyQuoteRequestsFromMyCarts
  CreateOrdersFromOthersCarts
  CreateOrdersFromOthersQuotes
  CreateOthersCarts
  CreateQuoteRequestsFromOthersCarts
  DeclineMyQuotes
  DeclineOthersQuotes
  DeleteMyCarts
  DeleteOthersCarts
  ReassignMyQuotes
  ReassignOthersQuotes
  RenegotiateMyQuotes
  RenegotiateOthersQuotes
  UpdateApprovalFlows
  UpdateApprovalRules
  UpdateAssociates
  UpdateBusinessUnitDetails
  UpdateMyCarts
  UpdateMyOrders
  UpdateMyQuoteRequests
  UpdateOthersCarts
  UpdateOthersOrders
  UpdateOthersQuoteRequests
  UpdateParentUnit
  ViewMyCarts
  ViewMyOrders
  ViewMyQuoteRequests
  ViewMyQuotes
  ViewOthersCarts
  ViewOthersOrders
  ViewOthersQuoteRequests
  ViewOthersQuotes
}

type PlainEnumValue {
  key: String!
  label: String!
}

input PlainEnumValueDraft {
  key: String!
  label: String!
}

type PlainEnumValueResult {
  limit: Int
  offset: Int
  results: [PlainEnumValue!]!
  total: Int!
}

type PlatformFormat implements NotificationFormat {
  type: String!
}

input PlatformFormatInput {
  dummy: String
}

type Point implements Geometry {
  coordinates: [Float!]!
  type: String!
}

type PreviewFailure implements OrderEditResult {
  errors: [Json!]!
  type: String!
}

type PreviewSuccess implements OrderEditResult {
  messagePayloads: [OrderMessagePayload!]!
  preview: Order!
  type: String!
}

type PriceFunction {
  currencyCode: Currency!
  function: String!
}

input PriceFunctionDraft {
  currencyCode: Currency!
  function: String!
}

"""
This mode determines which type of Prices the system uses for
Product Price Selection as well as for LineItem Price selection
"""
enum PriceMode {
  """
  The system looks up prices from the `prices` field of the ProductVariant inside a Product.
  """
  Embedded

  """
  The system looks up prices from Standalone Prices, stored separately from Products.
  """
  Standalone
}

input PriceSelectorInput {
  channel: ReferenceInput
  country: Country
  currency: Currency!
  customerGroup: ReferenceInput
  date: DateTime
}

type Product implements ReferenceExpandable & ReviewTarget & Versioned {
  createdAt: DateTime!
  createdBy: Initiator
  id: String!
  key: String
  lastModifiedAt: DateTime!
  lastModifiedBy: Initiator
  masterData: ProductCatalogData!
  priceMode: PriceMode
  productSelectionRefs(limit: Int, offset: Int, sort: [String!], where: String): SelectionOfProductQueryResult!
  productType: ProductTypeDefinition
  productTypeRef: Reference!
  reviewRatingStatistics: ReviewRatingStatistics
  skus: [String!]!
  state: State
  stateRef: Reference
  taxCategory: TaxCategory
  taxCategoryRef: Reference
  version: Long!
}

type ProductAddedToCategory implements MessagePayload {
  category: ReferenceId!
  staged: Boolean!
  type: String!
}

type ProductAssignment {
  product: Product
  productRef: Reference!
  productSelection: ProductSelection
  productSelectionRef: Reference!
  variantExclusion: ProductVariantExclusion
  variantSelection: ProductVariantSelection
}

type ProductAssignmentQueryResult {
  count: Int!
  exists: Boolean!
  offset: Int!
  results: [ProductAssignment!]!
  total: Long!
}

"""
An input object used to define a ProductAttribute.

The value should be passed in a form of escaped JSON.


Examples for `value`:

* FieldType `String`: `"\"This is a string\""`
* FieldType `DateTimeType`: `"\"2018-10-12T14:00:00.000Z\""`
* FieldType `Number`: `"4"`
* FieldType `Set` with an elementType of `String`: `"[\"This is a string\", \"This is another string\"]"`
* FieldType `Reference`: `"{\"id\": \"b911b62d-353a-4388-93ee-8d488d9af962\", \"typeId\": \"product\"}"`
"""
input ProductAttributeInput {
  name: String!

  """
  The value should be passed in a form of escaped JSON.
  
  
  Examples for `value`:
  
  * FieldType `String`: `"\"This is a string\""`
  * FieldType `DateTimeType`: `"\"2018-10-12T14:00:00.000Z\""`
  * FieldType `Number`: `"4"`
  * FieldType `Set` with an elementType of `String`: `"[\"This is a string\", \"This is another string\"]"`
  * FieldType `Reference`: `"{\"id\": \"b911b62d-353a-4388-93ee-8d488d9af962\", \"typeId\": \"product\"}"`
  """
  value: String!
}

type ProductCatalogData {
  current: ProductData
  hasStagedChanges: Boolean!
  published: Boolean!
  staged: ProductData
}

type ProductCreated implements MessagePayload {
  productProjection: ProductProjectionMessagePayload!
  type: String!
}

type ProductData {
  allVariants(
    hasImages: Boolean
    isOnStock: Boolean

    """Queries for products with specified SKUs"""
    skus: [String!]

    """
    The IDs of channels for which to check the stock of the `isOnStock`.
    
    Variant is returned if at least one of the channels is matching the `isOnStock`
    
    If the list is not provided then noChannel is checked for `isOnStock`
    """
    stockChannelIds: [String!]
  ): [ProductVariant!]!
  categories: [Category!]!
  categoriesRef: [Reference!]!
  categoryOrderHint(categoryId: String!): String
  categoryOrderHints: [CategoryOrderHint!]!
  description(
    """
    List of languages the client is able to understand, and which locale variant is preferred.
    """
    acceptLanguage: [Locale!]

    """
    String is defined for different locales. This argument specifies the desired locale.
    """
    locale: Locale
  ): String
  descriptionAllLocales: [LocalizedString!]
  masterVariant: ProductVariant!
  metaDescription(
    """
    List of languages the client is able to understand, and which locale variant is preferred.
    """
    acceptLanguage: [Locale!]

    """
    String is defined for different locales. This argument specifies the desired locale.
    """
    locale: Locale
  ): String
  metaDescriptionAllLocales: [LocalizedString!]
  metaKeywords(
    """
    List of languages the client is able to understand, and which locale variant is preferred.
    """
    acceptLanguage: [Locale!]

    """
    String is defined for different locales. This argument specifies the desired locale.
    """
    locale: Locale
  ): String
  metaKeywordsAllLocales: [LocalizedString!]
  metaTitle(
    """
    List of languages the client is able to understand, and which locale variant is preferred.
    """
    acceptLanguage: [Locale!]

    """
    String is defined for different locales. This argument specifies the desired locale.
    """
    locale: Locale
  ): String
  metaTitleAllLocales: [LocalizedString!]
  name(
    """
    List of languages the client is able to understand, and which locale variant is preferred.
    """
    acceptLanguage: [Locale!]

    """
    String is defined for different locales. This argument specifies the desired locale.
    """
    locale: Locale
  ): String
  nameAllLocales: [LocalizedString!]!
  searchKeyword(
    """
    String is defined for different locales. This argument specifies the desired locale.
    """
    locale: Locale!
  ): [SearchKeyword!]
  searchKeywords: [SearchKeywords!]!
  skus: [String!]!
  slug(
    """
    List of languages the client is able to understand, and which locale variant is preferred.
    """
    acceptLanguage: [Locale!]

    """
    String is defined for different locales. This argument specifies the desired locale.
    """
    locale: Locale
  ): String
  slugAllLocales: [LocalizedString!]!
  variant(
    """
    Queries for a [ProductVariant](https://docs.commercetools.com/api/projects/products#productvariant) with specified `key`
    """
    key: String

    """Queries for a variant with specified SKU"""
    sku: String
  ): ProductVariant
  variants(
    hasImages: Boolean
    isOnStock: Boolean

    """Queries for products with specified SKUs"""
    skus: [String!]

    """
    The IDs of channels for which to check the stock of the `isOnStock`.
    
    Variant is returned if at least one of the channels is matching the `isOnStock`
    
    If the list is not provided then noChannel is checked for `isOnStock`
    """
    stockChannelIds: [String!]
  ): [ProductVariant!]!
}

type ProductDeleted implements MessagePayload {
  currentProjection: ProductProjectionMessagePayload
  removedImageUrls: Set!
  type: String!
}

"\nA product price can be discounted in two ways:\n\n* with a relative or an absolute product discount, which will be automatically applied to all prices in a product that match a discount predicate.\n  A relative discount reduces the matching price by a fraction (for example 10 % off). An absolute discount reduces the matching price by a fixed amount (for example 10€ off). If more than one product discount matches a price, the discount sort order determines which one will be applied.\n* with an external product discount, which can then be used to explicitly set a discounted value on a particular product price.\n\nThe discounted price is stored in the discounted field of the Product Price.\n\nNote that when a discount is created, updated or removed it can take up to 15 minutes to update all the prices with the discounts.\n\nThe maximum number of ProductDiscounts that can be active at the same time is **200**.\n      "
type ProductDiscount implements ReferenceExpandable & Versioned {
  createdAt: DateTime!
  createdBy: Initiator
  description(
    """
    List of languages the client is able to understand, and which locale variant is preferred.
    """
    acceptLanguage: [Locale!]

    """
    String is defined for different locales. This argument specifies the desired locale.
    """
    locale: Locale
  ): String
  descriptionAllLocales: [LocalizedString!]
  id: String!
  isActive: Boolean!
  isValid: Boolean!
  key: String
  lastModifiedAt: DateTime!
  lastModifiedBy: Initiator
  name(
    """
    List of languages the client is able to understand, and which locale variant is preferred.
    """
    acceptLanguage: [Locale!]

    """
    String is defined for different locales. This argument specifies the desired locale.
    """
    locale: Locale
  ): String
  nameAllLocales: [LocalizedString!]!
  predicate: String!
  referenceRefs: [Reference!]!
  sortOrder: String!
  validFrom: DateTime
  validUntil: DateTime
  value: ProductDiscountValue!
  version: Long!
}

input ProductDiscountDraft {
  description: [LocalizedStringItemInputType!]
  isActive: Boolean = true
  key: String
  name: [LocalizedStringItemInputType!]!
  predicate: String!
  sortOrder: String!
  validFrom: DateTime
  validUntil: DateTime
  value: ProductDiscountValueInput!
}

type ProductDiscountLimitWithCurrent implements LimitWithCurrent {
  current: Long!
  limit: Long
}

type ProductDiscountLimitsProjection {
  totalActive: ProductDiscountLimitWithCurrent!
}

type ProductDiscountQueryResult {
  count: Int!
  exists: Boolean!
  offset: Int!
  results: [ProductDiscount!]!
  total: Long!
}

input ProductDiscountUpdateAction {
  changeIsActive: ChangeProductDiscountIsActive
  changeName: ChangeProductDiscountName
  changePredicate: ChangeProductDiscountPredicate
  changeSortOrder: ChangeProductDiscountSortOrder
  changeValue: ChangeProductDiscountValue
  setDescription: SetProductDiscountDescription
  setKey: SetProductDiscountKey
  setValidFrom: SetProductDiscountValidFrom
  setValidFromAndUntil: SetProductDiscountValidFromAndUntil
  setValidUntil: SetProductDiscountValidUntil
}

interface ProductDiscountValue {
  type: String!
}

input ProductDiscountValueInput {
  absolute: AbsoluteDiscountValueInput
  external: ExternalDiscountValueInput
  relative: RelativeDiscountValueInput
}

input ProductDraft {
  categories: [ResourceIdentifierInput!]
  categoryOrderHints: [CategoryOrderHintInput!]
  description: [LocalizedStringItemInputType!]
  key: String
  masterVariant: ProductVariantInput
  metaDescription: [LocalizedStringItemInputType!]
  metaKeywords: [LocalizedStringItemInputType!]
  metaTitle: [LocalizedStringItemInputType!]
  name: [LocalizedStringItemInputType!]!
  priceMode: PriceMode
  productType: ResourceIdentifierInput!
  publish: Boolean
  searchKeywords: [SearchKeywordInput!]
  slug: [LocalizedStringItemInputType!]!
  state: ResourceIdentifierInput
  taxCategory: ResourceIdentifierInput
  variants: [ProductVariantInput!] = []
}

type ProductImageAdded implements MessagePayload {
  image: Image!
  staged: Boolean!
  type: String!
  variantId: Int!
}

type ProductLimitsProjection {
  pricesPerVariant: Limit!
  productTailoring: Limit!
  variants: Limit!
}

type ProductOfSelection {
  product: Product
  productRef: Reference!
  variantExclusion: ProductVariantExclusion
  variantSelection: ProductVariantSelection
}

type ProductOfSelectionQueryResult {
  count: Int!
  exists: Boolean!
  offset: Int!
  results: [ProductOfSelection!]!
  total: Long!
}

type ProductPrice {
  channel: Channel
  channelRef: Reference
  country: Country
  custom: CustomFieldsType
  customerGroup: CustomerGroup
  customerGroupRef: Reference
  discounted: DiscountedProductPriceValue
  id: String
  key: String
  tiers: [ProductPriceTier!]
  validFrom: DateTime
  validUntil: DateTime
  value: BaseMoney!
}

type ProductPriceAdded implements MessagePayload {
  price: ProductPrice!
  staged: Boolean!
  type: String!
  variantId: Int!
}

type ProductPriceChanged implements MessagePayload {
  newPrice: ProductPrice!
  oldPrice: ProductPrice!
  oldStagedPrice: ProductPrice
  staged: Boolean!
  type: String!
  variantId: Int!
}

input ProductPriceDataInput {
  channel: ResourceIdentifierInput
  country: Country
  custom: CustomFieldsDraft
  customerGroup: ReferenceInput
  discounted: DiscountedProductPriceValueInput
  key: String
  tiers: [ProductPriceTierInput!] = []
  validFrom: DateTime
  validUntil: DateTime
  value: BaseMoneyInput!
}

type ProductPriceDiscountUpdateMessagePayload {
  discounted: DiscountedProductPriceValue
  priceId: String!
  sku: String
  staged: Boolean!
  variantId: Int!
  variantKey: String
}

type ProductPriceDiscountsSet implements MessagePayload {
  type: String!
  updatedPrices: [ProductPriceDiscountUpdateMessagePayload!]!
}

type ProductPriceExternalDiscountSet implements MessagePayload {
  discounted: DiscountedProductPriceValue
  priceId: String!
  sku: String
  staged: Boolean!
  type: String!
  variantId: Int!
  variantKey: String
}

type ProductPriceKeySet implements MessagePayload {
  key: String
  oldKey: String
  priceId: String
  staged: Boolean!
  type: String!
  variantId: Int!
}

type ProductPriceModeSet implements MessagePayload {
  to: PriceMode
  type: String!
}

type ProductPriceRemoved implements MessagePayload {
  price: ProductPrice!
  staged: Boolean!
  type: String!
  variantId: Int!
}

type ProductPriceSearch {
  channel: Channel
  channelRef: Reference
  country: Country
  custom: CustomFieldsType
  customerGroup: CustomerGroup
  customerGroupRef: Reference
  discounted: DiscountedProductSearchPriceValue
  id: String
  key: String
  tiers: [ProductSearchPriceTier!]
  validFrom: DateTime
  validUntil: DateTime
  value: BaseMoney!
}

type ProductPriceTier {
  minimumQuantity: Int!
  value: BaseMoney!
}

input ProductPriceTierInput {
  minimumQuantity: Int!
  value: BaseMoneyInput!
}

type ProductPricesSet implements MessagePayload {
  prices: [ProductPrice!]!
  staged: Boolean!
  type: String!
  variantId: Int!
}

type ProductProjection {
  categories: [Category!]!
  categoriesRef: [Reference!]!
  categoryOrderHints: [CategoryOrderHintProductSearch!]!
  createdAt: DateTime!
  description(
    """
    List of languages the client is able to understand, and which locale variant is preferred.
    """
    acceptLanguage: [Locale!]

    """
    String is defined for different locales. This argument specifies the desired locale.
    """
    locale: Locale
  ): String
  descriptionAllLocales: [LocalizedString!]
  hasStagedChanges: Boolean!
  id: String!
  key: String
  lastModifiedAt: DateTime!
  masterVariant: ProductSearchVariant!
  metaDescription(
    """
    List of languages the client is able to understand, and which locale variant is preferred.
    """
    acceptLanguage: [Locale!]

    """
    String is defined for different locales. This argument specifies the desired locale.
    """
    locale: Locale
  ): String
  metaDescriptionAllLocales: [LocalizedString!]
  metaKeywords(
    """
    List of languages the client is able to understand, and which locale variant is preferred.
    """
    acceptLanguage: [Locale!]

    """
    String is defined for different locales. This argument specifies the desired locale.
    """
    locale: Locale
  ): String
  metaKeywordsAllLocales: [LocalizedString!]
  metaTitle(
    """
    List of languages the client is able to understand, and which locale variant is preferred.
    """
    acceptLanguage: [Locale!]

    """
    String is defined for different locales. This argument specifies the desired locale.
    """
    locale: Locale
  ): String
  metaTitleAllLocales: [LocalizedString!]
  name(
    """
    List of languages the client is able to understand, and which locale variant is preferred.
    """
    acceptLanguage: [Locale!]

    """
    String is defined for different locales. This argument specifies the desired locale.
    """
    locale: Locale
  ): String
  nameAllLocales: [LocalizedString!]!
  productType: ProductTypeDefinition
  productTypeRef: Reference!
  published: Boolean!
  reviewRatingStatistics: ReviewRatingStatistics
  searchKeywords: [SearchKeywordsProductSearch!]!
  slug(
    """
    List of languages the client is able to understand, and which locale variant is preferred.
    """
    acceptLanguage: [Locale!]

    """
    String is defined for different locales. This argument specifies the desired locale.
    """
    locale: Locale
  ): String
  slugAllLocales: [LocalizedString!]!
  state: State
  stateRef: Reference
  taxCategory: TaxCategory
  taxCategoryRef: Reference
  variants: [ProductSearchVariant!]!
  version: Long!
}

type ProductProjectionMessagePayload {
  categories: [Category!]!
  categoriesRef: [Reference!]!
  categoryOrderHints: [CategoryOrderHint!]!
  createdAt: DateTime!
  description(
    """
    List of languages the client is able to understand, and which locale variant is preferred.
    """
    acceptLanguage: [Locale!]

    """
    String is defined for different locales. This argument specifies the desired locale.
    """
    locale: Locale
  ): String
  descriptionAllLocales: [LocalizedString!]
  hasStagedChanges: Boolean!
  id: String!
  lastModifiedAt: DateTime!
  masterVariant: ProductVariant!
  metaDescription(
    """
    List of languages the client is able to understand, and which locale variant is preferred.
    """
    acceptLanguage: [Locale!]

    """
    String is defined for different locales. This argument specifies the desired locale.
    """
    locale: Locale
  ): String
  metaDescriptionAllLocales: [LocalizedString!]
  metaKeywords(
    """
    List of languages the client is able to understand, and which locale variant is preferred.
    """
    acceptLanguage: [Locale!]

    """
    String is defined for different locales. This argument specifies the desired locale.
    """
    locale: Locale
  ): String
  metaKeywordsAllLocales: [LocalizedString!]
  metaTitle(
    """
    List of languages the client is able to understand, and which locale variant is preferred.
    """
    acceptLanguage: [Locale!]

    """
    String is defined for different locales. This argument specifies the desired locale.
    """
    locale: Locale
  ): String
  metaTitleAllLocales: [LocalizedString!]
  name(
    """
    List of languages the client is able to understand, and which locale variant is preferred.
    """
    acceptLanguage: [Locale!]

    """
    String is defined for different locales. This argument specifies the desired locale.
    """
    locale: Locale
  ): String
  nameAllLocales: [LocalizedString!]!
  productType: ProductTypeDefinition
  productTypeRef: Reference!
  published: Boolean!
  reviewRatingStatistics: ReviewRatingStatistics
  searchKeywords: [SearchKeywords!]!
  slug(
    """
    List of languages the client is able to understand, and which locale variant is preferred.
    """
    acceptLanguage: [Locale!]

    """
    String is defined for different locales. This argument specifies the desired locale.
    """
    locale: Locale
  ): String
  slugAllLocales: [LocalizedString!]!
  state: State
  stateRef: Reference
  taxCategory: TaxCategory
  taxCategoryRef: Reference
  variants: [ProductVariant!]!
  version: Long!
}

type ProductProjectionSearchResult {
  count: Int!
  facets: [FacetResultValue!]!
  offset: Int!
  results: [ProductProjection!]!
  total: Int!
}

type ProductPublished implements MessagePayload {
  productProjection: ProductProjectionMessagePayload!
  removedImageUrls: [String!]!
  scope: PublishScope!
  type: String!
}

type ProductQueryResult {
  count: Int!
  exists: Boolean!
  offset: Int!
  results: [Product!]!
  total: Long!
}

type ProductReferenceIdentifier {
  id: String
  key: String
  typeId: String!
}

type ProductRemovedFromCategory implements MessagePayload {
  category: ReferenceId!
  staged: Boolean!
  type: String!
}

type ProductRevertedStagedChanges implements MessagePayload {
  removedImageUrls: Set!
  type: String!
}

"""
CLOSED BETA: This feature is subject to change and should not be used in production. https://docs.commercetools.com/api/contract#closed-beta
"""
enum ProductSearchIndexingMode {
  ProductProjectionsSearch
  ProductsSearch
}

type ProductSearchPriceTier {
  minimumQuantity: Int!
  value: BaseMoney!
}

type ProductSearchVariant {
  assets: [Asset!]!

  """This field contains raw attributes data"""
  attributesRaw(
    """
    The names of the attributes to exclude.
    
    If neither `includeNames` nor `excludeNames` are provided, then all attributes are returned.
    """
    excludeNames: [String!]

    """
    The names of the attributes to include.
    
    If neither `includeNames` nor `excludeNames` are provided, then all attributes are returned.
    """
    includeNames: [String!]
  ): [RawProductSearchAttribute!]!
  availability: ProductSearchVariantAvailabilityWithChannels
  id: Int!
  images: [ImageProductSearch!]!
  isMatchingVariant: Boolean
  key: String

  """Returns a single price based on the price selection rules."""
  price(channelId: String, country: Country, currency: Currency!, customerGroupId: String, date: DateTime): ProductPriceSearch
  prices: [ProductPriceSearch!]
  scopedPrice: ScopedPrice
  scopedPriceDiscounted: Boolean
  sku: String
}

"""Product variant availabilities"""
type ProductSearchVariantAvailabilitiesResult {
  limit: Int
  offset: Int
  results: [ProductSearchVariantAvailabilityWithChannel!]!
  total: Int!
}

"""Product variant availability"""
type ProductSearchVariantAvailability {
  availableQuantity: Long
  id: String
  isOnStock: Boolean!
  restockableInDays: Int
  version: Long
}

type ProductSearchVariantAvailabilityWithChannel {
  availability: ProductSearchVariantAvailability!
  channel: Channel
  channelRef: Reference!
}

type ProductSearchVariantAvailabilityWithChannels {
  channels(
    """
    The IDs of channels to exclude.
    
    If neither `includeChannelIds` nor `excludeChannelIds` are provided, then all channels are returned.
    """
    excludeChannelIds: [String!]

    """
    The IDs of channels to include.
    
    If neither `includeChannelIds` nor `excludeChannelIds` are provided, then all channels are returned.
    """
    includeChannelIds: [String!]
    limit: Int
    offset: Int
  ): ProductSearchVariantAvailabilitiesResult!
  noChannel: ProductSearchVariantAvailability
}

type ProductSelection implements Versioned {
  createdAt: DateTime!
  createdBy: Initiator
  custom: CustomFieldsType
  id: String!
  key: String
  lastModifiedAt: DateTime!
  lastModifiedBy: Initiator
  mode: ProductSelectionMode!
  name(
    """
    List of languages the client is able to understand, and which locale variant is preferred.
    """
    acceptLanguage: [Locale!]

    """
    String is defined for different locales. This argument specifies the desired locale.
    """
    locale: Locale
  ): String
  nameAllLocales: [LocalizedString!]!
  productCount: Int!
  productRefs(limit: Int, offset: Int, sort: [String!], where: String): ProductOfSelectionQueryResult!
  version: Long!
}

type ProductSelectionCreated implements MessagePayload {
  productSelection: ProductSelection!
  type: String!
}

type ProductSelectionDeleted implements MessagePayload {
  type: String!
}

enum ProductSelectionMode {
  """
  Mode of Product Selection used to include a specific list of individual Products
  """
  Individual

  """
  Mode of Product Selection used to exclude a specific list of individual Products
  """
  IndividualExclusion
}

type ProductSelectionProductAdded implements MessagePayload {
  product: Product
  productRef: Reference!
  type: String!
  variantSelection: ProductVariantSelection
}

type ProductSelectionProductExcluded implements MessagePayload {
  product: Product
  productRef: Reference!
  type: String!
  variantExclusion: ProductVariantExclusion
}

type ProductSelectionProductRemoved implements MessagePayload {
  product: Product
  productRef: Reference!
  type: String!
}

"""Fields to access product selection assignments."""
interface ProductSelectionQueryInterface {
  productSelectionAssignments(limit: Int, offset: Int, sort: [String!], where: String): ProductAssignmentQueryResult!
}

type ProductSelectionQueryResult {
  count: Int!
  exists: Boolean!
  offset: Int!
  results: [ProductSelection!]!
  total: Long!
}

type ProductSelectionSetting {
  active: Boolean!
  productSelection: ProductSelection
  productSelectionRef: Reference!
}

input ProductSelectionSettingDraft {
  active: Boolean!
  productSelection: ResourceIdentifierInput!
}

input ProductSelectionSettingInActionInput {
  active: Boolean
  productSelection: ResourceIdentifierInput!
}

input ProductSelectionUpdateAction {
  addProduct: AddProductSelectionProduct
  changeName: ChangeProductSelectionName
  excludeProduct: ExcludeProductSelectionProduct
  removeProduct: RemoveProductSelectionProduct
  setCustomField: SetProductSelectionCustomField
  setCustomType: SetProductSelectionCustomType
  setKey: SetProductSelectionKey
  setVariantExclusion: SetProductSelectionVariantExclusion
  setVariantSelection: SetProductSelectionVariantSelection
}

type ProductSelectionVariantExclusionChanged implements MessagePayload {
  newVariantExclusion: ProductVariantExclusion
  oldVariantExclusion: ProductVariantExclusion
  product: Product
  productRef: Reference!
  type: String!
}

type ProductSelectionVariantSelectionChanged implements MessagePayload {
  newVariantSelection: ProductVariantSelection
  oldVariantSelection: ProductVariantSelection
  product: Product
  productRef: Reference!
  type: String!
}

type ProductSlugChanged implements MessagePayload {
  oldSlug(
    """
    List of languages the client is able to understand, and which locale variant is preferred.
    """
    acceptLanguage: [Locale!]

    """
    String is defined for different locales. This argument specifies the desired locale.
    """
    locale: Locale
  ): String
  oldSlugAllLocales: [LocalizedString!]
  slug(
    """
    List of languages the client is able to understand, and which locale variant is preferred.
    """
    acceptLanguage: [Locale!]

    """
    String is defined for different locales. This argument specifies the desired locale.
    """
    locale: Locale
  ): String
  slugAllLocales: [LocalizedString!]!
  type: String!
}

type ProductStateTransition implements MessagePayload {
  force: Boolean!
  state: State
  stateRef: Reference!
  type: String!
}

"""
BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta
"""
type ProductTailoring implements Versioned {
  createdAt: DateTime!
  createdBy: Initiator
  current: ProductTailoringData
  hasStagedChanges: Boolean!
  id: String!
  key: String
  lastModifiedAt: DateTime!
  lastModifiedBy: Initiator
  product: Product
  productRef: Reference!
  published: Boolean!
  staged: ProductTailoringData
  store: Store
  storeRef: KeyReference!
  version: Long!
}

type ProductTailoringCreated implements HasProductTailoringData & MessagePayload {
  description(
    """
    List of languages the client is able to understand, and which locale variant is preferred.
    """
    acceptLanguage: [Locale!]

    """
    String is defined for different locales. This argument specifies the desired locale.
    """
    locale: Locale
  ): String
  descriptionAllLocales: [LocalizedString!]
  key: String
  metaDescription(
    """
    List of languages the client is able to understand, and which locale variant is preferred.
    """
    acceptLanguage: [Locale!]

    """
    String is defined for different locales. This argument specifies the desired locale.
    """
    locale: Locale
  ): String
  metaDescriptionAllLocales: [LocalizedString!]
  metaKeywords(
    """
    List of languages the client is able to understand, and which locale variant is preferred.
    """
    acceptLanguage: [Locale!]

    """
    String is defined for different locales. This argument specifies the desired locale.
    """
    locale: Locale
  ): String
  metaKeywordsAllLocales: [LocalizedString!]
  metaTitle(
    """
    List of languages the client is able to understand, and which locale variant is preferred.
    """
    acceptLanguage: [Locale!]

    """
    String is defined for different locales. This argument specifies the desired locale.
    """
    locale: Locale
  ): String
  metaTitleAllLocales: [LocalizedString!]
  name(
    """
    List of languages the client is able to understand, and which locale variant is preferred.
    """
    acceptLanguage: [Locale!]

    """
    String is defined for different locales. This argument specifies the desired locale.
    """
    locale: Locale
  ): String
  nameAllLocales: [LocalizedString!]
  productKey: String
  productRef: Reference!
  publish: Boolean!
  slug(
    """
    List of languages the client is able to understand, and which locale variant is preferred.
    """
    acceptLanguage: [Locale!]

    """
    String is defined for different locales. This argument specifies the desired locale.
    """
    locale: Locale
  ): String
  slugAllLocales: [LocalizedString!]
  storeRef: KeyReference!
  type: String!
}

type ProductTailoringData implements HasProductTailoringData {
  description(
    """
    List of languages the client is able to understand, and which locale variant is preferred.
    """
    acceptLanguage: [Locale!]

    """
    String is defined for different locales. This argument specifies the desired locale.
    """
    locale: Locale
  ): String
  descriptionAllLocales: [LocalizedString!]
  metaDescription(
    """
    List of languages the client is able to understand, and which locale variant is preferred.
    """
    acceptLanguage: [Locale!]

    """
    String is defined for different locales. This argument specifies the desired locale.
    """
    locale: Locale
  ): String
  metaDescriptionAllLocales: [LocalizedString!]
  metaKeywords(
    """
    List of languages the client is able to understand, and which locale variant is preferred.
    """
    acceptLanguage: [Locale!]

    """
    String is defined for different locales. This argument specifies the desired locale.
    """
    locale: Locale
  ): String
  metaKeywordsAllLocales: [LocalizedString!]
  metaTitle(
    """
    List of languages the client is able to understand, and which locale variant is preferred.
    """
    acceptLanguage: [Locale!]

    """
    String is defined for different locales. This argument specifies the desired locale.
    """
    locale: Locale
  ): String
  metaTitleAllLocales: [LocalizedString!]
  name(
    """
    List of languages the client is able to understand, and which locale variant is preferred.
    """
    acceptLanguage: [Locale!]

    """
    String is defined for different locales. This argument specifies the desired locale.
    """
    locale: Locale
  ): String
  nameAllLocales: [LocalizedString!]
  slug(
    """
    List of languages the client is able to understand, and which locale variant is preferred.
    """
    acceptLanguage: [Locale!]

    """
    String is defined for different locales. This argument specifies the desired locale.
    """
    locale: Locale
  ): String
  slugAllLocales: [LocalizedString!]
}

type ProductTailoringDeleted implements MessagePayload {
  productKey: String
  productRef: Reference!
  storeRef: KeyReference!
  type: String!
}

type ProductTailoringDescriptionSet implements MessagePayload {
  description(
    """
    List of languages the client is able to understand, and which locale variant is preferred.
    """
    acceptLanguage: [Locale!]

    """
    String is defined for different locales. This argument specifies the desired locale.
    """
    locale: Locale
  ): String
  descriptionAllLocales: [LocalizedString!]
  oldDescription(
    """
    List of languages the client is able to understand, and which locale variant is preferred.
    """
    acceptLanguage: [Locale!]

    """
    String is defined for different locales. This argument specifies the desired locale.
    """
    locale: Locale
  ): String
  oldDescriptionAllLocales: [LocalizedString!]
  productKey: String
  productRef: Reference!
  storeRef: KeyReference!
  type: String!
}

input ProductTailoringDraft {
  description: [LocalizedStringItemInputType!]
  key: String
  metaDescription: [LocalizedStringItemInputType!]
  metaKeywords: [LocalizedStringItemInputType!]
  metaTitle: [LocalizedStringItemInputType!]
  name: [LocalizedStringItemInputType!]
  product: ResourceIdentifierInput!
  publish: Boolean
  slug: [LocalizedStringItemInputType!]
}

type ProductTailoringNameSet implements MessagePayload {
  name(
    """
    List of languages the client is able to understand, and which locale variant is preferred.
    """
    acceptLanguage: [Locale!]

    """
    String is defined for different locales. This argument specifies the desired locale.
    """
    locale: Locale
  ): String
  nameAllLocales: [LocalizedString!]
  oldName(
    """
    List of languages the client is able to understand, and which locale variant is preferred.
    """
    acceptLanguage: [Locale!]

    """
    String is defined for different locales. This argument specifies the desired locale.
    """
    locale: Locale
  ): String
  oldNameAllLocales: [LocalizedString!]
  productKey: String
  productRef: Reference!
  storeRef: KeyReference!
  type: String!
}

type ProductTailoringPublished implements MessagePayload {
  productKey: String
  productRef: Reference!
  storeRef: KeyReference!
  type: String!
}

type ProductTailoringQueryResult {
  count: Int!
  exists: Boolean!
  offset: Int!
  results: [ProductTailoring!]!
  total: Long!
}

type ProductTailoringSlugSet implements MessagePayload {
  oldSlug(
    """
    List of languages the client is able to understand, and which locale variant is preferred.
    """
    acceptLanguage: [Locale!]

    """
    String is defined for different locales. This argument specifies the desired locale.
    """
    locale: Locale
  ): String
  oldSlugAllLocales: [LocalizedString!]
  productKey: String
  productRef: Reference!
  slug(
    """
    List of languages the client is able to understand, and which locale variant is preferred.
    """
    acceptLanguage: [Locale!]

    """
    String is defined for different locales. This argument specifies the desired locale.
    """
    locale: Locale
  ): String
  slugAllLocales: [LocalizedString!]
  storeRef: KeyReference!
  type: String!
}

type ProductTailoringUnpublished implements MessagePayload {
  productKey: String
  productRef: Reference!
  storeRef: KeyReference!
  type: String!
}

input ProductTailoringUpdateAction {
  publish: PublishTailoring
  setDescription: SetProductTailoringDescription
  setMetaAttributes: SetProductTailoringMetaAttributes
  setMetaDescription: SetProductTailoringMetaDescription
  setMetaKeywords: SetProductTailoringMetaKeywords
  setMetaTitle: SetProductTailoringMetaTitle
  setName: SetProductTailoringName
  setSlug: SetProductTailoringSlug
  unpublish: UnpublishTailoring
}

type ProductTypeDefinition implements ReferenceExpandable & Versioned {
  attributeDefinitions(
    """
    The names of the attribute definitions to exclude.
    
    If neither `includeNames` nor `excludeNames` are provided, then all attribute definitions are returned.
    """
    excludeNames: [String!]

    """
    The names of the attribute definitions to include.
    
    If neither `includeNames` nor `excludeNames` are provided, then all attribute definitions are returned.
    """
    includeNames: [String!]
    limit: Int
    offset: Int
    sort: [String!]
  ): AttributeDefinitionResult!
  createdAt: DateTime!
  createdBy: Initiator
  description: String!
  id: String!
  key: String
  lastModifiedAt: DateTime!
  lastModifiedBy: Initiator
  name: String!
  version: Long!
}

type ProductTypeDefinitionQueryResult {
  count: Int!
  exists: Boolean!
  offset: Int!
  results: [ProductTypeDefinition!]!
  total: Long!
}

input ProductTypeDraft {
  attributeDefinitions: [AttributeDefinitionDraft!]
  description: String!
  key: String
  name: String!
}

type ProductTypeLimitWithCurrent implements LimitWithCurrent {
  current: Long!
  limit: Long
}

type ProductTypeLimitsProjection {
  total: ProductTypeLimitWithCurrent!
}

input ProductTypeUpdateAction {
  addAttributeDefinition: addAttributeDefinition
  addLocalizedEnumValue: addLocalizedEnumValue
  addPlainEnumValue: addPlainEnumValue
  changeAttributeName: changeAttributeName
  changeAttributeOrder: changeAttributeOrder
  changeAttributeOrderByName: changeAttributeOrderByName
  changeDescription: changeDescription
  changeEnumKey: changeEnumKey
  changeInputHint: changeInputHint
  changeIsSearchable: changeIsSearchable
  changeLabel: changeLabel
  changeLocalizedEnumValueLabel: changeLocalizedEnumValueLabel
  changeLocalizedEnumValueOrder: changeLocalizedEnumValueOrder
  changeName: changeName
  changePlainEnumValueLabel: changePlainEnumValueLabel
  changePlainEnumValueOrder: changePlainEnumValueOrder
  removeAttributeDefinition: removeAttributeDefinition
  removeEnumValues: removeEnumValues
  setInputTip: setInputTip
  setKey: setKey
}

type ProductUnpublished implements MessagePayload {
  type: String!
}

input ProductUpdateAction {
  addAsset: AddProductAsset
  addExternalImage: AddProductExternalImage
  addPrice: AddProductPrice
  addToCategory: AddProductToCategory
  addVariant: AddProductVariant
  changeAssetName: ChangeProductAssetName
  changeAssetOrder: ChangeProductAssetOrder
  changeImageLabel: ChangeProductImageLabel
  changeMasterVariant: ChangeProductMasterVariant
  changeName: ChangeProductName
  changePrice: ChangeProductPrice
  changeSlug: ChangeProductSlug
  moveImageToPosition: MoveProductImageToPosition
  publish: PublishProduct
  removeAsset: RemoveProductAsset
  removeFromCategory: RemoveProductFromCategory
  removeImage: RemoveProductImage
  removePrice: RemoveProductPrice
  removeVariant: RemoveProductVariant
  revertStagedChanges: RevertStagedChanges
  revertStagedVariantChanges: RevertStagedVariantChanges
  setAssetCustomField: SetProductAssetCustomField
  setAssetCustomType: SetProductAssetCustomType
  setAssetDescription: SetProductAssetDescription
  setAssetKey: SetProductAssetKey
  setAssetSources: SetProductAssetSources
  setAssetTags: SetProductAssetTags
  setAttribute: SetProductAttribute
  setAttributeInAllVariants: SetProductAttributeInAllVariants
  setCategoryOrderHint: SetProductCategoryOrderHint
  setDescription: SetProductDescription
  setDiscountedPrice: SetProductDiscountedPrice
  setImageLabel: SetProductImageLabel
  setKey: SetProductKey
  setMetaAttributes: SetProductMetaAttributes
  setMetaDescription: SetProductMetaDescription
  setMetaKeywords: SetProductMetaKeywords
  setMetaTitle: SetProductMetaTitle
  setPriceKey: SetProductPriceKey
  setPriceMode: SetProductPriceMode
  setPrices: SetProductPrices
  setProductPriceCustomField: SetProductPriceCustomField
  setProductPriceCustomType: SetProductPriceCustomType
  setProductVariantKey: SetProductVariantKey
  setSearchKeywords: SetSearchKeywords
  setSku: SetProductSku
  setTaxCategory: SetProductTaxCategory
  transitionState: TransitionProductState
  unpublish: UnpublishProduct
}

type ProductVariant {
  assets: [Asset!]!

  """This field contains raw attributes data"""
  attributesRaw(
    """
    The names of the attributes to exclude.
    
    If neither `includeNames` nor `excludeNames` are provided, then all attributes are returned.
    """
    excludeNames: [String!]

    """
    The names of the attributes to include.
    
    If neither `includeNames` nor `excludeNames` are provided, then all attributes are returned.
    """
    includeNames: [String!]
  ): [RawProductAttribute!]!
  availability: ProductVariantAvailabilityWithChannels
  id: Int!
  images: [Image!]!
  key: String

  """Returns a single price based on the price selection rules."""
  price(channelId: String, country: Country, currency: Currency!, customerGroupId: String, date: DateTime): ProductPrice
  prices: [ProductPrice!]
  sku: String
}

type ProductVariantAdded implements MessagePayload {
  staged: Boolean!
  type: String!
  variant: ProductVariant!
}

"""Product variant availabilities"""
type ProductVariantAvailabilitiesResult {
  limit: Int
  offset: Int
  results: [ProductVariantAvailabilityWithChannel!]!
  total: Int!
}

"""Product variant availability"""
type ProductVariantAvailability {
  availableQuantity: Long
  id: String
  isOnStock: Boolean!
  restockableInDays: Int
  version: Long
}

type ProductVariantAvailabilityWithChannel {
  availability: ProductVariantAvailability!
  channel: Channel
  channelRef: Reference!
}

type ProductVariantAvailabilityWithChannels {
  channels(
    """
    The IDs of channels to exclude.
    
    If neither `includeChannelIds` nor `excludeChannelIds` are provided, then all channels are returned.
    """
    excludeChannelIds: [String!]

    """
    The IDs of channels to include.
    
    If neither `includeChannelIds` nor `excludeChannelIds` are provided, then all channels are returned.
    """
    includeChannelIds: [String!]
    limit: Int
    offset: Int
  ): ProductVariantAvailabilitiesResult!
  noChannel: ProductVariantAvailability
}

type ProductVariantDeleted implements MessagePayload {
  removedImageUrls: Set!
  staged: Boolean
  type: String!
  variant: ProductVariant
}

type ProductVariantExclusion {
  skus: [String!]!
}

input ProductVariantExclusionDraft {
  skus: [String!]
}

input ProductVariantImportDraft {
  attributes: [ProductAttributeInput!] = []
  id: Int
  images: [ImageInput!] = []
  prices: [ProductPriceDataInput!] = []
  sku: String
}

input ProductVariantInput {
  assets: [AssetDraftInput!] = []
  attributes: [ProductAttributeInput!] = []
  images: [ImageInput!] = []
  key: String
  prices: [ProductPriceDataInput!] = []
  sku: String
}

interface ProductVariantSelection {
  skus: [String!]!
  type: String!
}

input ProductVariantSelectionDraft {
  includeAllExcept: [String!]
  includeOnly: [String!]
}

type ProductVariantSelectionIncludeAllExcept implements ProductVariantSelection {
  skus: [String!]!
  type: String!
}

type ProductVariantSelectionIncludeOnly implements ProductVariantSelection {
  skus: [String!]!
  type: String!
}

"""
CLOSED BETA: This feature is subject to change and should not be used in production. https://docs.commercetools.com/api/contract#closed-beta
"""
type ProductsSearchConfiguration {
  lastModifiedAt: DateTime!
  lastModifiedBy: Initiator
  status: ProductsSearchStatus!
}

"""
CLOSED BETA: This feature is subject to change and should not be used in production. https://docs.commercetools.com/api/contract#closed-beta
"""
enum ProductsSearchStatus {
  Activated
  Deactivated
}

"""Contains information about the limits of your project."""
type ProjectCustomLimitsProjection {
  attributeGroups: AttributeGroupLimitsProjection!
  cartDiscounts: CartDiscountLimitsProjection!
  carts: CartLimitsProjection!
  category: CategoryLimitsProjection!
  customObjects: CustomObjectLimitsProjection!
  customerGroups: CustomerGroupLimitsProjection!
  customers: CustomerLimitsProjection!
  extensions: ExtensionLimitsProjection!
  orderEdits: OrderEditLimitsProjection!
  productDiscounts: ProductDiscountLimitsProjection!
  productType: ProductTypeLimitsProjection!
  products: ProductLimitsProjection!
  query: QueryLimitsProjection!
  refreshTokens: RefreshTokenLimitsProjection!
  search: SearchLimitsProjection!
  shippingMethods: ShippingMethodLimitsProjection!
  shoppingLists: ShoppingListLimitsProjection!
  stores: StoreLimitsProjection!
  subscriptions: SubscriptionsLimitsProjection!
  taxCategories: TaxCategoryLimitsProjection!
  zones: ZoneLimitsProjection!
}

"""Project contains information about project."""
type ProjectProjection {
  businessUnits: BusinessUnitConfiguration
  carts: CartsConfiguration!
  countries: [Country!]!
  createdAt: DateTime!
  createdBy: Initiator
  currencies: [Currency!]!
  externalOAuth: ExternalOAuth
  key: String!
  languages: [Locale!]!
  lastModifiedAt: DateTime
  lastModifiedBy: Initiator
  messages: MessagesConfiguration!
  name: String!
  searchIndexing: SearchIndexingConfiguration
  shippingRateInputType: ShippingRateInputType
  shoppingLists: ShoppingListsConfiguration!
  trialUntil: YearMonth
  version: Long!
}

input ProjectSettingsUpdateAction {
  """
  CLOSED BETA: This feature is subject to change and should not be used in production. https://docs.commercetools.com/api/contract#closed-beta
  """
  changeBusinessUnitSearchStatus: ChangeProjectSettingsBusinessUnitSearchStatus
  changeCartsConfiguration: ChangeProjectSettingsCartsConfiguration
  changeCountries: ChangeProjectSettingsCountries
  changeCountryTaxRateFallbackEnabled: ChangeProjectSettingsCountryTaxRateFallbackEnabled
  changeCurrencies: ChangeProjectSettingsCurrencies

  """
  CLOSED BETA: This feature is subject to change and should not be used in production. https://docs.commercetools.com/api/contract#closed-beta
  """
  changeCustomerSearchStatus: ChangeProjectSettingsCustomerSearchStatus
  changeLanguages: ChangeProjectSettingsLanguages
  changeMessagesConfiguration: ChangeProjectSettingsMessagesConfiguration
  changeMessagesEnabled: ChangeProjectSettingsMessagesEnabled
  changeMyBusinessUnitStatusOnCreation: ChangeProjectSettingsMyBusinessUnitStatusOnCreation
  changeName: ChangeProjectSettingsName
  changeOrderSearchStatus: ChangeProjectSettingsOrderSearchStatus
  changeProductSearchIndexingEnabled: ChangeProjectSettingsProductSearchIndexingEnabled

  """
  CLOSED BETA: This feature is subject to change and should not be used in production. https://docs.commercetools.com/api/contract#closed-beta
  """
  changeProjectSettingsProductSearchIndexingEnabled: ChangeProjectSettingsProductSearchIndexingEnabled
  changeShoppingListsConfiguration: ChangeProjectSettingsShoppingListsConfiguration
  setExternalOAuth: SetProjectSettingsExternalOAuth

  """
  BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta
  """
  setMyBusinessUnitAssociateRoleOnCreation: SetProjectSettingsMyBusinessUnitAssociateRoleOnCreation
  setShippingRateInputType: SetProjectSettingsShippingRateInputType
}

input PublishProduct {
  scope: PublishScope
}

enum PublishScope {
  """Publishes the complete staged projection"""
  All

  """Publishes only prices on the staged projection"""
  Prices
}

input PublishTailoring {
  dummy: String
}

type PurchaseOrderNumberSet implements MessagePayload & OrderMessagePayload {
  oldPurchaseOrderNumber: String
  purchaseOrderNumber: String
  type: String!
}

type Query implements CartQueryInterface & CustomerActiveCartInterface & CustomerQueryInterface & MeFieldInterface & OrderQueryInterface & ProductSelectionQueryInterface & ShippingMethodsByCartInterface & ShoppingListQueryInterface {
  apiClient(id: String!): APIClientWithoutSecret
  apiClients(limit: Int, offset: Int, sort: [String!], where: String): APIClientWithoutSecretQueryResult!

  """
  This field gives access to the resources (such as carts) as an associate of a given business unit.
  """
  asAssociate(associateId: String!, businessUnitKey: KeyReferenceInput!): AsAssociate!
  associateRole(
    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
  ): AssociateRole
  associateRoles(limit: Int, offset: Int, sort: [String!], where: String): AssociateRoleQueryResult!
  attributeGroup(
    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
  ): AttributeGroup
  attributeGroups(limit: Int, offset: Int, sort: [String!], where: String): AttributeGroupQueryResult!
  businessUnit(
    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
  ): BusinessUnit
  businessUnits(limit: Int, offset: Int, sort: [String!], where: String): BusinessUnitQueryResult!
  cart(id: String!): Cart
  cartDiscount(
    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
  ): CartDiscount
  cartDiscounts(limit: Int, offset: Int, sort: [String!], where: String): CartDiscountQueryResult!
  carts(limit: Int, offset: Int, sort: [String!], where: String): CartQueryResult!
  categories(limit: Int, offset: Int, sort: [String!], where: String): CategoryQueryResult!
  category(
    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
  ): Category
  channel(
    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
  ): Channel
  channels(limit: Int, offset: Int, sort: [String!], where: String): ChannelQueryResult!
  customObject(
    container: String

    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
  ): CustomObject
  customObjects(container: String!, limit: Int, offset: Int, sort: [String!], where: String): CustomObjectQueryResult!
  customer(
    """Queries a customer with specified email token"""
    emailToken: String

    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String

    """Queries a customer with specified password token"""
    passwordToken: String
  ): Customer
  customerActiveCart(customerId: String!): Cart
  customerGroup(
    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
  ): CustomerGroup
  customerGroups(limit: Int, offset: Int, sort: [String!], where: String): CustomerGroupQueryResult!
  customers(limit: Int, offset: Int, sort: [String!], where: String): CustomerQueryResult!
  discountCode(
    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
  ): DiscountCode
  discountCodes(limit: Int, offset: Int, sort: [String!], where: String): DiscountCodeQueryResult!
  extension(
    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
  ): Extension
  extensions(limit: Int, offset: Int, sort: [String!], where: String): ExtensionQueryResult!

  """
  This field gives access to the resources (such as carts) that are inside the given store.
  """
  inStore(key: KeyReferenceInput!): InStore!

  """
  This field gives access to the resources (such as carts) that are inside one of the given stores.
  """
  inStores(keys: [KeyReferenceInput!]!): InStore!
  inventoryEntries(limit: Int, offset: Int, sort: [String!], where: String): InventoryEntryQueryResult!
  inventoryEntry(
    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
  ): InventoryEntry
  limits: ProjectCustomLimitsProjection!

  """
  This field can only be used with an access token created with the password flow or with an anonymous session.
  
  It gives access to the data that is specific to the customer or the anonymous session linked to the access token.
  """
  me: Me!
  message(
    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
  ): Message
  messages(limit: Int, offset: Int, sort: [String!], where: String): MessageQueryResult!
  order(
    """Queries with specified ID"""
    id: String
    orderNumber: String
  ): Order
  orderEdit(
    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
  ): OrderEdit
  orderEdits(limit: Int, offset: Int, sort: [String!], where: String): OrderEditQueryResult!
  orders(limit: Int, offset: Int, sort: [String!], where: String): OrderQueryResult!
  payment(
    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
  ): Payment
  payments(limit: Int, offset: Int, sort: [String!], where: String): PaymentQueryResult!
  product(
    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
    localeProjection: [Locale!]
    projectExpandedProducts: Boolean = false

    """Queries for a product with specified SKU"""
    sku: String

    """
    Queries for a [Product](https://docs.commercetools.com/api/projects/products#product) with specified [ProductVariant](https://docs.commercetools.com/api/projects/products#productvariant) `key`
    """
    variantKey: String
  ): Product
  productDiscount(
    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
  ): ProductDiscount
  productDiscounts(limit: Int, offset: Int, sort: [String!], where: String): ProductDiscountQueryResult!
  productProjectionSearch(
    facetFilters: [SearchFilterInput!] = []
    facets: [SearchFacetInput!] = []
    filters: [SearchFilterInput!] = []
    fuzzy: Boolean = false
    fuzzyLevel: Int
    limit: Int = 10
    locale: Locale
    localeProjection: [Locale!]

    """Deprecated: please use 'markMatchingVariants'."""
    markMatchingVariant: Boolean = false
    markMatchingVariants: Boolean = false
    offset: Int = 0
    priceSelector: PriceSelectorInput
    projectExpandedProducts: Boolean = false
    queryFilters: [SearchFilterInput!] = []
    sorts: [String!] = []
    staged: Boolean = false
    storeProjection: String
    text: String
  ): ProductProjectionSearchResult!
  productProjectionsSuggest(fuzzy: Boolean, limit: Int = 10, searchKeywords: [SearchKeywordArgument!]!, staged: Boolean = false): SuggestResult!
  productSelection(
    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
  ): ProductSelection
  productSelectionAssignments(limit: Int, offset: Int, sort: [String!], where: String): ProductAssignmentQueryResult!
  productSelections(limit: Int, offset: Int, sort: [String!], where: String): ProductSelectionQueryResult!

  """
  BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta
  """
  productTailoring(
    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String

    """Queries with specified Product ID"""
    productId: String

    """Queries with specified Product key"""
    productKey: String

    """
    The mutation is only performed if the resource is part of the store. Can be used with store-specific OAuth permissions.
    """
    storeKey: KeyReferenceInput
  ): ProductTailoring
  productTailoringList(limit: Int, offset: Int, sort: [String!], where: String): ProductTailoringQueryResult!
  productType(
    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
  ): ProductTypeDefinition
  productTypes(limit: Int, offset: Int, sort: [String!], where: String): ProductTypeDefinitionQueryResult!
  products(
    limit: Int
    localeProjection: [Locale!]
    offset: Int
    projectExpandedProducts: Boolean = false

    """Queries for products with specified SKUs"""
    skus: [String!]
    sort: [String!]
    where: String
  ): ProductQueryResult!
  project: ProjectProjection!
  quote(
    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
  ): Quote
  quoteRequest(
    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
  ): QuoteRequest
  quoteRequests(limit: Int, offset: Int, sort: [String!], where: String): QuoteRequestQueryResult!
  quotes(limit: Int, offset: Int, sort: [String!], where: String): QuoteQueryResult!
  review(
    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
  ): Review
  reviews(limit: Int, offset: Int, sort: [String!], where: String): ReviewQueryResult!
  shippingMethod(
    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
  ): ShippingMethod
  shippingMethods(limit: Int, offset: Int, sort: [String!], where: String): ShippingMethodQueryResult!
  shippingMethodsByCart(id: String!): [ShippingMethod!]!
  shippingMethodsByLocation(country: Country!, currency: Currency, state: String): [ShippingMethod!]!
  shoppingList(
    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
  ): ShoppingList
  shoppingLists(limit: Int, offset: Int, sort: [String!], where: String): ShoppingListQueryResult!
  stagedQuote(
    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
  ): StagedQuote
  stagedQuotes(limit: Int, offset: Int, sort: [String!], where: String): StagedQuoteQueryResult!

  """
  StandalonePrices are managed and queried through the StandalonePrices API
  and associated to a ProductVariant through the sku field.
  """
  standalonePrice(
    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
  ): StandalonePrice

  """
  StandalonePrices are managed and queried through the StandalonePrices API
  and associated to a ProductVariant through the sku field.
  """
  standalonePrices(limit: Int, offset: Int, sort: [String!], where: String): StandalonePriceQueryResult!
  state(
    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
  ): State
  states(limit: Int, offset: Int, sort: [String!], where: String): StateQueryResult!
  store(
    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
  ): Store
  stores(limit: Int, offset: Int, sort: [String!], where: String): StoreQueryResult!
  subscription(
    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
  ): CommercetoolsSubscription
  subscriptions(limit: Int, offset: Int, sort: [String!], where: String): CommercetoolsSubscriptionQueryResult!
  taxCategories(limit: Int, offset: Int, sort: [String!], where: String): TaxCategoryQueryResult!
  taxCategory(
    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
  ): TaxCategory
  typeDefinition(
    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
  ): TypeDefinition
  typeDefinitions(limit: Int, offset: Int, sort: [String!], where: String): TypeDefinitionQueryResult!
  zone(
    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
  ): Zone
  zones(limit: Int, offset: Int, sort: [String!], where: String): ZoneQueryResult!
}

type QueryLimitsProjection {
  offset: Limit!
}

type Quote implements Versioned {
  billingAddress: Address
  businessUnit: BusinessUnit
  businessUnitRef: KeyReference
  buyerComment: String
  country: Country
  createdAt: DateTime!
  createdBy: Initiator
  custom: CustomFieldsType
  customLineItems: [CustomLineItem!]!
  customer: Customer
  customerGroup: CustomerGroup
  customerGroupRef: Reference
  customerRef: Reference

  """
  BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta
  """
  directDiscounts: [DirectDiscount!]!
  id: String!
  inventoryMode: InventoryMode!
  itemShippingAddresses: [Address!]!
  key: String
  lastModifiedAt: DateTime!
  lastModifiedBy: Initiator
  lineItems(
    """Queries with specified ID"""
    id: String
  ): [LineItem!]!
  paymentInfo: PaymentInfo
  purchaseOrderNumber: String
  quoteRequest: QuoteRequest
  quoteRequestRef: Reference!
  quoteState: QuoteState!
  sellerComment: String
  shippingAddress: Address
  shippingInfo: ShippingInfo
  shippingRateInput: ShippingRateInput
  stagedQuote: StagedQuote
  stagedQuoteRef: Reference!
  state: State
  stateRef: Reference
  store: Store
  storeRef: KeyReference
  taxCalculationMode: TaxCalculationMode!
  taxMode: TaxMode!
  taxRoundingMode: RoundingMode!
  taxedPrice: TaxedPrice
  totalPrice: Money!
  validTo: DateTime
  version: Long!
}

type QuoteCreated implements MessagePayload {
  quote: Quote!
  type: String!
}

type QuoteCustomerChanged implements MessagePayload {
  customer: Customer
  customerRef: Reference!
  previousCustomer: Customer
  previousCustomerRef: Reference!
  type: String!
}

type QuoteDeleted implements MessagePayload {
  type: String!
}

input QuoteDraft {
  custom: CustomFieldsDraft
  key: String
  stagedQuote: ResourceIdentifierInput
  stagedQuoteStateToSent: Boolean = false
  stagedQuoteVersion: Long
  state: ReferenceInput
}

"""Fields to access Quotes."""
interface QuoteQueryInterface {
  quote(
    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
  ): Quote
  quotes(limit: Int, offset: Int, sort: [String!], where: String): QuoteQueryResult!
}

type QuoteQueryResult {
  count: Int!
  exists: Boolean!
  offset: Int!
  results: [Quote!]!
  total: Long!
}

type QuoteRenegotiationRequested implements MessagePayload {
  buyerComment: String
  type: String!
}

type QuoteRequest implements Versioned {
  billingAddress: Address
  businessUnit: BusinessUnit
  businessUnitRef: KeyReference
  cartRef: Reference
  comment: String
  country: Country
  createdAt: DateTime!
  createdBy: Initiator
  custom: CustomFieldsType
  customLineItems: [CustomLineItem!]!
  customer: Customer
  customerGroup: CustomerGroup
  customerGroupRef: Reference
  customerRef: Reference

  """
  BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta
  """
  directDiscounts: [DirectDiscount!]!
  id: String!
  inventoryMode: InventoryMode!
  itemShippingAddresses: [Address!]!
  key: String
  lastModifiedAt: DateTime!
  lastModifiedBy: Initiator
  lineItems(
    """Queries with specified ID"""
    id: String
  ): [LineItem!]!
  paymentInfo: PaymentInfo
  purchaseOrderNumber: String
  quoteRequestState: QuoteRequestState!
  shippingAddress: Address
  shippingInfo: ShippingInfo
  shippingRateInput: ShippingRateInput
  state: State
  stateRef: Reference
  store: Store
  storeRef: KeyReference
  taxCalculationMode: TaxCalculationMode!
  taxMode: TaxMode!
  taxRoundingMode: RoundingMode!
  taxedPrice: TaxedPrice
  totalPrice: Money!
  version: Long!
}

type QuoteRequestCreated implements MessagePayload {
  quoteRequest: QuoteRequest!
  type: String!
}

type QuoteRequestCustomerChanged implements MessagePayload {
  customer: Customer
  customerRef: Reference!
  previousCustomer: Customer
  previousCustomerRef: Reference!
  type: String!
}

type QuoteRequestDeleted implements MessagePayload {
  type: String!
}

input QuoteRequestDraft {
  cart: ResourceIdentifierInput
  cartVersion: Long
  comment: String
  custom: CustomFieldsDraft
  key: String
  purchaseOrderNumber: String
  state: ReferenceInput
}

"""Fields to access QuoteRequests."""
interface QuoteRequestQueryInterface {
  quoteRequest(
    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
  ): QuoteRequest
  quoteRequests(limit: Int, offset: Int, sort: [String!], where: String): QuoteRequestQueryResult!
}

type QuoteRequestQueryResult {
  count: Int!
  exists: Boolean!
  offset: Int!
  results: [QuoteRequest!]!
  total: Long!
}

enum QuoteRequestState {
  Accepted
  Cancelled
  Closed
  Rejected
  Submitted
  UnderReview
}

type QuoteRequestStateChanged implements MessagePayload {
  oldQuoteRequestState: QuoteRequestState!
  quoteRequestState: QuoteRequestState!
  type: String!
}

type QuoteRequestStateTransition implements MessagePayload {
  force: Boolean!
  oldState: State
  oldStateRef: Reference
  state: State
  stateRef: Reference!
  type: String!
}

input QuoteRequestUpdateAction {
  changeCustomer: ChangeQuoteRequestCustomer
  changeQuoteRequestState: ChangeQuoteRequestState
  setCustomField: SetQuoteRequestCustomField
  setCustomType: SetQuoteRequestCustomType
  transitionState: TransitionQuoteRequestState
}

enum QuoteState {
  Accepted
  Declined
  DeclinedForRenegotiation
  Pending
  RenegotiationAddressed
  Withdrawn
}

type QuoteStateChanged implements MessagePayload {
  oldQuoteState: QuoteState!
  quoteState: QuoteState!
  type: String!
}

type QuoteStateTransition implements MessagePayload {
  force: Boolean!
  oldState: State
  oldStateRef: Reference
  state: State
  stateRef: Reference!
  type: String!
}

input QuoteUpdateAction {
  changeCustomer: ChangeQuoteCustomer
  changeQuoteState: ChangeQuoteState
  requestQuoteRenegotiation: RequestQuoteRenegotiation
  setCustomField: SetQuoteCustomField
  setCustomType: SetQuoteCustomType
  transitionState: TransitionQuoteState
}

interface RangeCount {
  type: String!
}

type RangeCountDouble implements RangeCount {
  count: Int!
  from: Float!
  fromStr: String!
  max: Float!
  mean: Float!
  min: Float!
  productCount: Int
  to: Float!
  toStr: String!
  total: Float!
  totalCount: Int!
  type: String!
}

type RangeCountLong implements RangeCount {
  count: Int!
  from: Long!
  fromStr: String!
  max: Long!
  mean: Float!
  min: Long!
  productCount: Int
  to: Long!
  toStr: String!
  total: Long!
  totalCount: Int!
  type: String!
}

input RangeElementInput {
  from: String!
  to: String!
}

input RangeFacetInput {
  alias: String
  countProducts: Boolean! = false
  path: String!
  ranges: [RangeElementInput!]!
}

type RangeFacetResult implements FacetResult {
  dataType: String!
  ranges: [RangeCount!]!
  type: String!
}

input RangeFilterInput {
  path: String!
  ranges: [RangeElementInput!]!
}

type RawCustomField {
  name: String!

  """
  BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta
  """
  referencedResource: ReferenceExpandable

  """
  BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta
  """
  referencedResourceSet: [ReferenceExpandable!]!
  value: Json!
}

type RawProductAttribute {
  attributeDefinition: AttributeDefinition
  name: String!

  """
  BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta
  """
  referencedResource: ReferenceExpandable

  """
  BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta
  """
  referencedResourceSet: [ReferenceExpandable!]!
  value: Json!
}

type RawProductSearchAttribute {
  name: String!

  """
  BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta
  """
  referencedResource: ReferenceExpandable

  """
  BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta
  """
  referencedResourceSet: [ReferenceExpandable!]!
  value: Json!
}

input RecalculateCart {
  updateProductData: Boolean = false
}

input RecalculateStagedOrder {
  updateProductData: Boolean = false
}

type RecalculateStagedOrderOutput implements StagedOrderUpdateActionOutput {
  type: String!
  updateProductData: Boolean!
}

type Reference {
  id: String!
  typeId: String!
}

type ReferenceAttribute implements Attribute {
  id: String!
  name: String!
  typeId: String!
}

type ReferenceAttributeDefinitionType implements AttributeDefinitionType {
  name: String!
  referenceTypeId: String!
}

interface ReferenceExpandable {
  id: String!
}

type ReferenceField implements CustomField {
  id: String!
  name: String!
  typeId: String!
}

type ReferenceId {
  id: String!
  typeId: String!
}

input ReferenceInput {
  id: String!
  typeId: String!
}

type ReferenceType implements FieldType {
  name: String!
  referenceTypeId: String!
}

input ReferenceTypeDefinitionDraft {
  referenceTypeId: String!
}

type RefreshTokenLimitWithCurrent implements LimitWithCurrent {
  current: Long!
  limit: Long
}

type RefreshTokenLimitsProjection {
  total: RefreshTokenLimitWithCurrent!
}

input RejectApprovalFlow {
  reason: String
}

type RelativeDiscountValue implements CartDiscountValue & ProductDiscountValue {
  permyriad: Int!
  type: String!
}

input RelativeDiscountValueInput {
  permyriad: Int!
}

input RemoveAssociateRolePermission {
  permission: Permission!
}

input RemoveAttributeGroupAttribute {
  attribute: AttributeReferenceInput!
}

input RemoveBusinessUnitAddress {
  addressId: String
  addressKey: String
}

input RemoveBusinessUnitAssociate {
  customer: ResourceIdentifierInput!
}

input RemoveBusinessUnitBillingAddressId {
  addressId: String
  addressKey: String
}

input RemoveBusinessUnitShippingAddressId {
  addressId: String
  addressKey: String
}

input RemoveBusinessUnitStore {
  store: ResourceIdentifierInput!
}

input RemoveCartCustomLineItem {
  customLineItemId: String
  customLineItemKey: String
}

input RemoveCartDiscountCode {
  discountCode: ReferenceInput!
}

input RemoveCartDiscountStore {
  store: ResourceIdentifierInput!
}

input RemoveCartItemShippingAddress {
  addressKey: String!
}

input RemoveCartLineItem {
  externalPrice: BaseMoneyInput
  externalTotalPrice: ExternalLineItemTotalPriceDraft
  lineItemId: String
  lineItemKey: String
  quantity: Long
  shippingDetailsToRemove: ItemShippingDetailsDraft
}

input RemoveCartPayment {
  payment: ResourceIdentifierInput!
}

input RemoveCartShippingMethod {
  shippingKey: String!
}

input RemoveCategoryAsset {
  assetId: String
  assetKey: String
}

input RemoveChannelRoles {
  roles: [ChannelRole!]!
}

input RemoveCustomerAddress {
  addressId: String
  addressKey: String
}

input RemoveCustomerBillingAddressId {
  addressId: String
  addressKey: String
}

input RemoveCustomerGroupAssignment {
  customerGroup: ResourceIdentifierInput!
}

input RemoveCustomerShippingAddressId {
  addressId: String
  addressKey: String
}

input RemoveCustomerStore {
  store: ResourceIdentifierInput!
}

input RemoveInventoryEntryQuantity {
  quantity: Long!
}

input RemoveMyBusinessUnitAddress {
  addressId: String
  addressKey: String
}

input RemoveMyBusinessUnitAssociate {
  customer: ResourceIdentifierInput!
}

input RemoveMyBusinessUnitBillingAddressId {
  addressId: String
  addressKey: String
}

input RemoveMyBusinessUnitShippingAddressId {
  addressId: String
  addressKey: String
}

input RemoveOrderDelivery {
  deliveryId: String
  deliveryKey: String
}

input RemoveOrderItemShippingAddress {
  addressKey: String!
}

input RemoveOrderParcelFromDelivery {
  parcelId: String
  parcelKey: String
}

input RemoveOrderPayment {
  payment: ResourceIdentifierInput!
}

input RemoveProductAsset {
  assetId: String
  assetKey: String
  sku: String
  staged: Boolean = true
  variantId: Int
}

input RemoveProductFromCategory {
  category: ResourceIdentifierInput!
  staged: Boolean = true
}

input RemoveProductImage {
  imageUrl: String!
  sku: String
  staged: Boolean = true
  variantId: Int
}

input RemoveProductPrice {
  priceId: String
  staged: Boolean = true
}

input RemoveProductSelectionProduct {
  product: ResourceIdentifierInput!
}

input RemoveProductVariant {
  id: Int
  sku: String
  staged: Boolean = true
}

input RemoveShippingMethodShippingRate {
  shippingRate: ShippingRateDraft!
  zone: ResourceIdentifierInput!
}

input RemoveShippingMethodZone {
  zone: ResourceIdentifierInput!
}

input RemoveShoppingListLineItem {
  lineItemId: String
  lineItemKey: String
  quantity: Int
}

input RemoveShoppingListTextLineItem {
  quantity: Int
  textLineItemId: String
  textLineItemKey: String
}

input RemoveStagedChanges {
  dummy: String
}

input RemoveStagedOrderCustomLineItem {
  customLineItemId: String
  customLineItemKey: String
}

type RemoveStagedOrderCustomLineItemOutput implements StagedOrderUpdateActionOutput {
  customLineItemId: String
  customLineItemKey: String
  type: String!
}

input RemoveStagedOrderDelivery {
  deliveryId: String
  deliveryKey: String
}

type RemoveStagedOrderDeliveryOutput implements StagedOrderUpdateActionOutput {
  deliveryId: String
  deliveryKey: String
  type: String!
}

input RemoveStagedOrderDiscountCode {
  discountCode: ReferenceInput!
}

type RemoveStagedOrderDiscountCodeOutput implements StagedOrderUpdateActionOutput {
  discountCode: DiscountCode
  discountCodeRef: Reference!
  type: String!
}

input RemoveStagedOrderItemShippingAddress {
  addressKey: String!
}

type RemoveStagedOrderItemShippingAddressOutput implements StagedOrderUpdateActionOutput {
  addressKey: String!
  type: String!
}

input RemoveStagedOrderLineItem {
  externalPrice: BaseMoneyInput
  externalTotalPrice: ExternalLineItemTotalPriceDraft
  lineItemId: String
  lineItemKey: String
  quantity: Long
  shippingDetailsToRemove: ItemShippingDetailsDraftType
}

type RemoveStagedOrderLineItemOutput implements StagedOrderUpdateActionOutput {
  externalPrice: BaseMoney
  externalTotalPrice: ExternalLineItemTotalPrice
  lineItemId: String
  lineItemKey: String
  quantity: Long
  shippingDetailsToRemove: ItemShippingDetailsDraftOutput
  type: String!
}

input RemoveStagedOrderParcelFromDelivery {
  parcelId: String
  parcelKey: String
}

type RemoveStagedOrderParcelFromDeliveryOutput implements StagedOrderUpdateActionOutput {
  parcelId: String
  parcelKey: String
  type: String!
}

input RemoveStagedOrderPayment {
  payment: ResourceIdentifierInput!
}

type RemoveStagedOrderPaymentOutput implements StagedOrderUpdateActionOutput {
  paymentResId: ResourceIdentifier!
  type: String!
}

input RemoveStandalonePriceTier {
  minimumQuantity: Int!
}

input RemoveStateRoles {
  roles: [StateRole!]!
}

input RemoveStoreCountry {
  country: StoreCountryInput!
}

input RemoveStoreDistributionChannel {
  distributionChannel: ResourceIdentifierInput!
}

input RemoveStoreProductSelection {
  productSelection: ResourceIdentifierInput!
}

input RemoveStoreSupplyChannel {
  supplyChannel: ResourceIdentifierInput!
}

input RemoveTypeFieldDefinition {
  fieldName: String!
}

input RemoveZoneLocation {
  location: ZoneLocation!
}

input RequestQuoteRenegotiation {
  buyerComment: String
}

type ResourceIdentifier {
  id: String
  key: String
  typeId: String!
}

input ResourceIdentifierInput {
  id: String
  key: String
  typeId: String
}

"""Stores information about returns connected to this order."""
type ReturnInfo {
  items: [ReturnItem!]!
  returnDate: DateTime
  returnTrackingId: String
}

type ReturnInfoAdded implements MessagePayload & OrderMessagePayload {
  returnInfo: ReturnInfo!
  type: String!
}

input ReturnInfoDraftType {
  items: [ReturnItemDraftType!]!
  returnDate: DateTime
  returnTrackingId: String
}

type ReturnInfoDraftTypeOutput {
  items: [ReturnItemDraftTypeOutput!]!
  returnDate: DateTime
  returnTrackingId: String
}

type ReturnInfoSet implements MessagePayload & OrderMessagePayload {
  returnInfo: [ReturnInfo!]
  type: String!
}

interface ReturnItem {
  comment: String
  createdAt: DateTime!
  custom: CustomFieldsType
  id: String!
  key: String
  lastModifiedAt: DateTime!
  paymentState: ReturnPaymentState!
  quantity: Long!
  shipmentState: ReturnShipmentState!
  type: String!
}

input ReturnItemDraftType {
  comment: String
  custom: CustomFieldsDraft
  customLineItemId: String
  key: String
  lineItemId: String
  quantity: Long!
  shipmentState: ReturnShipmentState!
}

type ReturnItemDraftTypeOutput {
  comment: String
  custom: CustomFieldsCommand
  customLineItemId: String
  key: String
  lineItemId: String
  quantity: Long!
  shipmentState: ReturnShipmentState!
}

enum ReturnPaymentState {
  Initial
  NonRefundable
  NotRefunded
  Refunded
}

enum ReturnShipmentState {
  Advised
  BackInStock
  Returned
  Unusable
}

input RevertStagedChanges {
  dummy: String
}

input RevertStagedVariantChanges {
  variantId: Int!
}

type Review implements ReferenceExpandable & Versioned {
  authorName: String
  createdAt: DateTime!
  createdBy: Initiator
  custom: CustomFieldsType
  customer: Customer
  customerRef: Reference
  id: String!
  includedInStatistics: Boolean!
  key: String
  lastModifiedAt: DateTime!
  lastModifiedBy: Initiator
  locale: Locale
  rating: Int
  state: State
  stateRef: Reference
  target: ReviewTarget
  targetRef: Reference
  text: String
  title: String
  uniquenessValue: String
  version: Long!
}

type ReviewCreated implements MessagePayload {
  review: Review!
  type: String!
}

input ReviewDraft {
  authorName: String
  custom: CustomFieldsDraft
  customer: ResourceIdentifierInput
  key: String
  locale: Locale
  rating: Int
  state: ResourceIdentifierInput
  target: TargetReferenceInput
  text: String
  title: String
  uniquenessValue: String
}

type ReviewQueryResult {
  count: Int!
  exists: Boolean!
  offset: Int!
  results: [Review!]!
  total: Long!
}

type ReviewRatingSet implements MessagePayload {
  includedInStatistics: Boolean!
  newRating: Int
  oldRating: Int
  target: ReviewTarget
  targetRef: Reference
  type: String!
}

type ReviewRatingStatistics {
  averageRating: Float!
  count: Long!
  highestRating: Int!
  lowestRating: Int!
  ratingsDistribution: Json!
}

type ReviewStateTransition implements MessagePayload {
  force: Boolean!
  newIncludedInStatistics: Boolean!
  newState: State
  newStateRef: Reference!
  oldIncludedInStatistics: Boolean!
  oldState: State
  oldStateRef: Reference
  target: ReviewTarget
  targetRef: Reference
  type: String!
}

interface ReviewTarget {
  id: String!
}

input ReviewUpdateAction {
  setAuthorName: SetReviewAuthorName
  setCustomField: SetReviewCustomField
  setCustomType: SetReviewCustomType
  setCustomer: SetReviewCustomer
  setKey: SetReviewKey
  setLocale: SetReviewLocale
  setRating: SetReviewRating
  setTarget: SetReviewTarget
  setText: SetReviewText
  setTitle: SetReviewTitle
  transitionState: TransitionReviewState
}

enum RoundingMode {
  """
  [Round half down](https://en.wikipedia.org/wiki/Rounding#Round_half_down)
  """
  HalfDown

  """
  [Round half to even](https://en.wikipedia.org/wiki/Rounding#Round_half_to_even). Default rounding mode as used in IEEE 754 computing functions and operators.
  """
  HalfEven

  """[Round half up](https://en.wikipedia.org/wiki/Rounding#Round_half_up)"""
  HalfUp
}

type RuleApprover {
  associateRole: AssociateRole!
  associateRoleRef: KeyReference!
}

input RuleApproverDraft {
  associateRole: ResourceIdentifierInput!
}

type RuleRequester {
  associateRole: AssociateRole!
  associateRoleRef: KeyReference!
}

input RuleRequesterDraft {
  associateRole: ResourceIdentifierInput!
}

type SNSDestination implements Destination {
  accessKey: String
  accessSecret: String
  authenticationMode: AwsAuthenticationMode!
  topicArn: String!
  type: String!
}

input SNSDestinationInput {
  accessKey: String
  accessSecret: String
  authenticationMode: AwsAuthenticationMode = Credentials
  topicArn: String!
}

type SQSDestination implements Destination {
  accessKey: String
  accessSecret: String
  authenticationMode: AwsAuthenticationMode!
  queueUrl: String!
  region: String!
  type: String!
}

input SQSDestinationInput {
  accessKey: String
  accessSecret: String
  authenticationMode: AwsAuthenticationMode = Credentials
  queueUrl: String!
  region: String!
}

type ScopedPrice {
  channel: Channel
  channelRef: Reference
  country: String
  currentValue: BaseMoney!
  custom: CustomFieldsType
  customerGroup: CustomerGroup
  customerGroupRef: Reference
  discounted: DiscountedProductSearchPriceValue
  id: String!
  validFrom: DateTime
  validUntil: DateTime
  value: BaseMoney!
}

type ScoreShippingRateInput implements ShippingRateInput {
  score: Int!
  type: String!
}

input ScoreShippingRateInputDraft {
  score: Int!
}

type ScoreShippingRateInputDraftOutput implements ShippingRateInputDraftOutput {
  score: Int!
  type: String!
}

input SearchFacetInput {
  model: SearchFacetModelInput
  string: String
}

input SearchFacetModelInput {
  range: RangeFacetInput
  terms: TermsFacetInput
}

input SearchFilterInput {
  model: SearchFilterModelInput
  string: String
}

input SearchFilterModelInput {
  exists: ExistsFilterInput
  missing: MissingFilterInput
  range: RangeFilterInput
  tree: TreeFilterInput
  value: ValueFilterInput
}

type SearchIndexingConfiguration {
  """
  CLOSED BETA: This feature is subject to change and should not be used in production. https://docs.commercetools.com/api/contract#closed-beta
  """
  businessUnits: BusinessUnitSearchConfiguration

  """
  CLOSED BETA: This feature is subject to change and should not be used in production. https://docs.commercetools.com/api/contract#closed-beta
  """
  customers: CustomerSearchConfiguration
  orders: OrderSearchConfiguration
  products: SearchIndexingConfigurationValues

  """
  CLOSED BETA: This feature is subject to change and should not be used in production. https://docs.commercetools.com/api/contract#closed-beta
  """
  productsSearch: ProductsSearchConfiguration
}

type SearchIndexingConfigurationValues {
  lastModifiedAt: DateTime
  lastModifiedBy: Initiator
  status: SearchIndexingStatus
}

enum SearchIndexingStatus {
  Activated
  Deactivated
  Indexing
}

type SearchKeyword {
  suggestTokenizer: SuggestTokenizer
  text: String!
}

input SearchKeywordArgument {
  locale: Locale!
  searchKeyword: String!
}

input SearchKeywordInput {
  keywords: [SearchKeywordItemInput!]!
  locale: Locale!
}

input SearchKeywordItemInput {
  suggestTokenizer: BaseSearchKeywordInput
  text: String!
}

type SearchKeywordProductSearch {
  suggestTokenizer: SuggestTokenizerProductSearch
  text: String!
}

type SearchKeywords {
  locale: Locale!
  searchKeywords: [SearchKeyword!]!
}

type SearchKeywordsProductSearch {
  locale: Locale!
  searchKeywords: [SearchKeywordProductSearch!]!
}

type SearchLimitsProjection {
  maxTextSize: Limit!
}

"""
In order to decide which of the matching items will actually be discounted
"""
enum SelectionMode {
  Cheapest
  MostExpensive
}

type SelectionOfProduct {
  createdAt: DateTime!
  lastModifiedAt: DateTime!
  productSelection: ProductSelection
  productSelectionRef: Reference!
  variantExclusion: ProductVariantExclusion
  variantSelection: ProductVariantSelection
}

type SelectionOfProductQueryResult {
  count: Int!
  exists: Boolean!
  offset: Int!
  results: [SelectionOfProduct!]!
  total: Long!
}

"""A set."""
scalar Set

input SetApprovalFlowCustomField {
  name: String!
  value: String
}

input SetApprovalFlowCustomType {
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeId: String
  typeKey: String
}

input SetApprovalRuleApprovers {
  approvers: ApproverHierarchyDraft!
}

input SetApprovalRuleDescription {
  description: String
}

input SetApprovalRuleKey {
  key: String
}

input SetApprovalRuleName {
  name: String!
}

input SetApprovalRulePredicate {
  predicate: String!
}

input SetApprovalRuleRequesters {
  requesters: [RuleRequesterDraft!]!
}

input SetApprovalRuleStatus {
  status: ApprovalRuleStatus!
}

input SetAssociateRoleCustomField {
  name: String!
  value: String
}

input SetAssociateRoleCustomType {
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeId: String
  typeKey: String
}

input SetAssociateRoleName {
  name: String
}

input SetAssociateRolePermissions {
  permissions: [Permission!]
}

type SetAttributeDefinitionType implements AttributeDefinitionType {
  elementType: AttributeDefinitionType!
  name: String!
}

input SetAttributeGroupAttributes {
  attributes: [AttributeReferenceInput!]!
}

input SetAttributeGroupDescription {
  description: [LocalizedStringItemInputType!]
}

input SetAttributeGroupKey {
  key: String
}

input SetBusinessUnitAddressCustomField {
  addressId: String
  addressKey: String
  name: String!
  value: String
}

input SetBusinessUnitAddressCustomType {
  addressId: String
  addressKey: String
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeId: String
  typeKey: String
}

input SetBusinessUnitAssociates {
  associates: [AssociateDraft!] = []
}

input SetBusinessUnitContactEmail {
  contactEmail: String
}

input SetBusinessUnitCustomField {
  name: String!
  value: String
}

input SetBusinessUnitCustomType {
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeId: String
  typeKey: String
}

input SetBusinessUnitDefaultBillingAddress {
  addressId: String
  addressKey: String
}

input SetBusinessUnitDefaultShippingAddress {
  addressId: String
  addressKey: String
}

input SetBusinessUnitStoreMode {
  storeMode: String
  stores: [ResourceIdentifierInput!]
}

input SetBusinessUnitStores {
  stores: [ResourceIdentifierInput!]!
}

input SetCartAnonymousId {
  anonymousId: String
}

input SetCartBillingAddress {
  address: AddressInput
}

input SetCartBillingAddressCustomField {
  name: String!
  value: String
}

input SetCartBillingAddressCustomType {
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeId: String
  typeKey: String
}

input SetCartBusinessUnit {
  businessUnit: ResourceIdentifierInput!
}

input SetCartCountry {
  country: Country
}

input SetCartCustomField {
  name: String!
  value: String
}

input SetCartCustomLineItemCustomField {
  customLineItemId: String
  customLineItemKey: String
  name: String!
  value: String
}

input SetCartCustomLineItemCustomType {
  customLineItemId: String
  customLineItemKey: String
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeId: String
  typeKey: String
}

input SetCartCustomLineItemShippingDetails {
  customLineItemId: String
  customLineItemKey: String
  shippingDetails: ItemShippingDetailsDraft
}

input SetCartCustomLineItemTaxAmount {
  customLineItemId: String
  customLineItemKey: String
  externalTaxAmount: ExternalTaxAmountDraft
  shippingKey: String
}

input SetCartCustomLineItemTaxRate {
  customLineItemId: String
  customLineItemKey: String
  externalTaxRate: ExternalTaxRateDraft
  shippingKey: String
}

input SetCartCustomShippingMethod {
  externalTaxRate: ExternalTaxRateDraft
  shippingMethodName: String!
  shippingRate: ShippingRateDraft!
  taxCategory: ResourceIdentifierInput
}

input SetCartCustomType {
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeId: String
  typeKey: String
}

input SetCartCustomerEmail {
  email: String
}

input SetCartCustomerGroup {
  customerGroup: ResourceIdentifierInput
}

input SetCartCustomerId {
  customerId: String
}

input SetCartDeleteDaysAfterLastModification {
  deleteDaysAfterLastModification: Int
}

input SetCartDirectDiscounts {
  discounts: [DirectDiscountDraft!]!
}

input SetCartDiscountCustomField {
  name: String!
  value: String
}

input SetCartDiscountCustomType {
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeId: String
  typeKey: String
}

input SetCartDiscountDescription {
  description: [LocalizedStringItemInputType!]
}

input SetCartDiscountKey {
  key: String
}

input SetCartDiscountStores {
  stores: [ResourceIdentifierInput!]
}

input SetCartDiscountValidFrom {
  validFrom: DateTime
}

input SetCartDiscountValidFromAndUntil {
  validFrom: DateTime
  validUntil: DateTime
}

input SetCartDiscountValidUntil {
  validUntil: DateTime
}

input SetCartItemShippingAddressCustomField {
  addressKey: String!
  name: String!
  value: String
}

input SetCartItemShippingAddressCustomType {
  addressKey: String!
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeId: String
  typeKey: String
}

input SetCartKey {
  key: String
}

input SetCartLineItemCustomField {
  lineItemId: String
  lineItemKey: String
  name: String!
  value: String
}

input SetCartLineItemCustomType {
  fields: [CustomFieldInput!]
  lineItemId: String
  lineItemKey: String
  type: ResourceIdentifierInput
  typeId: String
  typeKey: String
}

input SetCartLineItemDistributionChannel {
  distributionChannel: ResourceIdentifierInput
  lineItemId: String
  lineItemKey: String
}

input SetCartLineItemInventoryMode {
  inventoryMode: InventoryMode
  lineItemId: String
  lineItemKey: String
}

input SetCartLineItemPrice {
  externalPrice: BaseMoneyInput
  lineItemId: String
  lineItemKey: String
}

input SetCartLineItemShippingDetails {
  lineItemId: String
  lineItemKey: String
  shippingDetails: ItemShippingDetailsDraft
}

input SetCartLineItemSupplyChannel {
  lineItemId: String
  lineItemKey: String
  supplyChannel: ResourceIdentifierInput
}

input SetCartLineItemTaxAmount {
  externalTaxAmount: ExternalTaxAmountDraft
  lineItemId: String
  lineItemKey: String
  shippingKey: String
}

input SetCartLineItemTaxRate {
  externalTaxRate: ExternalTaxRateDraft
  lineItemId: String
  lineItemKey: String
  shippingKey: String
}

input SetCartLineItemTotalPrice {
  externalTotalPrice: ExternalLineItemTotalPriceDraft
  lineItemId: String
  lineItemKey: String
}

input SetCartLocale {
  locale: Locale
}

input SetCartShippingAddress {
  address: AddressInput
}

input SetCartShippingAddressCustomField {
  name: String!
  value: String
}

input SetCartShippingAddressCustomType {
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeId: String
  typeKey: String
}

input SetCartShippingCustomField {
  name: String!
  shippingKey: String
  value: String
}

input SetCartShippingCustomType {
  fields: [CustomFieldInput!]
  shippingKey: String
  type: ResourceIdentifierInput
  typeId: String
  typeKey: String
}

input SetCartShippingMethod {
  externalTaxRate: ExternalTaxRateDraft
  shippingMethod: ResourceIdentifierInput
}

input SetCartShippingMethodTaxAmount {
  externalTaxAmount: ExternalTaxAmountDraft
  shippingKey: String
}

input SetCartShippingMethodTaxRate {
  externalTaxRate: ExternalTaxRateDraft
  shippingKey: String
}

input SetCartShippingRateInput {
  shippingRateInput: ShippingRateInputDraft
}

input SetCartTotalTax {
  externalTaxPortions: [TaxPortionDraft!] = []
  externalTotalGross: MoneyInput
}

input SetCategoryAssetCustomField {
  assetId: String
  assetKey: String
  name: String!
  value: String
}

input SetCategoryAssetCustomType {
  assetId: String
  assetKey: String
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeId: String
  typeKey: String
}

input SetCategoryAssetDescription {
  assetId: String
  assetKey: String
  description: [LocalizedStringItemInputType!]
}

input SetCategoryAssetKey {
  assetId: String!
  assetKey: String
}

input SetCategoryAssetSources {
  assetId: String
  assetKey: String
  sources: [AssetSourceInput!] = []
}

input SetCategoryAssetTags {
  assetId: String
  assetKey: String
  tags: [String!] = []
}

input SetCategoryCustomField {
  name: String!
  value: String
}

input SetCategoryCustomType {
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeId: String
  typeKey: String
}

input SetCategoryDescription {
  description: [LocalizedStringItemInputType!]
}

input SetCategoryExternalId {
  externalId: String
}

input SetCategoryKey {
  key: String
}

input SetCategoryMetaDescription {
  metaDescription: [LocalizedStringItemInputType!]
}

input SetCategoryMetaKeywords {
  metaKeywords: [LocalizedStringItemInputType!]
}

input SetCategoryMetaTitle {
  metaTitle: [LocalizedStringItemInputType!]
}

input SetChannelAddress {
  address: AddressInput
}

input SetChannelAddressCustomField {
  name: String!
  value: String
}

input SetChannelAddressCustomType {
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeId: String
  typeKey: String
}

input SetChannelCustomField {
  name: String!
  value: String
}

input SetChannelCustomType {
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeId: String
  typeKey: String
}

input SetChannelGeoLocation {
  geoLocation: GeometryInput
}

input SetChannelRoles {
  roles: [ChannelRole!]!
}

input SetCustomerAddressCustomField {
  addressId: String!
  name: String!
  value: String
}

input SetCustomerAddressCustomType {
  addressId: String!
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeId: String
  typeKey: String
}

input SetCustomerAuthenticationMode {
  authMode: AuthenticationMode!
  password: String
}

input SetCustomerCompanyName {
  companyName: String
}

input SetCustomerCustomField {
  name: String!
  value: String
}

input SetCustomerCustomType {
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeId: String
  typeKey: String
}

input SetCustomerDateOfBirth {
  dateOfBirth: Date
}

input SetCustomerDefaultBillingAddress {
  addressId: String
  addressKey: String
}

input SetCustomerDefaultShippingAddress {
  addressId: String
  addressKey: String
}

input SetCustomerExternalId {
  externalId: String
}

input SetCustomerFirstName {
  firstName: String
}

input SetCustomerGroup {
  customerGroup: ResourceIdentifierInput
}

input SetCustomerGroupAssignments {
  customerGroupAssignments: [CustomerGroupAssignmentDraft!]!
}

input SetCustomerGroupCustomField {
  name: String!
  value: String
}

input SetCustomerGroupCustomType {
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeId: String
  typeKey: String
}

input SetCustomerGroupKey {
  key: String
}

input SetCustomerKey {
  key: String
}

input SetCustomerLastName {
  lastName: String
}

input SetCustomerLocale {
  locale: Locale
}

input SetCustomerMiddleName {
  middleName: String
}

input SetCustomerNumber {
  customerNumber: String
}

input SetCustomerSalutation {
  salutation: String
}

input SetCustomerStores {
  stores: [ResourceIdentifierInput!]!
}

input SetCustomerTitle {
  title: String
}

input SetCustomerVatId {
  vatId: String
}

input SetDiscountCodeCartPredicate {
  cartPredicate: String
}

input SetDiscountCodeCustomField {
  name: String!
  value: String
}

input SetDiscountCodeCustomType {
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeId: String
  typeKey: String
}

input SetDiscountCodeDescription {
  description: [LocalizedStringItemInputType!]
}

input SetDiscountCodeKey {
  key: String
}

input SetDiscountCodeMaxApplications {
  maxApplications: Long
}

input SetDiscountCodeMaxApplicationsPerCustomer {
  maxApplicationsPerCustomer: Long
}

input SetDiscountCodeName {
  name: [LocalizedStringItemInputType!]
}

input SetDiscountCodeValidFrom {
  validFrom: DateTime
}

input SetDiscountCodeValidFromAndUntil {
  validFrom: DateTime
  validUntil: DateTime
}

input SetDiscountCodeValidUntil {
  validUntil: DateTime
}

input SetExtensionKey {
  key: String
}

input SetExtensionTimeoutInMs {
  timeoutInMs: Int
}

input SetInventoryEntryCustomField {
  name: String!
  value: String
}

input SetInventoryEntryCustomType {
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeId: String
  typeKey: String
}

input SetInventoryEntryExpectedDelivery {
  expectedDelivery: DateTime
}

input SetInventoryEntryRestockableInDays {
  restockableInDays: Int
}

input SetInventoryEntrySupplyChannel {
  supplyChannel: ResourceIdentifierInput
}

input SetMyBusinessUnitAddressCustomField {
  addressId: String
  addressKey: String
  name: String!
  value: String
}

input SetMyBusinessUnitAddressCustomType {
  addressId: String
  addressKey: String
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeId: String
  typeKey: String
}

input SetMyBusinessUnitContactEmail {
  contactEmail: String
}

input SetMyBusinessUnitCustomField {
  name: String!
  value: String
}

input SetMyBusinessUnitCustomType {
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeId: String
  typeKey: String
}

input SetMyBusinessUnitDefaultBillingAddress {
  addressId: String
  addressKey: String
}

input SetMyBusinessUnitDefaultShippingAddress {
  addressId: String
  addressKey: String
}

input SetMyCartShippingMethod {
  shippingMethod: ResourceIdentifierInput
}

input SetMyQuoteRequestCustomField {
  name: String!
  value: String
}

input SetMyQuoteRequestCustomType {
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeId: String
  typeKey: String
}

input SetOrderBillingAddress {
  address: AddressInput
}

input SetOrderBillingAddressCustomField {
  name: String!
  value: String
}

input SetOrderBillingAddressCustomType {
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeId: String
  typeKey: String
}

input SetOrderCustomField {
  name: String!
  value: String
}

input SetOrderCustomLineItemCustomField {
  customLineItemId: String
  customLineItemKey: String
  name: String!
  value: String
}

input SetOrderCustomLineItemCustomType {
  customLineItemId: String
  customLineItemKey: String
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeId: String
  typeKey: String
}

input SetOrderCustomLineItemShippingDetails {
  customLineItemId: String
  customLineItemKey: String
  shippingDetails: ItemShippingDetailsDraftType
}

input SetOrderCustomType {
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeId: String
  typeKey: String
}

input SetOrderCustomerEmail {
  email: String
}

input SetOrderCustomerId {
  customerId: String
}

input SetOrderDeliveryAddress {
  address: AddressInput
  deliveryId: String
  deliveryKey: String
}

input SetOrderDeliveryAddressCustomField {
  deliveryId: String
  deliveryKey: String
  name: String!
  value: String
}

input SetOrderDeliveryAddressCustomType {
  deliveryId: String
  deliveryKey: String
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeId: String
  typeKey: String
}

input SetOrderDeliveryCustomField {
  deliveryId: String
  deliveryKey: String
  name: String!
  value: String
}

input SetOrderDeliveryCustomType {
  deliveryId: String
  deliveryKey: String
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeId: String
  typeKey: String
}

input SetOrderDeliveryItems {
  deliveryId: String
  deliveryKey: String
  items: [DeliveryItemDraftType!]!
}

input SetOrderEditComment {
  comment: String
}

input SetOrderEditCustomField {
  name: String!
  value: String
}

input SetOrderEditCustomType {
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeId: String
  typeKey: String
}

input SetOrderEditKey {
  key: String
}

input SetOrderEditStagedActions {
  stagedActions: [StagedOrderUpdateAction!]!
}

input SetOrderItemShippingAddressCustomField {
  addressKey: String!
  name: String!
  value: String
}

input SetOrderItemShippingAddressCustomType {
  addressKey: String!
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeId: String
  typeKey: String
}

input SetOrderLineItemCustomField {
  lineItemId: String
  lineItemKey: String
  name: String!
  value: String
}

input SetOrderLineItemCustomType {
  fields: [CustomFieldInput!]
  lineItemId: String
  lineItemKey: String
  type: ResourceIdentifierInput
  typeId: String
  typeKey: String
}

input SetOrderLineItemShippingDetails {
  lineItemId: String
  lineItemKey: String
  shippingDetails: ItemShippingDetailsDraftType
}

input SetOrderLocale {
  locale: Locale
}

input SetOrderNumber {
  orderNumber: String
}

input SetOrderParcelCustomField {
  name: String!
  parcelId: String
  parcelKey: String
  value: String
}

input SetOrderParcelCustomType {
  fields: [CustomFieldInput!]
  parcelId: String
  parcelKey: String
  type: ResourceIdentifierInput
  typeId: String
  typeKey: String
}

input SetOrderParcelItems {
  items: [DeliveryItemDraftType!]!
  parcelId: String
  parcelKey: String
}

input SetOrderParcelMeasurements {
  measurements: ParcelMeasurementsDraftType
  parcelId: String
  parcelKey: String
}

input SetOrderParcelTrackingData {
  parcelId: String
  parcelKey: String
  trackingData: TrackingDataDraftType
}

input SetOrderPurchaseOrderNumber {
  purchaseOrderNumber: String
}

input SetOrderReturnInfo {
  items: [ReturnInfoDraftType!] = []
}

input SetOrderReturnItemCustomField {
  name: String!
  returnItemId: String
  returnItemKey: String
  value: String
}

input SetOrderReturnItemCustomType {
  fields: [CustomFieldInput!]
  returnItemId: String
  returnItemKey: String
  type: ResourceIdentifierInput
  typeId: String
  typeKey: String
}

input SetOrderReturnPaymentState {
  paymentState: ReturnPaymentState!
  returnItemId: String
  returnItemKey: String
}

input SetOrderReturnShipmentState {
  returnItemId: String
  returnItemKey: String
  shipmentState: ReturnShipmentState!
}

input SetOrderShippingAddress {
  address: AddressInput
}

input SetOrderShippingAddressCustomField {
  name: String!
  value: String
}

input SetOrderShippingAddressCustomType {
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeId: String
  typeKey: String
}

input SetOrderShippingCustomField {
  name: String!
  shippingKey: String
  value: String
}

input SetOrderShippingCustomType {
  fields: [CustomFieldInput!]
  shippingKey: String
  type: ResourceIdentifierInput
  typeId: String
  typeKey: String
}

input SetOrderStore {
  store: ResourceIdentifierInput
}

input SetPaymentAmountPaid {
  amount: MoneyInput
}

input SetPaymentAmountRefunded {
  amount: MoneyInput
}

input SetPaymentAnonymousId {
  anonymousId: String
}

input SetPaymentAuthorization {
  amount: MoneyInput
  until: DateTime
}

input SetPaymentCustomField {
  name: String!
  value: String
}

input SetPaymentCustomType {
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeId: String
  typeKey: String
}

input SetPaymentCustomer {
  customer: ResourceIdentifierInput
}

input SetPaymentExternalId {
  externalId: String
}

input SetPaymentInterfaceId {
  interfaceId: String
}

input SetPaymentKey {
  key: String
}

input SetPaymentMethodInfoInterface {
  interface: String!
}

input SetPaymentMethodInfoMethod {
  method: String
}

input SetPaymentMethodInfoName {
  name: [LocalizedStringItemInputType!]
}

input SetPaymentStatusInterfaceCode {
  interfaceCode: String
}

input SetPaymentStatusInterfaceText {
  interfaceText: String
}

input SetPaymentTransactionCustomField {
  name: String!
  transactionId: String!
  value: String
}

input SetPaymentTransactionCustomType {
  fields: [CustomFieldInput!]
  transactionId: String!
  type: ResourceIdentifierInput
  typeId: String
  typeKey: String
}

input SetProductAssetCustomField {
  assetId: String
  assetKey: String
  name: String!
  sku: String
  staged: Boolean = true
  value: String
  variantId: Int
}

input SetProductAssetCustomType {
  assetId: String
  assetKey: String
  fields: [CustomFieldInput!]
  sku: String
  staged: Boolean = true
  type: ResourceIdentifierInput
  typeId: String
  typeKey: String
  variantId: Int
}

input SetProductAssetDescription {
  assetId: String
  assetKey: String
  description: [LocalizedStringItemInputType!]
  sku: String
  staged: Boolean = true
  variantId: Int
}

input SetProductAssetKey {
  assetId: String!
  assetKey: String
  sku: String
  staged: Boolean = true
  variantId: Int
}

input SetProductAssetSources {
  assetId: String
  assetKey: String
  sku: String
  sources: [AssetSourceInput!] = []
  staged: Boolean = true
  variantId: Int
}

input SetProductAssetTags {
  assetId: String
  assetKey: String
  sku: String
  staged: Boolean = true
  tags: [String!] = []
  variantId: Int
}

input SetProductAttribute {
  name: String!
  sku: String
  staged: Boolean = true
  value: String
  variantId: Int
}

input SetProductAttributeInAllVariants {
  name: String!
  staged: Boolean = true
  value: String
}

input SetProductCategoryOrderHint {
  categoryId: String!
  orderHint: String
  staged: Boolean = true
}

input SetProductDescription {
  description: [LocalizedStringItemInputType!]
  staged: Boolean = true
}

input SetProductDiscountDescription {
  description: [LocalizedStringItemInputType!]
}

input SetProductDiscountKey {
  key: String
}

input SetProductDiscountValidFrom {
  validFrom: DateTime
}

input SetProductDiscountValidFromAndUntil {
  validFrom: DateTime
  validUntil: DateTime
}

input SetProductDiscountValidUntil {
  validUntil: DateTime
}

input SetProductDiscountedPrice {
  discounted: DiscountedProductPriceValueInput
  priceId: String!
  staged: Boolean = true
}

input SetProductImageLabel {
  imageUrl: String!
  label: String
  sku: String
  staged: Boolean = true
  variantId: Int
}

input SetProductKey {
  key: String
}

input SetProductMetaAttributes {
  metaDescription: [LocalizedStringItemInputType!]
  metaKeywords: [LocalizedStringItemInputType!]
  metaTitle: [LocalizedStringItemInputType!]
  staged: Boolean = true
}

input SetProductMetaDescription {
  metaDescription: [LocalizedStringItemInputType!]
  staged: Boolean = true
}

input SetProductMetaKeywords {
  metaKeywords: [LocalizedStringItemInputType!]
  staged: Boolean = true
}

input SetProductMetaTitle {
  metaTitle: [LocalizedStringItemInputType!]
  staged: Boolean = true
}

input SetProductPriceCustomField {
  name: String!
  priceId: String!
  staged: Boolean = true
  value: String
}

input SetProductPriceCustomType {
  fields: [CustomFieldInput!]
  priceId: String!
  staged: Boolean = true
  type: ResourceIdentifierInput
  typeId: String
  typeKey: String
}

input SetProductPriceKey {
  key: String
  priceId: String!
  staged: Boolean = true
}

input SetProductPriceMode {
  priceMode: PriceMode
}

input SetProductPrices {
  prices: [ProductPriceDataInput!]!
  sku: String
  staged: Boolean = true
  variantId: Int
}

input SetProductSelectionCustomField {
  name: String!
  value: String
}

input SetProductSelectionCustomType {
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeId: String
  typeKey: String
}

input SetProductSelectionKey {
  key: String
}

input SetProductSelectionVariantExclusion {
  product: ResourceIdentifierInput!
  variantExclusion: ProductVariantExclusionDraft
}

input SetProductSelectionVariantSelection {
  product: ResourceIdentifierInput!
  variantSelection: ProductVariantSelectionDraft
}

input SetProductSku {
  sku: String
  staged: Boolean = true
  variantId: Int!
}

input SetProductTailoringDescription {
  description: [LocalizedStringItemInputType!]
  staged: Boolean = true
}

input SetProductTailoringMetaAttributes {
  metaDescription: [LocalizedStringItemInputType!]
  metaKeywords: [LocalizedStringItemInputType!]
  metaTitle: [LocalizedStringItemInputType!]
  staged: Boolean = true
}

input SetProductTailoringMetaDescription {
  metaDescription: [LocalizedStringItemInputType!]
  staged: Boolean = true
}

input SetProductTailoringMetaKeywords {
  metaKeywords: [LocalizedStringItemInputType!]
  staged: Boolean = true
}

input SetProductTailoringMetaTitle {
  metaTitle: [LocalizedStringItemInputType!]
  staged: Boolean = true
}

input SetProductTailoringName {
  name: [LocalizedStringItemInputType!]
  staged: Boolean = true
}

input SetProductTailoringSlug {
  slug: [LocalizedStringItemInputType!]
  staged: Boolean = true
}

input SetProductTaxCategory {
  taxCategory: ResourceIdentifierInput
}

input SetProductVariantKey {
  key: String
  sku: String
  staged: Boolean = true
  variantId: Int
}

input SetProjectSettingsExternalOAuth {
  externalOAuth: ExternalOAuthDraft
}

"""
BETA: This feature can be subject to change and should be used carefully in production. https://docs.commercetools.com/api/contract#public-beta
"""
input SetProjectSettingsMyBusinessUnitAssociateRoleOnCreation {
  associateRole: ResourceIdentifierInput
}

input SetProjectSettingsShippingRateInputType {
  shippingRateInputType: ShippingRateInputTypeInput
}

input SetQuoteCustomField {
  name: String!
  value: String
}

input SetQuoteCustomType {
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeId: String
  typeKey: String
}

input SetQuoteRequestCustomField {
  name: String!
  value: String
}

input SetQuoteRequestCustomType {
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeId: String
  typeKey: String
}

input SetReviewAuthorName {
  authorName: String
}

input SetReviewCustomField {
  name: String!
  value: String
}

input SetReviewCustomType {
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeId: String
  typeKey: String
}

input SetReviewCustomer {
  customer: ResourceIdentifierInput
}

input SetReviewKey {
  key: String
}

input SetReviewLocale {
  locale: Locale
}

input SetReviewRating {
  rating: Int
}

input SetReviewTarget {
  target: TargetReferenceInput
}

input SetReviewText {
  text: String
}

input SetReviewTitle {
  title: String
}

input SetSearchKeywords {
  searchKeywords: [SearchKeywordInput!]!
  staged: Boolean
}

input SetShippingMethodCustomField {
  name: String!
  value: String
}

input SetShippingMethodCustomType {
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeId: String
  typeKey: String
}

input SetShippingMethodDescription {
  description: String
}

input SetShippingMethodKey {
  key: String
}

input SetShippingMethodLocalizedDescription {
  localizedDescription: [LocalizedStringItemInputType!]
}

input SetShippingMethodLocalizedName {
  localizedName: [LocalizedStringItemInputType!]
}

input SetShippingMethodPredicate {
  predicate: String
}

input SetShoppingListAnonymousId {
  anonymousId: String
}

input SetShoppingListCustomField {
  name: String!
  value: String
}

input SetShoppingListCustomType {
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeId: String
  typeKey: String
}

input SetShoppingListCustomer {
  customer: ResourceIdentifierInput
}

input SetShoppingListDeleteDaysAfterLastModification {
  deleteDaysAfterLastModification: Int
}

input SetShoppingListDescription {
  description: [LocalizedStringItemInputType!]
}

input SetShoppingListKey {
  key: String
}

input SetShoppingListLineItemCustomField {
  lineItemId: String
  lineItemKey: String
  name: String!
  value: String
}

input SetShoppingListLineItemCustomType {
  fields: [CustomFieldInput!]
  lineItemId: String
  lineItemKey: String
  type: ResourceIdentifierInput
  typeId: String
  typeKey: String
}

input SetShoppingListSlug {
  slug: [LocalizedStringItemInputType!]
}

input SetShoppingListStore {
  store: ResourceIdentifierInput
}

input SetShoppingListTextLineItemCustomField {
  name: String!
  textLineItemId: String
  textLineItemKey: String
  value: String
}

input SetShoppingListTextLineItemCustomType {
  fields: [CustomFieldInput!]
  textLineItemId: String
  textLineItemKey: String
  type: ResourceIdentifierInput
  typeId: String
  typeKey: String
}

input SetShoppingListTextLineItemDescription {
  description: [LocalizedStringItemInputType!]
  textLineItemId: String
  textLineItemKey: String
}

input SetStagedOrderBillingAddress {
  address: AddressInput
}

input SetStagedOrderBillingAddressCustomField {
  name: String!
  value: String
}

type SetStagedOrderBillingAddressCustomFieldOutput implements StagedOrderUpdateActionOutput {
  name: String!
  type: String!
  value: Json
}

input SetStagedOrderBillingAddressCustomType {
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeId: String
  typeKey: String
}

type SetStagedOrderBillingAddressCustomTypeOutput implements StagedOrderUpdateActionOutput {
  custom: CustomFieldsCommand!
  type: String!
}

type SetStagedOrderBillingAddressOutput implements StagedOrderUpdateActionOutput {
  address: AddressDraft
  type: String!
}

input SetStagedOrderCountry {
  country: Country
}

type SetStagedOrderCountryOutput implements StagedOrderUpdateActionOutput {
  country: Country
  type: String!
}

input SetStagedOrderCustomField {
  name: String!
  value: String
}

type SetStagedOrderCustomFieldOutput implements StagedOrderUpdateActionOutput {
  name: String!
  type: String!
  value: Json
}

input SetStagedOrderCustomLineItemCustomField {
  customLineItemId: String
  customLineItemKey: String
  name: String!
  value: String
}

type SetStagedOrderCustomLineItemCustomFieldOutput implements StagedOrderUpdateActionOutput {
  customLineItemId: String
  customLineItemKey: String
  name: String!
  type: String!
  value: Json
}

input SetStagedOrderCustomLineItemCustomType {
  customLineItemId: String
  customLineItemKey: String
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeId: String
  typeKey: String
}

type SetStagedOrderCustomLineItemCustomTypeOutput implements StagedOrderUpdateActionOutput {
  custom: CustomFieldsCommand!
  customLineItemId: String
  customLineItemKey: String
  type: String!
}

input SetStagedOrderCustomLineItemShippingDetails {
  customLineItemId: String
  customLineItemKey: String
  shippingDetails: ItemShippingDetailsDraftType
}

type SetStagedOrderCustomLineItemShippingDetailsOutput implements StagedOrderUpdateActionOutput {
  customLineItemId: String
  customLineItemKey: String
  shippingDetails: ItemShippingDetailsDraftOutput
  type: String!
}

input SetStagedOrderCustomLineItemTaxAmount {
  customLineItemId: String
  customLineItemKey: String
  externalTaxAmount: ExternalTaxAmountDraft
  shippingKey: String
}

type SetStagedOrderCustomLineItemTaxAmountOutput implements StagedOrderUpdateActionOutput {
  customLineItemId: String
  customLineItemKey: String
  externalTaxAmount: ExternalTaxAmountDraftOutput
  shippingKey: String
  type: String!
}

input SetStagedOrderCustomLineItemTaxRate {
  customLineItemId: String
  customLineItemKey: String
  externalTaxRate: ExternalTaxRateDraft
  shippingKey: String
}

type SetStagedOrderCustomLineItemTaxRateOutput implements StagedOrderUpdateActionOutput {
  customLineItemId: String
  customLineItemKey: String
  externalTaxRate: ExternalTaxRateDraftOutput
  shippingKey: String
  type: String!
}

input SetStagedOrderCustomShippingMethod {
  externalTaxRate: ExternalTaxRateDraft
  shippingMethodName: String!
  shippingRate: ShippingRateDraft!
  taxCategory: ResourceIdentifierInput
}

type SetStagedOrderCustomShippingMethodOutput implements StagedOrderUpdateActionOutput {
  externalTaxRate: ExternalTaxRateDraftOutput
  shippingMethodName: String!
  shippingRate: ShippingRate!
  taxCategoryResId: ResourceIdentifier
  type: String!
}

input SetStagedOrderCustomType {
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeId: String
  typeKey: String
}

type SetStagedOrderCustomTypeOutput implements StagedOrderUpdateActionOutput {
  custom: CustomFieldsCommand!
  type: String!
}

input SetStagedOrderCustomerEmail {
  email: String
}

type SetStagedOrderCustomerEmailOutput implements StagedOrderUpdateActionOutput {
  email: String
  type: String!
}

input SetStagedOrderCustomerGroup {
  customerGroup: ResourceIdentifierInput
}

type SetStagedOrderCustomerGroupOutput implements StagedOrderUpdateActionOutput {
  customerGroupResId: CustomerGroupReferenceIdentifier
  type: String!
}

input SetStagedOrderCustomerId {
  customerId: String
}

type SetStagedOrderCustomerIdOutput implements StagedOrderUpdateActionOutput {
  customerId: String
  type: String!
}

input SetStagedOrderDeliveryAddress {
  address: AddressInput
  deliveryId: String
  deliveryKey: String
}

input SetStagedOrderDeliveryAddressCustomField {
  deliveryId: String
  deliveryKey: String
  name: String!
  value: String
}

type SetStagedOrderDeliveryAddressCustomFieldOutput implements StagedOrderUpdateActionOutput {
  deliveryId: String
  deliveryKey: String
  name: String!
  type: String!
  value: Json
}

input SetStagedOrderDeliveryAddressCustomType {
  deliveryId: String
  deliveryKey: String
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeId: String
  typeKey: String
}

type SetStagedOrderDeliveryAddressCustomTypeOutput implements StagedOrderUpdateActionOutput {
  custom: CustomFieldsCommand!
  deliveryId: String
  deliveryKey: String
  type: String!
}

type SetStagedOrderDeliveryAddressOutput implements StagedOrderUpdateActionOutput {
  address: AddressDraft
  deliveryId: String
  deliveryKey: String
  type: String!
}

input SetStagedOrderDeliveryCustomField {
  deliveryId: String
  deliveryKey: String
  name: String!
  value: String
}

type SetStagedOrderDeliveryCustomFieldOutput implements StagedOrderUpdateActionOutput {
  deliveryId: String
  deliveryKey: String
  name: String!
  type: String!
  value: Json
}

input SetStagedOrderDeliveryCustomType {
  deliveryId: String
  deliveryKey: String
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeId: String
  typeKey: String
}

type SetStagedOrderDeliveryCustomTypeOutput implements StagedOrderUpdateActionOutput {
  custom: CustomFieldsCommand!
  deliveryId: String
  deliveryKey: String
  type: String!
}

input SetStagedOrderDeliveryItems {
  deliveryId: String
  deliveryKey: String
  items: [DeliveryItemDraftType!]!
}

type SetStagedOrderDeliveryItemsOutput implements StagedOrderUpdateActionOutput {
  deliveryId: String
  deliveryKey: String
  items: [DeliveryItem!]!
  type: String!
}

input SetStagedOrderDirectDiscounts {
  discounts: [DirectDiscountDraft!]!
}

type SetStagedOrderDirectDiscountsOutput implements StagedOrderUpdateActionOutput {
  discounts: [DirectDiscountDraftOutput!]!
  type: String!
}

input SetStagedOrderItemShippingAddressCustomField {
  addressKey: String!
  name: String!
  value: String
}

type SetStagedOrderItemShippingAddressCustomFieldOutput implements StagedOrderUpdateActionOutput {
  addressKey: String!
  name: String!
  type: String!
  value: Json
}

input SetStagedOrderItemShippingAddressCustomType {
  addressKey: String!
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeId: String
  typeKey: String
}

type SetStagedOrderItemShippingAddressCustomTypeOutput implements StagedOrderUpdateActionOutput {
  addressKey: String!
  custom: CustomFieldsCommand!
  type: String!
}

input SetStagedOrderLineItemCustomField {
  lineItemId: String
  lineItemKey: String
  name: String!
  value: String
}

type SetStagedOrderLineItemCustomFieldOutput implements StagedOrderUpdateActionOutput {
  lineItemId: String
  lineItemKey: String
  name: String!
  type: String!
  value: Json
}

input SetStagedOrderLineItemCustomType {
  fields: [CustomFieldInput!]
  lineItemId: String
  lineItemKey: String
  type: ResourceIdentifierInput
  typeId: String
  typeKey: String
}

type SetStagedOrderLineItemCustomTypeOutput implements StagedOrderUpdateActionOutput {
  custom: CustomFieldsCommand!
  lineItemId: String
  lineItemKey: String
  type: String!
}

input SetStagedOrderLineItemDistributionChannel {
  distributionChannel: ResourceIdentifierInput
  lineItemId: String
  lineItemKey: String
}

type SetStagedOrderLineItemDistributionChannelOutput implements StagedOrderUpdateActionOutput {
  distributionChannelResId: ChannelReferenceIdentifier
  lineItemId: String
  lineItemKey: String
  type: String!
}

input SetStagedOrderLineItemPrice {
  externalPrice: BaseMoneyInput
  lineItemId: String
  lineItemKey: String
}

type SetStagedOrderLineItemPriceOutput implements StagedOrderUpdateActionOutput {
  externalPrice: BaseMoney
  lineItemId: String
  lineItemKey: String
  type: String!
}

input SetStagedOrderLineItemShippingDetails {
  lineItemId: String
  lineItemKey: String
  shippingDetails: ItemShippingDetailsDraftType
}

type SetStagedOrderLineItemShippingDetailsOutput implements StagedOrderUpdateActionOutput {
  lineItemId: String
  lineItemKey: String
  shippingDetails: ItemShippingDetailsDraftOutput
  type: String!
}

input SetStagedOrderLineItemTaxAmount {
  externalTaxAmount: ExternalTaxAmountDraft
  lineItemId: String
  lineItemKey: String
  shippingKey: String
}

type SetStagedOrderLineItemTaxAmountOutput implements StagedOrderUpdateActionOutput {
  externalTaxAmount: ExternalTaxAmountDraftOutput
  lineItemId: String
  lineItemKey: String
  shippingKey: String
  type: String!
}

input SetStagedOrderLineItemTaxRate {
  externalTaxRate: ExternalTaxRateDraft
  lineItemId: String
  lineItemKey: String
  shippingKey: String
}

type SetStagedOrderLineItemTaxRateOutput implements StagedOrderUpdateActionOutput {
  externalTaxRate: ExternalTaxRateDraftOutput
  lineItemId: String
  lineItemKey: String
  shippingKey: String
  type: String!
}

input SetStagedOrderLineItemTotalPrice {
  externalTotalPrice: ExternalLineItemTotalPriceDraft
  lineItemId: String
  lineItemKey: String
}

type SetStagedOrderLineItemTotalPriceOutput implements StagedOrderUpdateActionOutput {
  externalTotalPrice: ExternalLineItemTotalPrice
  lineItemId: String
  lineItemKey: String
  type: String!
}

input SetStagedOrderLocale {
  locale: Locale
}

type SetStagedOrderLocaleOutput implements StagedOrderUpdateActionOutput {
  locale: Locale
  type: String!
}

input SetStagedOrderOrderNumber {
  orderNumber: String
}

type SetStagedOrderOrderNumberOutput implements StagedOrderUpdateActionOutput {
  orderNumber: String
  type: String!
}

input SetStagedOrderOrderTotalTax {
  externalTaxPortions: [TaxPortionDraft!] = []
  externalTotalGross: MoneyInput
}

type SetStagedOrderOrderTotalTaxOutput implements StagedOrderUpdateActionOutput {
  externalTaxPortions: [TaxPortion!]!
  externalTotalGross: Money
  type: String!
}

input SetStagedOrderParcelCustomField {
  name: String!
  parcelId: String
  parcelKey: String
  value: String
}

type SetStagedOrderParcelCustomFieldOutput implements StagedOrderUpdateActionOutput {
  name: String!
  parcelId: String
  parcelKey: String
  type: String!
  value: Json
}

input SetStagedOrderParcelCustomType {
  fields: [CustomFieldInput!]
  parcelId: String
  parcelKey: String
  type: ResourceIdentifierInput
  typeId: String
  typeKey: String
}

type SetStagedOrderParcelCustomTypeOutput implements StagedOrderUpdateActionOutput {
  custom: CustomFieldsCommand!
  parcelId: String
  parcelKey: String
  type: String!
}

input SetStagedOrderParcelItems {
  items: [DeliveryItemDraftType!]!
  parcelId: String
  parcelKey: String
}

type SetStagedOrderParcelItemsOutput implements StagedOrderUpdateActionOutput {
  items: [DeliveryItem!]!
  parcelId: String
  parcelKey: String
  type: String!
}

input SetStagedOrderParcelMeasurements {
  measurements: ParcelMeasurementsDraftType
  parcelId: String
  parcelKey: String
}

type SetStagedOrderParcelMeasurementsOutput implements StagedOrderUpdateActionOutput {
  measurements: ParcelMeasurements
  parcelId: String
  parcelKey: String
  type: String!
}

input SetStagedOrderParcelTrackingData {
  parcelId: String
  parcelKey: String
  trackingData: TrackingDataDraftType
}

type SetStagedOrderParcelTrackingDataOutput implements StagedOrderUpdateActionOutput {
  parcelId: String
  parcelKey: String
  trackingData: TrackingData
  type: String!
}

input SetStagedOrderPurchaseOrderNumber {
  purchaseOrderNumber: String
}

type SetStagedOrderPurchaseOrderNumberOutput implements StagedOrderUpdateActionOutput {
  purchaseOrderNumber: String
  type: String!
}

input SetStagedOrderReturnInfo {
  items: [ReturnInfoDraftType!] = []
}

type SetStagedOrderReturnInfoOutput implements StagedOrderUpdateActionOutput {
  items: [ReturnInfoDraftTypeOutput!]!
  type: String!
}

input SetStagedOrderReturnItemCustomField {
  name: String!
  returnItemId: String
  returnItemKey: String
  value: String
}

type SetStagedOrderReturnItemCustomFieldOutput implements StagedOrderUpdateActionOutput {
  name: String!
  returnItemId: String
  returnItemKey: String
  type: String!
  value: Json
}

input SetStagedOrderReturnItemCustomType {
  fields: [CustomFieldInput!]
  returnItemId: String
  returnItemKey: String
  type: ResourceIdentifierInput
  typeId: String
  typeKey: String
}

type SetStagedOrderReturnItemCustomTypeOutput implements StagedOrderUpdateActionOutput {
  custom: CustomFieldsCommand!
  returnItemId: String
  returnItemKey: String
  type: String!
}

input SetStagedOrderReturnPaymentState {
  paymentState: ReturnPaymentState!
  returnItemId: String
  returnItemKey: String
}

type SetStagedOrderReturnPaymentStateOutput implements StagedOrderUpdateActionOutput {
  paymentState: ReturnPaymentState!
  returnItemId: String
  returnItemKey: String
  type: String!
}

input SetStagedOrderReturnShipmentState {
  returnItemId: String
  returnItemKey: String
  shipmentState: ReturnShipmentState!
}

type SetStagedOrderReturnShipmentStateOutput implements StagedOrderUpdateActionOutput {
  returnItemId: String
  returnItemKey: String
  shipmentState: ReturnShipmentState!
  type: String!
}

input SetStagedOrderShippingAddress {
  address: AddressInput
}

input SetStagedOrderShippingAddressAndCustomShippingMethod {
  address: AddressInput!
  externalTaxRate: ExternalTaxRateDraft
  shippingMethodName: String!
  shippingRate: ShippingRateDraft!
  taxCategory: ResourceIdentifierInput
}

type SetStagedOrderShippingAddressAndCustomShippingMethodOutput implements StagedOrderUpdateActionOutput {
  address: AddressDraft!
  externalTaxRate: ExternalTaxRateDraftOutput
  shippingMethodName: String!
  shippingRate: ShippingRate!
  taxCategoryResId: ResourceIdentifier
  type: String!
}

input SetStagedOrderShippingAddressAndShippingMethod {
  address: AddressInput!
  externalTaxRate: ExternalTaxRateDraft
  shippingMethod: ResourceIdentifierInput
}

type SetStagedOrderShippingAddressAndShippingMethodOutput implements StagedOrderUpdateActionOutput {
  address: AddressDraft!
  externalTaxRate: ExternalTaxRateDraftOutput
  shippingMethodResId: ResourceIdentifier
  type: String!
}

input SetStagedOrderShippingAddressCustomField {
  name: String!
  value: String
}

type SetStagedOrderShippingAddressCustomFieldOutput implements StagedOrderUpdateActionOutput {
  name: String!
  type: String!
  value: Json
}

input SetStagedOrderShippingAddressCustomType {
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeId: String
  typeKey: String
}

type SetStagedOrderShippingAddressCustomTypeOutput implements StagedOrderUpdateActionOutput {
  custom: CustomFieldsCommand!
  type: String!
}

type SetStagedOrderShippingAddressOutput implements StagedOrderUpdateActionOutput {
  address: AddressDraft
  type: String!
}

input SetStagedOrderShippingCustomField {
  name: String!
  shippingKey: String
  value: String
}

type SetStagedOrderShippingCustomFieldOutput implements StagedOrderUpdateActionOutput {
  name: String!
  shippingKey: String
  type: String!
  value: Json
}

input SetStagedOrderShippingCustomType {
  fields: [CustomFieldInput!]
  shippingKey: String
  type: ResourceIdentifierInput
  typeId: String
  typeKey: String
}

type SetStagedOrderShippingCustomTypeOutput implements StagedOrderUpdateActionOutput {
  custom: CustomFieldsCommand!
  shippingKey: String
  type: String!
}

input SetStagedOrderShippingMethod {
  externalTaxRate: ExternalTaxRateDraft
  shippingMethod: ResourceIdentifierInput
}

type SetStagedOrderShippingMethodOutput implements StagedOrderUpdateActionOutput {
  externalTaxRate: ExternalTaxRateDraftOutput
  shippingMethodResId: ResourceIdentifier
  type: String!
}

input SetStagedOrderShippingMethodTaxAmount {
  externalTaxAmount: ExternalTaxAmountDraft
  shippingKey: String
}

type SetStagedOrderShippingMethodTaxAmountOutput implements StagedOrderUpdateActionOutput {
  externalTaxAmount: ExternalTaxAmountDraftOutput
  shippingKey: String
  type: String!
}

input SetStagedOrderShippingMethodTaxRate {
  externalTaxRate: ExternalTaxRateDraft
  shippingKey: String
}

type SetStagedOrderShippingMethodTaxRateOutput implements StagedOrderUpdateActionOutput {
  externalTaxRate: ExternalTaxRateDraftOutput
  shippingKey: String
  type: String!
}

input SetStagedOrderShippingRateInput {
  shippingRateInput: ShippingRateInputDraft
}

type SetStagedOrderShippingRateInputOutput implements StagedOrderUpdateActionOutput {
  shippingRateInput: ShippingRateInputDraftOutput
  type: String!
}

input SetStagedOrderStore {
  store: ResourceIdentifierInput
}

type SetStagedOrderStoreOutput implements StagedOrderUpdateActionOutput {
  storeResId: ResourceIdentifier
  type: String!
}

input SetStagedQuoteCustomField {
  name: String!
  value: String
}

input SetStagedQuoteCustomType {
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeId: String
  typeKey: String
}

input SetStagedQuoteSellerComment {
  sellerComment: String
}

input SetStagedQuoteValidTo {
  validTo: DateTime
}

input SetStandalonePriceCustomFields {
  name: String!
  value: String
}

input SetStandalonePriceDiscountedPrice {
  discounted: DiscountedProductPriceValueInput
}

input SetStandalonePriceKey {
  key: String
}

input SetStandalonePriceTiers {
  tiers: [ProductPriceTierInput!]!
}

input SetStandalonePriceValidFrom {
  validFrom: DateTime
}

input SetStandalonePriceValidFromAndUntil {
  validFrom: DateTime
  validUntil: DateTime
}

input SetStandalonePriceValidUntil {
  validUntil: DateTime
}

input SetStateDescription {
  description: [LocalizedStringItemInputType!]
}

input SetStateName {
  name: [LocalizedStringItemInputType!]
}

input SetStateRoles {
  roles: [StateRole!]!
}

input SetStateTransitions {
  transitions: [ResourceIdentifierInput!]
}

input SetStoreCountries {
  countries: [StoreCountryInput!]
}

input SetStoreCustomField {
  name: String!
  value: String
}

input SetStoreCustomType {
  fields: [CustomFieldInput!]
  type: ResourceIdentifierInput
  typeId: String
  typeKey: String
}

input SetStoreDistributionChannels {
  distributionChannels: [ResourceIdentifierInput!]
}

input SetStoreLanguages {
  languages: [Locale!]
}

input SetStoreName {
  name: [LocalizedStringItemInputType!]
}

input SetStoreProductSelections {
  productSelections: [ProductSelectionSettingInActionInput!]
}

input SetStoreSupplyChannels {
  supplyChannels: [ResourceIdentifierInput!]
}

input SetSubscriptionChanges {
  changes: [ChangeSubscriptionInput!]!
}

input SetSubscriptionKey {
  key: String
}

input SetSubscriptionMessages {
  messages: [MessageSubscriptionInput!]!
}

input SetTaxCategoryKey {
  key: String
}

type SetType implements FieldType {
  elementType: FieldType!
  name: String!
}

input SetTypeDescription {
  description: [LocalizedStringItemInputType!]
}

input SetZoneDescription {
  description: String
}

input SetZoneKey {
  key: String
}

enum ShipmentState {
  Backorder
  Delayed
  Delivered
  Partial
  Pending
  Ready
  Shipped
}

type Shipping {
  shippingAddress: Address
  shippingCustomFields: CustomFieldsType
  shippingInfo: ShippingInfo
  shippingKey: String
  shippingRateInput: ShippingRateInput
}

input ShippingDraft {
  custom: CustomFieldsDraft
  deliveries: [DeliveryDraft!]
  externalTaxRate: ExternalTaxRateDraft
  key: String!
  shippingAddress: AddressInput!
  shippingMethod: ResourceIdentifierInput
  shippingRateInput: ShippingRateInputDraft
}

type ShippingInfo {
  deliveries: [Delivery!]!
  discountedPrice: DiscountedLineItemPrice
  price: Money!
  shippingMethod: ShippingMethod
  shippingMethodName: String!
  shippingMethodRef: Reference
  shippingMethodState: ShippingMethodState!
  shippingRate: ShippingRate!
  taxCategory: TaxCategory
  taxCategoryRef: Reference
  taxRate: TaxRate
  taxedPrice: TaxedItemPrice
}

input ShippingInfoImportDraft {
  deliveries: [DeliveryDraft!]! = []
  discountedPrice: DiscountedLineItemPriceDraft
  price: MoneyInput!
  shippingMethod: ResourceIdentifierInput
  shippingMethodName: String!
  shippingMethodState: ShippingMethodState! = MatchesCart
  shippingRate: ShippingRateDraft!
  taxCategory: ResourceIdentifierInput
  taxRate: TaxRateInput
}

type ShippingMethod implements ReferenceExpandable & Versioned {
  createdAt: DateTime!
  createdBy: Initiator
  custom: CustomFieldsType
  id: String!
  isDefault: Boolean!
  key: String
  lastModifiedAt: DateTime!
  lastModifiedBy: Initiator
  localizedDescription(
    """
    List of languages the client is able to understand, and which locale variant is preferred.
    """
    acceptLanguage: [Locale!]

    """
    String is defined for different locales. This argument specifies the desired locale.
    """
    locale: Locale
  ): String
  localizedDescriptionAllLocales: [LocalizedString!]
  localizedName(
    """
    List of languages the client is able to understand, and which locale variant is preferred.
    """
    acceptLanguage: [Locale!]

    """
    String is defined for different locales. This argument specifies the desired locale.
    """
    locale: Locale
  ): String
  localizedNameAllLocales: [LocalizedString!]
  name: String!
  predicate: String
  taxCategory: TaxCategory
  taxCategoryRef: Reference
  version: Long!
  zoneRates: [ZoneRate!]!
}

input ShippingMethodDraft {
  custom: CustomFieldsDraft

  """
  The usage of parameter 'description' is deprecated in favor of using 'localizedDescription'
  """
  description: String
  isDefault: Boolean!
  key: String
  localizedDescription: [LocalizedStringItemInputType!]
  localizedName: [LocalizedStringItemInputType!]
  name: String!
  predicate: String
  taxCategory: ResourceIdentifierInput!
  zoneRates: [ZoneRateDraft!] = []
}

type ShippingMethodLimitWithCurrent implements LimitWithCurrent {
  current: Long!
  limit: Long
}

type ShippingMethodLimitsProjection {
  total: ShippingMethodLimitWithCurrent!
}

type ShippingMethodQueryResult {
  count: Int!
  exists: Boolean!
  offset: Int!
  results: [ShippingMethod!]!
  total: Long!
}

enum ShippingMethodState {
  """
  The ShippingMethod predicate does not match the cart. Ordering this cart will fail with error ShippingMethodDoesNotMatchCart
  """
  DoesNotMatchCart

  """
  Either there is no predicate defined for the ShippingMethod or the given predicate matches the cart
  """
  MatchesCart
}

input ShippingMethodUpdateAction {
  addShippingRate: AddShippingMethodShippingRate
  addZone: AddShippingMethodZone
  changeIsDefault: ChangeShippingMethodIsDefault
  changeName: ChangeShippingMethodName
  changeTaxCategory: ChangeShippingMethodTaxCategory
  removeShippingRate: RemoveShippingMethodShippingRate
  removeZone: RemoveShippingMethodZone
  setCustomField: SetShippingMethodCustomField
  setCustomType: SetShippingMethodCustomType

  """This action is deprecated in favor of using 'setLocalizedDescription'"""
  setDescription: SetShippingMethodDescription
  setKey: SetShippingMethodKey
  setLocalizedDescription: SetShippingMethodLocalizedDescription
  setLocalizedName: SetShippingMethodLocalizedName
  setPredicate: SetShippingMethodPredicate
}

"""A field to retrieve available shipping methods for a cart."""
interface ShippingMethodsByCartInterface {
  shippingMethodsByCart(id: String!): [ShippingMethod!]!
}

enum ShippingMode {
  """
  Allows multiple shipping methods for the cart with their respective shipping addresses
  """
  Multiple

  """Allows only one shipping method and shipping address for the cart"""
  Single
}

"""Shipping Rate"""
type ShippingRate {
  freeAbove: Money
  isMatching: Boolean
  price: Money!
  tiers: [ShippingRatePriceTier!]!
}

type ShippingRateCartClassificationPriceTier implements ShippingRatePriceTier {
  isMatching: Boolean
  price: Money!
  type: String!
  value: String!
}

type ShippingRateCartScorePriceTier implements ShippingRatePriceTier {
  isMatching: Boolean
  price: Money
  priceFunction: PriceFunction
  score: Int!
  type: String!
}

type ShippingRateCartValuePriceTier implements ShippingRatePriceTier {
  isMatching: Boolean
  minimumCentAmount: Int!
  price: Money!
  type: String!
}

input ShippingRateDraft {
  freeAbove: MoneyDraft
  price: MoneyDraft!
  tiers: [ShippingRatePriceTierDraft!] = []
}

interface ShippingRateInput {
  type: String!
}

input ShippingRateInputDraft {
  Classification: ClassificationShippingRateInputDraft
  Score: ScoreShippingRateInputDraft
}

interface ShippingRateInputDraftOutput {
  type: String!
}

type ShippingRateInputLocalizedEnumValue {
  key: String!
  label(
    """
    List of languages the client is able to understand, and which locale variant is preferred.
    """
    acceptLanguage: [Locale!]

    """
    String is defined for different locales. This argument specifies the desired locale.
    """
    locale: Locale
  ): String
  labelAllLocales: [LocalizedString!]!
}

interface ShippingRateInputType {
  type: String!
}

input ShippingRateInputTypeInput {
  CartClassification: CartClassificationInput
  CartScore: CartScoreInput
  CartValue: CartValueInput
}

interface ShippingRatePriceTier {
  type: String!
}

input ShippingRatePriceTierCartClassificationDraft {
  price: MoneyDraft!
  value: String!
}

input ShippingRatePriceTierCartScoreDraft {
  price: MoneyDraft
  priceFunction: PriceFunctionDraft
  score: Int!
}

input ShippingRatePriceTierCartValueDraft {
  minimumCentAmount: Int!
  price: MoneyDraft!
}

input ShippingRatePriceTierDraft {
  CartClassification: ShippingRatePriceTierCartClassificationDraft
  CartScore: ShippingRatePriceTierCartScoreDraft
  CartValue: ShippingRatePriceTierCartValueDraft
}

type ShippingTarget implements CartDiscountTarget {
  type: String!
}

input ShippingTargetDraft {
  addressKey: String!
  quantity: Long!
  shippingMethodKey: String
}

input ShippingTargetDraftType {
  addressKey: String!
  quantity: Long!
  shippingMethodKey: String
}

input ShippingTargetInput {
  dummy: String
}

type ShoppingList implements ReferenceExpandable & Versioned {
  anonymousId: String
  createdAt: DateTime!
  createdBy: Initiator
  custom: CustomFieldsType
  customer: Customer
  customerRef: Reference
  deleteDaysAfterLastModification: Int
  description(
    """
    List of languages the client is able to understand, and which locale variant is preferred.
    """
    acceptLanguage: [Locale!]

    """
    String is defined for different locales. This argument specifies the desired locale.
    """
    locale: Locale
  ): String
  descriptionAllLocales: [LocalizedString!]
  id: String!
  key: String
  lastModifiedAt: DateTime!
  lastModifiedBy: Initiator
  lineItems: [ShoppingListLineItem!]!
  name(
    """
    List of languages the client is able to understand, and which locale variant is preferred.
    """
    acceptLanguage: [Locale!]

    """
    String is defined for different locales. This argument specifies the desired locale.
    """
    locale: Locale
  ): String
  nameAllLocales: [LocalizedString!]!
  slug(
    """
    List of languages the client is able to understand, and which locale variant is preferred.
    """
    acceptLanguage: [Locale!]

    """
    String is defined for different locales. This argument specifies the desired locale.
    """
    locale: Locale
  ): String
  slugAllLocales: [LocalizedString!]
  store: Store
  storeRef: KeyReference
  textLineItems: [TextLineItem!]!
  version: Long!
}

input ShoppingListDraft {
  anonymousId: String
  custom: CustomFieldsDraft
  customer: ResourceIdentifierInput
  deleteDaysAfterLastModification: Int
  description: [LocalizedStringItemInputType!]
  key: String
  lineItems: [ShoppingListLineItemDraft!] = []
  name: [LocalizedStringItemInputType!]!
  slug: [LocalizedStringItemInputType!]
  textLineItems: [TextLineItemDraft!] = []
}

type ShoppingListLimitWithCurrent implements LimitWithCurrent {
  current: Long!
  limit: Long
}

type ShoppingListLimitsProjection {
  lineItems: Limit!
  textLineItems: Limit!
  total: ShoppingListLimitWithCurrent!
}

type ShoppingListLineItem {
  addedAt: DateTime!
  custom: CustomFieldsType
  deactivatedAt: DateTime
  id: String!
  key: String
  name(
    """
    List of languages the client is able to understand, and which locale variant is preferred.
    """
    acceptLanguage: [Locale!]

    """
    String is defined for different locales. This argument specifies the desired locale.
    """
    locale: Locale
  ): String
  nameAllLocales: [LocalizedString!]!
  productId: String!
  productSlug(
    """
    List of languages the client is able to understand, and which locale variant is preferred.
    """
    acceptLanguage: [Locale!]

    """
    String is defined for different locales. This argument specifies the desired locale.
    """
    locale: Locale
  ): String
  productSlugAllLocales: [LocalizedString!]
  productType: ProductTypeDefinition!
  productTypeRef: Reference!
  quantity: Int!
  variant: ProductVariant
  variantId: Int
}

input ShoppingListLineItemDraft {
  addedAt: DateTime
  custom: CustomFieldsDraft
  key: String
  productId: String
  quantity: Int = 1
  sku: String
  variantId: Int
}

"""
Fields to access shopping lists. Includes direct access to a single list and searching for shopping lists.
"""
interface ShoppingListQueryInterface {
  shoppingList(
    """Queries with specified ID"""
    id: String

    """Queries with specified key"""
    key: String
  ): ShoppingList
  shoppingLists(limit: Int, offset: Int, sort: [String!], where: String): ShoppingListQueryResult!
}

type ShoppingListQueryResult {
  count: Int!
  exists: Boolean!
  offset: Int!
  results: [ShoppingList!]!
  total: Long!
}

input ShoppingListUpdateAction {
  addLineItem: AddShoppingListLineItem
  addTextLineItem: AddShoppingListTextLineItem
  changeLineItemQuantity: ChangeShoppingListLineItemQuantity
  changeLineItemsOrder: ChangeShoppingListLineItemsOrder
  changeName: ChangeShoppingListName
  changeTextLineItemName: ChangeShoppingListTextLineItemName
  changeTextLineItemQuantity: ChangeShoppingListTextLineItemQuantity
  changeTextLineItemsOrder: ChangeShoppingListTextLineItemsOrder
  removeLineItem: RemoveShoppingListLineItem
  removeTextLineItem: RemoveShoppingListTextLineItem
  setAnonymousId: SetShoppingListAnonymousId
  setCustomField: SetShoppingListCustomField
  setCustomType: SetShoppingListCustomType
  setCustomer: SetShoppingListCustomer
  setDeleteDaysAfterLastModification: SetShoppingListDeleteDaysAfterLastModification
  setDescription: SetShoppingListDescription
  setKey: SetShoppingListKey
  setLineItemCustomField: SetShoppingListLineItemCustomField
  setLineItemCustomType: SetShoppingListLineItemCustomType
  setSlug: SetShoppingListSlug
  setStore: SetShoppingListStore
  setTextLineItemCustomField: SetShoppingListTextLineItemCustomField
  setTextLineItemCustomType: SetShoppingListTextLineItemCustomType
  setTextLineItemDescription: SetShoppingListTextLineItemDescription
}

type ShoppingListsConfiguration {
  deleteDaysAfterLastModification: Int
}

input ShoppingListsConfigurationInput {
  deleteDaysAfterLastModification: Int
}

input SignUpInMyBusinessUnitDraft {
  associateRoleAssignments: [AssociateRoleAssignmentDraft!]!
  businessUnit: ResourceIdentifierInput!
  customer: CustomerSignUpDraft!
  version: Long!
}

input SimpleAttributeTypeDraft {
  dummy: String
}

input SimpleFieldTypeDraft {
  dummy: String
}

"""Describes how this discount interacts with other discounts"""
enum StackingMode {
  """
  Default. Continue applying other matching discounts after applying this one.
  """
  Stacking

  """Don’t apply any more matching discounts after this one."""
  StopAfterThisDiscount
}

input StagedOrderUpdateAction {
  addCustomLineItem: AddStagedOrderCustomLineItem
  addDelivery: AddStagedOrderDelivery
  addDiscountCode: AddStagedOrderDiscountCode
  addItemShippingAddress: AddStagedOrderItemShippingAddress
  addLineItem: AddStagedOrderLineItem
  addParcelToDelivery: AddStagedOrderParcelToDelivery
  addPayment: AddStagedOrderPayment
  addReturnInfo: AddStagedOrderReturnInfo
  addShoppingList: AddStagedOrderShoppingList
  changeCustomLineItemMoney: ChangeStagedOrderCustomLineItemMoney
  changeCustomLineItemQuantity: ChangeStagedOrderCustomLineItemQuantity
  changeLineItemQuantity: ChangeStagedOrderLineItemQuantity
  changeOrderState: ChangeStagedOrderOrderState
  changePaymentState: ChangeStagedOrderPaymentState
  changeShipmentState: ChangeStagedOrderShipmentState
  changeTaxCalculationMode: ChangeStagedOrderTaxCalculationMode
  changeTaxMode: ChangeStagedOrderTaxMode
  changeTaxRoundingMode: ChangeStagedOrderTaxRoundingMode
  importCustomLineItemState: ImportStagedOrderCustomLineItemState
  importLineItemState: ImportStagedOrderLineItemState
  recalculate: RecalculateStagedOrder
  removeCustomLineItem: RemoveStagedOrderCustomLineItem
  removeDelivery: RemoveStagedOrderDelivery
  removeDiscountCode: RemoveStagedOrderDiscountCode
  removeItemShippingAddress: RemoveStagedOrderItemShippingAddress
  removeLineItem: RemoveStagedOrderLineItem
  removeParcelFromDelivery: RemoveStagedOrderParcelFromDelivery
  removePayment: RemoveStagedOrderPayment
  setBillingAddress: SetStagedOrderBillingAddress
  setBillingAddressCustomField: SetStagedOrderBillingAddressCustomField
  setBillingAddressCustomType: SetStagedOrderBillingAddressCustomType
  setCountry: SetStagedOrderCountry
  setCustomField: SetStagedOrderCustomField
  setCustomLineItemCustomField: SetStagedOrderCustomLineItemCustomField
  setCustomLineItemCustomType: SetStagedOrderCustomLineItemCustomType
  setCustomLineItemShippingDetails: SetStagedOrderCustomLineItemShippingDetails
  setCustomLineItemTaxAmount: SetStagedOrderCustomLineItemTaxAmount
  setCustomLineItemTaxRate: SetStagedOrderCustomLineItemTaxRate
  setCustomShippingMethod: SetStagedOrderCustomShippingMethod
  setCustomType: SetStagedOrderCustomType
  setCustomerEmail: SetStagedOrderCustomerEmail
  setCustomerGroup: SetStagedOrderCustomerGroup
  setCustomerId: SetStagedOrderCustomerId
  setDeliveryAddress: SetStagedOrderDeliveryAddress
  setDeliveryAddressCustomField: SetStagedOrderDeliveryAddressCustomField
  setDeliveryAddressCustomType: SetStagedOrderDeliveryAddressCustomType
  setDeliveryCustomField: SetStagedOrderDeliveryCustomField
  setDeliveryCustomType: SetStagedOrderDeliveryCustomType
  setDeliveryItems: SetStagedOrderDeliveryItems
  setDirectDiscounts: SetStagedOrderDirectDiscounts
  setItemShippingAddressCustomField: SetStagedOrderItemShippingAddressCustomField
  setItemShippingAddressCustomType: SetStagedOrderItemShippingAddressCustomType
  setLineItemCustomField: SetStagedOrderLineItemCustomField
  setLineItemCustomType: SetStagedOrderLineItemCustomType
  setLineItemDistributionChannel: SetStagedOrderLineItemDistributionChannel
  setLineItemPrice: SetStagedOrderLineItemPrice
  setLineItemShippingDetails: SetStagedOrderLineItemShippingDetails
  setLineItemTaxAmount: SetStagedOrderLineItemTaxAmount
  setLineItemTaxRate: SetStagedOrderLineItemTaxRate
  setLineItemTotalPrice: SetStagedOrderLineItemTotalPrice
  setLocale: SetStagedOrderLocale
  setOrderNumber: SetStagedOrderOrderNumber
  setOrderTotalTax: SetStagedOrderOrderTotalTax
  setParcelCustomField: SetStagedOrderParcelCustomField
  setParcelCustomType: SetStagedOrderParcelCustomType
  setParcelItems: SetStagedOrderParcelItems
  setParcelMeasurements: SetStagedOrderParcelMeasurements
  setParcelTrackingData: SetStagedOrderParcelTrackingData
  setPurchaseOrderNumber: SetStagedOrderPurchaseOrderNumber
  setReturnInfo: SetStagedOrderReturnInfo
  setReturnItemCustomField: SetStagedOrderReturnItemCustomField
  setReturnItemCustomType: SetStagedOrderReturnItemCustomType
  setReturnPaymentState: SetStagedOrderReturnPaymentState
  setReturnShipmentState: SetStagedOrderReturnShipmentState
  setShippingAddress: SetStagedOrderShippingAddress
  setShippingAddressAndCustomShippingMethod: SetStagedOrderShippingAddressAndCustomShippingMethod
  setShippingAddressAndShippingMethod: SetStagedOrderShippingAddressAndShippingMethod
  setShippingAddressCustomField: SetStagedOrderShippingAddressCustomField
  setShippingAddressCustomType: SetStagedOrderShippingAddressCustomType
  setShippingCustomField: SetStagedOrderShippingCustomField
  setShippingCustomType: SetStagedOrderShippingCustomType
  setShippingMethod: SetStagedOrderShippingMethod
  setShippingMethodTaxAmount: SetStagedOrderShippingMethodTaxAmount
  setShippingMethodTaxRate: SetStagedOrderShippingMethodTaxRate
  setShippingRateInput: SetStagedOrderShippingRateInput
  setStore: SetStagedOrderStore
  transitionCustomLineItemState: TransitionStagedOrderCustomLineItemState
  transitionLineItemState: TransitionStagedOrderLineItemState
  transitionState: TransitionStagedOrderState
  updateItemShippingAddress: UpdateStagedOrderItemShippingAddress
  updateSyncInfo: UpdateStagedOrderSyncInfo
}

interface StagedOrderUpdateActionOutput {
  type: String!
}

input StagedPriceDraft {
  value: BaseMoneyInput!
}

type StagedQuote implements Versioned {
  businessUnit: BusinessUnit
  businessUnitRef: KeyReference
  createdAt: DateTime!
  createdBy: Initiator
  custom: CustomFieldsType
  customer: Customer
  customerRef: Reference
  id: String!
  key: String
  lastModifiedAt: DateTime!
  lastModifiedBy: Initiator
  purchaseOrderNumber: String
  quotationCart: Cart
  quotationCartRef: Reference!
  quoteRequest: QuoteRequest
  quoteRequestRef: Reference!
  sellerComment: String
  stagedQuoteState: StagedQuoteState!
  state: State
  stateRef: Reference
  validTo: DateTime
  version: Long!
}

type StagedQuoteCreated implements MessagePayload {
  stagedQuote: StagedQuote!
  type: String!
}

type StagedQuoteDeleted implements MessagePayload {
  type: String!
}

input StagedQuoteDraft {
  custom: CustomFieldsDraft
  key: String
  quoteRequest: ResourceIdentifierInput
  quoteRequestStateToAccepted: Boolean = false
  quoteRequestVersion: Long
  state: ReferenceInput
}

type StagedQuoteQueryResult {
  count: Int!
  exists: Boolean!
  offset: Int!
  results: [StagedQuote!]!
  total: Long!
}

type StagedQuoteSellerCommentSet implements MessagePayload {
  sellerComment: String
  type: String!
}

enum StagedQuoteState {
  Closed
  InProgress
  Sent
}

type StagedQuoteStateChanged implements MessagePayload {
  oldStagedQuoteState: StagedQuoteState!
  stagedQuoteState: StagedQuoteState!
  type: String!
}

type StagedQuoteStateTransition implements MessagePayload {
  force: Boolean!
  oldState: State
  oldStateRef: Reference
  state: State
  stateRef: Reference!
  type: String!
}

input StagedQuoteUpdateAction {
  changeStagedQuoteState: ChangeStagedQuoteState
  setCustomField: SetStagedQuoteCustomField
  setCustomType: SetStagedQuoteCustomType
  setSellerComment: SetStagedQuoteSellerComment
  setValidTo: SetStagedQuoteValidTo
  transitionState: TransitionStagedQuoteState
}

type StagedQuoteValidToSet implements MessagePayload {
  type: String!
  validTo: DateTime
}

type StagedStandalonePrice {
  discounted: DiscountedProductPriceValue
  value: BaseMoney!
}

"""
StandalonePrices are managed and queried through the StandalonePrices API
and associated to a ProductVariant through the sku field.
"""
type StandalonePrice implements Versioned {
  active: Boolean!
  channel: Channel
  channelRef: Reference
  country: Country
  createdAt: DateTime!
  createdBy: Initiator
  custom: CustomFieldsType
  customerGroup: CustomerGroup
  customerGroupRef: Reference
  discounted: DiscountedProductPriceValue
  expiresAt: DateTime
  id: String!
  key: String
  lastModifiedAt: DateTime!
  lastModifiedBy: Initiator
  sku: String!
  staged: StagedStandalonePrice
  tiers: [ProductPriceTier!]
  validFrom: DateTime
  validUntil: DateTime
  value: BaseMoney!
  version: Long!
}

type StandalonePriceActiveChanged implements MessagePayload {
  active: Boolean!
  oldActive: Boolean!
  type: String!
}

type StandalonePriceCreated implements MessagePayload {
  standalonePrice: StandalonePrice!
  type: String!
}

type StandalonePriceDeleted implements MessagePayload {
  sku: String
  type: String!
}

type StandalonePriceDiscountSet implements MessagePayload {
  discounted: DiscountedProductPriceValue
  type: String!
}

type StandalonePriceExpiresAtSet implements MessagePayload {
  expiresAt: DateTime
  type: String!
}

type StandalonePriceExternalDiscountSet implements MessagePayload {
  discounted: DiscountedProductPriceValue
  type: String!
}

type StandalonePriceKeySet implements MessagePayload {
  key: String
  oldKey: String
  type: String!
}

type StandalonePriceQueryResult {
  count: Int!
  exists: Boolean!
  offset: Int!
  results: [StandalonePrice!]!
  total: Long!
}

type StandalonePriceStagedChangesApplied implements MessagePayload {
  stagedChanges: StagedStandalonePrice!
  type: String!
}

type StandalonePriceStagedChangesRemoved implements MessagePayload {
  stagedChanges: StagedStandalonePrice
  type: String!
}

type StandalonePriceTierAdded implements MessagePayload {
  tier: ProductPriceTier!
  type: String!
}

type StandalonePriceTierRemoved implements MessagePayload {
  tier: ProductPriceTier!
  type: String!
}

type StandalonePriceTiersSet implements MessagePayload {
  previousTiers: [ProductPriceTier!]!
  tiers: [ProductPriceTier!]!
  type: String!
}

input StandalonePriceUpdateAction {
  addPriceTier: AddStandalonePriceTier
  applyStagedChanges: ApplyStagedChanges
  changeActive: ChangeStandalonePriceActive
  changeValue: ChangeStandalonePriceValue
  removePriceTier: RemoveStandalonePriceTier
  removeStagedChanges: RemoveStagedChanges
  setCustomField: SetStandalonePriceCustomFields
  setCustomType: CustomFieldsDraft
  setDiscountedPrice: SetStandalonePriceDiscountedPrice
  setKey: SetStandalonePriceKey
  setPriceTiers: SetStandalonePriceTiers
  setValidFrom: SetStandalonePriceValidFrom
  setValidFromAndUntil: SetStandalonePriceValidFromAndUntil
  setValidUntil: SetStandalonePriceValidUntil
}

type StandalonePriceValidFromAndUntilSet implements MessagePayload {
  previousValidFrom: DateTime
  previousValidUntil: DateTime
  type: String!
  validFrom: DateTime
  validUntil: DateTime
}

type StandalonePriceValidFromSet implements MessagePayload {
  previousValidFrom: DateTime
  type: String!
  validFrom: DateTime
}

type StandalonePriceValidUntilSet implements MessagePayload {
  previousValidUntil: DateTime
  type: String!
  validUntil: DateTime
}

type StandalonePriceValueChanged implements MessagePayload {
  oldValue: BaseMoney
  staged: Boolean!
  type: String!
  value: BaseMoney!
}

"""[State](https://docs.commercetools.com/api/projects/states)"""
type State implements ReferenceExpandable & Versioned {
  builtIn: Boolean!
  createdAt: DateTime!
  createdBy: Initiator
  description(
    """
    List of languages the client is able to understand, and which locale variant is preferred.
    """
    acceptLanguage: [Locale!]

    """
    String is defined for different locales. This argument specifies the desired locale.
    """
    locale: Locale
  ): String
  descriptionAllLocales: [LocalizedString!]
  id: String!
  initial: Boolean!
  key: String
  lastModifiedAt: DateTime!
  lastModifiedBy: Initiator
  name(
    """
    List of languages the client is able to understand, and which locale variant is preferred.
    """
    acceptLanguage: [Locale!]

    """
    String is defined for different locales. This argument specifies the desired locale.
    """
    locale: Locale
  ): String
  nameAllLocales: [LocalizedString!]
  roles: [StateRole!]!
  transitions: [State!]
  transitionsRef: [Reference!]
  type: StateType!
  version: Long!
}

input StateDraft {
  description: [LocalizedStringItemInputType!]
  initial: Boolean
  key: String!
  name: [LocalizedStringItemInputType!]
  roles: [StateRole!]
  transitions: [ReferenceInput!]
  type: StateType!
}

type StateQueryResult {
  count: Int!
  exists: Boolean!
  offset: Int!
  results: [State!]!
  total: Long!
}

enum StateRole {
  Return
  ReviewIncludedInStatistics
}

enum StateType {
  LineItemState
  OrderState
  PaymentState
  ProductState
  QuoteRequestState
  QuoteState
  ReviewState
  StagedQuoteState
}

input StateUpdateAction {
  addRoles: AddStateRoles
  changeInitial: ChangeStateInitial
  changeKey: ChangeStateKey
  changeType: ChangeStateType
  removeRoles: RemoveStateRoles
  setDescription: SetStateDescription
  setName: SetStateName
  setRoles: SetStateRoles
  setTransitions: SetStateTransitions
}

"""Stores allow defining different contexts for a project."""
type Store implements ReferenceExpandable & Versioned {
  countries: [StoreCountry!]
  createdAt: DateTime!
  createdBy: Initiator
  custom: CustomFieldsType
  distributionChannels: [Channel!]!
  distributionChannelsRef: [Reference!]!
  id: String!
  key: String!
  languages: [Locale!]
  lastModifiedAt: DateTime!
  lastModifiedBy: Initiator
  name(
    """
    List of languages the client is able to understand, and which locale variant is preferred.
    """
    acceptLanguage: [Locale!]

    """
    String is defined for different locales. This argument specifies the desired locale.
    """
    locale: Locale
  ): String
  nameAllLocales: [LocalizedString!]
  productSelections: [ProductSelectionSetting!]!
  supplyChannels: [Channel!]!
  supplyChannelsRef: [Reference!]!
  version: Long!
}

type StoreCountriesChanged implements MessagePayload {
  addedCountries: [StoreCountry!]
  removedCountries: [StoreCountry!]
  type: String!
}

type StoreCountry {
  code: Country!
}

input StoreCountryInput {
  code: Country!
}

type StoreCreated implements MessagePayload {
  countries: [StoreCountry!]
  custom: CustomFieldsType
  distributionChannels: [Channel!]!
  distributionChannelsRef: [Reference!]!
  languages: [Locale!]!
  name(
    """
    List of languages the client is able to understand, and which locale variant is preferred.
    """
    acceptLanguage: [Locale!]

    """
    String is defined for different locales. This argument specifies the desired locale.
    """
    locale: Locale
  ): String
  nameAllLocales: [LocalizedString!]
  productSelections: [ProductSelectionSetting!]!
  productSelectionsRef: [Reference!]!
  supplyChannels: [Channel!]!
  supplyChannelsRef: [Reference!]!
  type: String!
}

type StoreDeleted implements MessagePayload {
  type: String!
}

type StoreDistributionChannelsChanged implements MessagePayload {
  addedDistributionChannels: [Channel!]
  addedDistributionChannelsRef: [Reference!]
  removedDistributionChannels: [Channel!]
  removedDistributionChannelsRef: [Reference!]
  type: String!
}

type StoreLanguagesChanged implements MessagePayload {
  addedLanguages: [Locale!]
  removedLanguages: [Locale!]
  type: String!
}

type StoreLimitWithCurrent implements LimitWithCurrent {
  current: Long!
  limit: Long
}

type StoreLimitsProjection {
  inventorySupplyChannels: Limit!
  productDistributionChannels: Limit!
  productSelections: Limit!
  total: StoreLimitWithCurrent!
}

type StoreNameSet implements MessagePayload {
  name(
    """
    List of languages the client is able to understand, and which locale variant is preferred.
    """
    acceptLanguage: [Locale!]

    """
    String is defined for different locales. This argument specifies the desired locale.
    """
    locale: Locale
  ): String
  nameAllLocales: [LocalizedString!]
  type: String!
}

type StoreProductSelectionsChanged implements MessagePayload {
  addedProductSelections: [ProductSelectionSetting!]
  removedProductSelections: [ProductSelectionSetting!]
  type: String!
  updatedProductSelections: [ProductSelectionSetting!]
}

type StoreQueryResult {
  count: Int!
  exists: Boolean!
  offset: Int!
  results: [Store!]!
  total: Long!
}

type StoreSupplyChannelsChanged implements MessagePayload {
  addedSupplyChannels: [Channel!]
  addedSupplyChannelsRef: [Reference!]
  removedSupplyChannels: [Channel!]
  removedSupplyChannelsRef: [Reference!]
  type: String!
}

input StoreUpdateAction {
  addCountry: AddStoreCountry
  addDistributionChannel: AddStoreDistributionChannel
  addProductSelection: AddStoreProductSelection
  addSupplyChannel: AddStoreSupplyChannel
  changeProductSelectionActive: ChangeStoreProductSelectionActive
  removeCountry: RemoveStoreCountry
  removeDistributionChannel: RemoveStoreDistributionChannel
  removeProductSelection: RemoveStoreProductSelection
  removeSupplyChannel: RemoveStoreSupplyChannel
  setCountries: SetStoreCountries
  setCustomField: SetStoreCustomField
  setCustomType: SetStoreCustomType
  setDistributionChannels: SetStoreDistributionChannels
  setLanguages: SetStoreLanguages
  setName: SetStoreName
  setProductSelections: SetStoreProductSelections
  setSupplyChannels: SetStoreSupplyChannels
}

type StringAttribute implements Attribute {
  name: String!
  value: String!
}

type StringField implements CustomField {
  name: String!
  value: String!
}

type StringType implements FieldType {
  name: String!
}

type SubRate {
  amount: Float!
  name: String!
}

input SubRateDraft {
  amount: Float!
  name: String!
}

input SubscriptionDraft {
  changes: [ChangeSubscriptionInput!]
  destination: DestinationInput!
  format: SubscriptionFormatInput
  key: String
  messages: [MessageSubscriptionInput!]
}

input SubscriptionFormatInput {
  CloudEvents: CloudEventsSubscriptionsFormatInput
  Platform: PlatformFormatInput
}

enum SubscriptionHealthStatus {
  ConfigurationError
  ConfigurationErrorDeliveryStopped
  Healthy
  ManuallySuspended
  TemporaryError
}

input SubscriptionUpdateAction {
  changeDestination: ChangeSubscriptionDestination
  setChanges: SetSubscriptionChanges
  setKey: SetSubscriptionKey
  setMessages: SetSubscriptionMessages
}

type SubscriptionsLimitsProjection {
  maxSubscriptions: Limit!
}

type SuggestResult {
  searchKeywords: [SuggestResultEntry!]!
}

type SuggestResultEntry {
  locale: Locale!
  suggestions: [Suggestion!]!
}

interface SuggestTokenizer {
  type: String!
}

interface SuggestTokenizerProductSearch {
  type: String!
}

type Suggestion {
  text: String!
}

"""
Stores information about order synchronization activities (like export or import).
"""
type SyncInfo {
  channel: Channel
  channelRef: Reference!
  externalId: String
  syncedAt: DateTime!
}

input TargetReferenceInput {
  id: String
  key: String
  typeId: String!
}

enum TaxCalculationMode {
  """
  Default. This calculation mode calculates the taxes after the unit price is multiplied with the quantity.
  E.g. `($1.08 * 3 = $3.24) * 1.19 = $3.8556 -> $3.86 rounded`
  """
  LineItemLevel

  """
  This calculation mode calculates the taxes on the unit price before multiplying with the quantity.
  E.g. `($1.08 * 1.19 = $1.2852 -> $1.29 rounded) * 3 = $3.87`
  """
  UnitPriceLevel
}

"""
Tax Categories define how products are to be taxed in different countries.
"""
type TaxCategory implements ReferenceExpandable & Versioned {
  createdAt: DateTime!
  createdBy: Initiator
  description: String
  id: String!
  key: String
  lastModifiedAt: DateTime!
  lastModifiedBy: Initiator
  name: String!
  rates: [TaxRate!]!
  version: Long!
}

input TaxCategoryAddTaxRate {
  taxRate: TaxRateDraft!
}

input TaxCategoryChangeName {
  name: String!
}

input TaxCategoryDraft {
  description: String
  key: String
  name: String!
  rates: [TaxRateDraft!]
}

type TaxCategoryLimitWithCurrent implements LimitWithCurrent {
  current: Long!
  limit: Long
}

type TaxCategoryLimitsProjection {
  total: TaxCategoryLimitWithCurrent!
}

type TaxCategoryQueryResult {
  count: Int!
  exists: Boolean!
  offset: Int!
  results: [TaxCategory!]!
  total: Long!
}

input TaxCategoryRemoveTaxRate {
  taxRateId: String
  taxRateKey: String
}

input TaxCategoryReplaceTaxRate {
  taxRate: TaxRateDraft!
  taxRateId: String
  taxRateKey: String
}

input TaxCategorySetDescription {
  description: String
}

input TaxCategoryUpdateAction {
  addTaxRate: TaxCategoryAddTaxRate
  changeName: TaxCategoryChangeName
  removeTaxRate: TaxCategoryRemoveTaxRate
  replaceTaxRate: TaxCategoryReplaceTaxRate
  setDescription: TaxCategorySetDescription
  setKey: SetTaxCategoryKey
}

enum TaxMode {
  """No taxes are added to the cart."""
  Disabled

  """
  The tax rates are set externally per ExternalTaxRateDraft. A cart with this tax mode can only be ordered if all
  line items, all custom line items and the shipping method have an external tax rate set. The totalNet and
  totalGross as well as the taxPortions fields are calculated according to the taxRoundingMode.
  """
  External

  """
  The tax amounts and the tax rates as well as the tax portions are set externally per ExternalTaxAmountDraft.
  A cart with this tax mode can only be ordered if the cart itself and all line items, all custom line items and
  the shipping method have an external tax amount and rate set
  """
  ExternalAmount

  """
  The tax rates are selected from the TaxCategories based on the cart shipping address.
  The totalNet and totalGross as well as the taxPortions fields are calculated according to the
  taxRoundingMode.
  """
  Platform
}

"""
Represents the portions that sum up to the totalGross field of a TaxedPrice. The portions are calculated
from the TaxRates. If a tax rate has SubRates, they are used and can be identified by name. Tax portions
from line items that have the same rate and name will be accumulated to the same tax portion.
"""
type TaxPortion {
  amount: Money!
  name: String
  rate: Float!
}

input TaxPortionDraft {
  amount: MoneyInput!
  name: String
  rate: Float!
}

type TaxRate {
  amount: Float!
  country: Country!
  id: String
  includedInPrice: Boolean!
  key: String
  name: String!
  state: String
  subRates: [SubRate!]!
}

input TaxRateDraft {
  amount: Float
  country: Country!
  includedInPrice: Boolean!
  key: String
  name: String!
  state: String
  subRates: [SubRateDraft!] = []
}

input TaxRateInput {
  amount: Float!
  country: Country!
  id: String
  includedInPrice: Boolean!
  key: String
  name: String!
  state: String
  subRates: [SubRateDraft!] = []
}

type TaxedItemPrice {
  taxPortions: [TaxPortion!]!
  totalGross: Money!
  totalNet: Money!
  totalTax: Money
}

type TaxedPrice {
  taxPortions: [TaxPortion!]!
  totalGross: Money!
  totalNet: Money!
  totalTax: Money
}

input TaxedPriceDraft {
  taxPortions: [TaxPortionDraft!]!
  totalGross: BaseMoneyInput!
  totalNet: BaseMoneyInput!
  totalTax: BaseMoneyInput
}

type TermCount {
  count: Int!
  productCount: Int
  term: String!
}

input TermsFacetInput {
  alias: String
  countProducts: Boolean! = false
  path: String!
}

type TermsFacetResult implements FacetResult {
  dataType: String!
  missing: Int!
  other: Int!
  terms: [TermCount!]!
  total: Int!
  type: String!
}

type TextAttributeDefinitionType implements AttributeDefinitionType {
  name: String!
}

"""
UI hint telling what kind of edit control should be displayed for a text attribute.
"""
enum TextInputHint {
  MultiLine
  SingleLine
}

type TextLineItem {
  addedAt: DateTime!
  custom: CustomFieldsType
  description(
    """
    List of languages the client is able to understand, and which locale variant is preferred.
    """
    acceptLanguage: [Locale!]

    """
    String is defined for different locales. This argument specifies the desired locale.
    """
    locale: Locale
  ): String
  descriptionAllLocales: [LocalizedString!]
  id: String!
  key: String
  name(
    """
    List of languages the client is able to understand, and which locale variant is preferred.
    """
    acceptLanguage: [Locale!]

    """
    String is defined for different locales. This argument specifies the desired locale.
    """
    locale: Locale
  ): String
  nameAllLocales: [LocalizedString!]!
  quantity: Int!
}

input TextLineItemDraft {
  addedAt: DateTime
  custom: CustomFieldsDraft
  description: [LocalizedStringItemInputType!]
  key: String
  name: [LocalizedStringItemInputType!]!
  quantity: Int = 1
}

"""Time is a scalar value that represents an ISO8601 formatted time."""
scalar Time

type TimeAttribute implements Attribute {
  name: String!
  value: Time!
}

type TimeAttributeDefinitionType implements AttributeDefinitionType {
  name: String!
}

type TimeField implements CustomField {
  name: String!
  value: Time!
}

type TimeType implements FieldType {
  name: String!
}

type TrackingData {
  carrier: String
  isReturn: Boolean!
  provider: String
  providerTransaction: String
  trackingId: String
}

input TrackingDataDraftType {
  carrier: String
  isReturn: Boolean = false
  provider: String
  providerTransaction: String
  trackingId: String
}

type Transaction {
  amount: Money!
  custom: CustomFieldsType
  id: String!
  interactionId: String
  state: TransactionState!
  timestamp: DateTime
  type: TransactionType
}

input TransactionDraft {
  amount: MoneyInput!
  custom: CustomFieldsDraft
  interactionId: String
  state: TransactionState
  timestamp: DateTime
  type: TransactionType!
}

enum TransactionState {
  Failure
  Initial
  Pending
  Success
}

enum TransactionType {
  Authorization
  CancelAuthorization
  Charge
  Chargeback
  Refund
}

input TransitionOrderCustomLineItemState {
  actualTransitionDate: DateTime
  customLineItemId: String
  customLineItemKey: String
  fromState: ResourceIdentifierInput!
  quantity: Long!
  toState: ResourceIdentifierInput!
}

input TransitionOrderLineItemState {
  actualTransitionDate: DateTime
  fromState: ResourceIdentifierInput!
  lineItemId: String
  lineItemKey: String
  quantity: Long!
  toState: ResourceIdentifierInput!
}

input TransitionOrderState {
  force: Boolean = false
  state: ResourceIdentifierInput!
}

input TransitionPaymentState {
  force: Boolean = false
  state: ResourceIdentifierInput!
}

input TransitionProductState {
  force: Boolean
  state: ReferenceInput!
}

input TransitionQuoteRequestState {
  force: Boolean = false
  state: ResourceIdentifierInput!
}

input TransitionQuoteState {
  force: Boolean = false
  state: ResourceIdentifierInput!
}

input TransitionReviewState {
  force: Boolean = false
  state: ResourceIdentifierInput!
}

input TransitionStagedOrderCustomLineItemState {
  actualTransitionDate: DateTime
  customLineItemId: String
  customLineItemKey: String
  fromState: ResourceIdentifierInput!
  quantity: Long!
  toState: ResourceIdentifierInput!
}

type TransitionStagedOrderCustomLineItemStateOutput implements StagedOrderUpdateActionOutput {
  actualTransitionDate: DateTime
  customLineItemId: String
  customLineItemKey: String
  fromStateResId: ResourceIdentifier!
  quantity: Long!
  toStateResId: ResourceIdentifier!
  type: String!
}

input TransitionStagedOrderLineItemState {
  actualTransitionDate: DateTime
  fromState: ResourceIdentifierInput!
  lineItemId: String
  lineItemKey: String
  quantity: Long!
  toState: ResourceIdentifierInput!
}

type TransitionStagedOrderLineItemStateOutput implements StagedOrderUpdateActionOutput {
  actualTransitionDate: DateTime
  fromStateResId: ResourceIdentifier!
  lineItemId: String
  lineItemKey: String
  quantity: Long!
  toStateResId: ResourceIdentifier!
  type: String!
}

input TransitionStagedOrderState {
  force: Boolean = false
  state: ResourceIdentifierInput!
}

type TransitionStagedOrderStateOutput implements StagedOrderUpdateActionOutput {
  force: Boolean!
  stateResId: ResourceIdentifier!
  type: String!
}

input TransitionStagedQuoteState {
  force: Boolean = false
  state: ResourceIdentifierInput!
}

input TreeFilterInput {
  path: String!
  rootValues: [String!]!
  subTreeValues: [String!]!
}

type Trigger {
  actions: [ActionType!]!
  condition: String
  resourceTypeId: String!
}

input TriggerInput {
  actions: [ActionType!]
  condition: String
  resourceTypeId: String!
}

"""
Types allow you to define additional project-specific fields on resources and data types, so-called Custom Fields.
"""
type TypeDefinition implements ReferenceExpandable & Versioned {
  createdAt: DateTime!
  createdBy: Initiator
  description(
    """
    List of languages the client is able to understand, and which locale variant is preferred.
    """
    acceptLanguage: [Locale!]

    """
    String is defined for different locales. This argument specifies the desired locale.
    """
    locale: Locale
  ): String
  descriptionAllLocales: [LocalizedString!]
  fieldDefinitions(
    """
    The names of the custom field definitions to exclude.
    
    If neither `includeNames` nor `excludeNames` are provided, then all custom fields are returned.
    """
    excludeNames: [String!]

    """
    The names of the custom field definitions to include.
    
    If neither `includeNames` nor `excludeNames` are provided, then all custom fields are returned.
    """
    includeNames: [String!]
  ): [FieldDefinition!]!
  id: String!
  key: String!
  lastModifiedAt: DateTime!
  lastModifiedBy: Initiator
  name(
    """
    List of languages the client is able to understand, and which locale variant is preferred.
    """
    acceptLanguage: [Locale!]

    """
    String is defined for different locales. This argument specifies the desired locale.
    """
    locale: Locale
  ): String
  nameAllLocales: [LocalizedString!]!
  resourceTypeIds: [String!]!
  version: Long!
}

input TypeDefinitionDraft {
  description: [LocalizedStringItemInputType!]
  fieldDefinitions: [FieldDefinitionInput!]
  key: String!
  name: [LocalizedStringItemInputType!]!
  resourceTypeIds: [String!]!
}

type TypeDefinitionQueryResult {
  count: Int!
  exists: Boolean!
  offset: Int!
  results: [TypeDefinition!]!
  total: Long!
}

input TypeUpdateAction {
  addEnumValue: AddTypeEnumValue
  addFieldDefinition: AddTypeFieldDefinition
  addLocalizedEnumValue: AddTypeLocalizedEnumValue
  changeEnumValueLabel: ChangeTypeEnumValueLabel
  changeEnumValueOrder: ChangeTypeEnumValueOrder
  changeFieldDefinitionOrder: ChangeTypeFieldDefinitionOrder
  changeInputHint: ChangeTypeInputHint
  changeKey: ChangeTypeKey
  changeLabel: ChangeTypeLabel
  changeLocalizedEnumValueLabel: ChangeTypeLocalizedEnumValueLabel
  changeLocalizedEnumValueOrder: ChangeTypeLocalizedEnumValueOrder
  changeName: ChangeTypeName
  removeFieldDefinition: RemoveTypeFieldDefinition
  setDescription: SetTypeDescription
}

input UnfreezeCart {
  dummy: String
}

input UnpublishProduct {
  dummy: String
}

input UnpublishTailoring {
  dummy: String
}

input UpdateCartItemShippingAddress {
  address: AddressInput!
}

input UpdateOrderItemShippingAddress {
  address: AddressInput!
}

input UpdateOrderSyncInfo {
  channel: ResourceIdentifierInput!
  externalId: String
  syncedAt: DateTime
}

input UpdateStagedOrderItemShippingAddress {
  address: AddressInput!
}

type UpdateStagedOrderItemShippingAddressOutput implements StagedOrderUpdateActionOutput {
  address: AddressDraft!
  type: String!
}

input UpdateStagedOrderSyncInfo {
  channel: ResourceIdentifierInput!
  externalId: String
  syncedAt: DateTime
}

type UpdateStagedOrderSyncInfoOutput implements StagedOrderUpdateActionOutput {
  channelResId: ChannelReferenceIdentifier!
  externalId: String
  syncedAt: DateTime
  type: String!
}

type UserProvidedIdentifiers {
  customerNumber: String
  externalId: String
  key: String
  orderNumber: String
  sku: String
  slug(
    """
    List of languages the client is able to understand, and which locale variant is preferred.
    """
    acceptLanguage: [Locale!]

    """
    String is defined for different locales. This argument specifies the desired locale.
    """
    locale: Locale
  ): String
  slugAllLocales: [LocalizedString!]
}

type ValueFacetResult implements FacetResult {
  count: Int!
  productCount: Int
  type: String!
}

input ValueFilterInput {
  path: String!
  values: [String!]!
}

"""
Versioned object have an ID and version and modification. Every update of this object changes it's version.
"""
interface Versioned {
  createdAt: DateTime!
  createdBy: Initiator
  id: String!
  lastModifiedAt: DateTime!
  lastModifiedBy: Initiator
  version: Long!
}

type WhitespaceSuggestTokenizer implements SuggestTokenizer {
  type: String!
}

input WhitespaceSuggestTokenizerInput {
  dummy: String
}

type WhitespaceSuggestTokenizerProductSearch implements SuggestTokenizerProductSearch {
  type: String!
}

"""
YearMonth is a scalar value that represents an ISO8601 formatted year and month.
"""
scalar YearMonth

"""Zones allow defining ShippingRates for specific Locations."""
type Zone implements ReferenceExpandable & Versioned {
  createdAt: DateTime!
  createdBy: Initiator
  description: String
  id: String!
  key: String
  lastModifiedAt: DateTime!
  lastModifiedBy: Initiator
  locations: [Location!]!
  name: String!
  version: Long!
}

type ZoneLimitWithCurrent implements LimitWithCurrent {
  current: Long!
  limit: Long
}

type ZoneLimitsProjection {
  total: ZoneLimitWithCurrent!
}

input ZoneLocation {
  country: Country!
  state: String
}

type ZoneQueryResult {
  count: Int!
  exists: Boolean!
  offset: Int!
  results: [Zone!]!
  total: Long!
}

type ZoneRate {
  shippingRates: [ShippingRate!]!
  zone: Zone
  zoneRef: Reference
}

input ZoneRateDraft {
  shippingRates: [ShippingRateDraft!] = []
  zone: ResourceIdentifierInput!
}

input ZoneUpdateAction {
  addLocation: AddZoneLocation
  changeName: ChangeZoneName
  removeLocation: RemoveZoneLocation
  setDescription: SetZoneDescription
  setKey: SetZoneKey
}

input addAttributeDefinition {
  attributeDefinition: AttributeDefinitionDraft!
}

input addLocalizedEnumValue {
  attributeName: String!
  value: LocalizedEnumValueDraft!
}

input addPlainEnumValue {
  attributeName: String!
  value: PlainEnumValueDraft!
}

input changeAttributeName {
  attributeName: String!
  newAttributeName: String!
}

input changeAttributeOrder {
  attributeDefinitions: [AttributeDefinitionDraft!]!
}

input changeAttributeOrderByName {
  attributeNames: [String!]!
}

input changeDescription {
  description: String!
}

input changeEnumKey {
  attributeName: String!
  key: String!
  newKey: String!
}

input changeInputHint {
  attributeName: String!
  newValue: TextInputHint!
}

input changeIsSearchable {
  attributeName: String!
  isSearchable: Boolean!
}

input changeLabel {
  attributeName: String!
  label: [LocalizedStringItemInputType!]!
}

input changeLocalizedEnumValueLabel {
  attributeName: String!
  newValue: LocalizedEnumValueDraft!
}

input changeLocalizedEnumValueOrder {
  attributeName: String!
  values: [LocalizedEnumValueDraft!]!
}

input changeName {
  name: String!
}

input changePlainEnumValueLabel {
  attributeName: String!
  newValue: PlainEnumValueDraft!
}

input changePlainEnumValueOrder {
  attributeName: String!
  values: [PlainEnumValueDraft!]!
}

input removeAttributeDefinition {
  name: String!
}

input removeEnumValues {
  attributeName: String!
  keys: [String!]!
}

input setInputTip {
  attributeName: String!
  inputTip: [LocalizedStringItemInputType!]
}

input setKey {
  key: String
}